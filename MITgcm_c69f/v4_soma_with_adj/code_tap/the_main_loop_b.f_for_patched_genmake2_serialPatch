C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) - 20 Jun 2024 17:41
C
C  Differentiation of the_main_loop in reverse (adjoint) mode:
C   gradient     of useful results: fc
C   with respect to varying inputs: xx_genarr2d_dummy xx_genarr3d_dummy
C                xx_gentim2d_dummy fc
C   RW status of diff variables: xx_genarr2d_dummy:out xx_genarr3d_dummy:out
C                xx_gentim2d_dummy:out fc:in-out
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
CBOP
C !ROUTINE: CPP_OPTIONS.h
C !INTERFACE:
C #include "CPP_OPTIONS.h"
C
C !DESCRIPTION:
C *==================================================================*
C | main CPP options file for the model:
C | Control which optional features to compile in model/src code.
C *==================================================================*
CEOP
C
C CPP flags controlling particular source code features
C
C-- Forcing code options:
C
C o Shortwave heating as extra term in external_forcing.F
C Note: this should be a run-time option
C
C o Include/exclude Geothermal Heat Flux at the bottom of the ocean
C
C o Allow to account for heating due to friction (and momentum dissipation)
C
C o Allow mass source or sink of Fluid in the interior
C   (3-D generalisation of oceanic real-fresh water flux)
C
C o Include pressure loading code
C
C o Include/exclude balancing surface forcing fluxes code
C
C o Include/exclude balancing surface forcing relaxation code
C
C o Include/exclude checking for negative salinity
C
C-- Options to discard parts of the main code:
C
C o Exclude/allow external forcing-fields load
C   this allows to read & do simple linear time interpolation of oceanic
C   forcing fields, if no specific pkg (e.g., EXF) is used to compute them.
C   If defined, use same method (with pkg/autodiff compiled or not) for checking
C   when to load new reccord ; by default, use simpler method with pkg/autodiff.
C
C o Include/exclude phi_hyd calculation code
C
C o Include/exclude sound speed calculation code
C o (Note that this is a diagnostic from Del Grasso algorithm, not derived
C    from EOS)
C
C-- Vertical mixing code options:
C
C o Include/exclude calling S/R CONVECTIVE_ADJUSTMENT
C
C o Include/exclude calling S/R CONVECTIVE_ADJUSTMENT_INI, turned off by
C   default because it is an unpopular historical left-over
C
C o Include/exclude call to S/R CALC_DIFFUSIVITY
C
C o Allow full 3D specification of vertical diffusivity
C
C o Allow latitudinally varying BryanLewis79 vertical diffusivity
C
C o Exclude/allow partial-cell effect (physical or enhanced) in vertical mixing
C   this allows to account for partial-cell in vertical viscosity and diffusion,
C   either from grid-spacing reduction effect or as artificially enhanced mixing
C   near surface & bottom for too thin grid-cell
C
C o Exclude/allow to use isotropic 3-D Smagorinsky viscosity as diffusivity
C   for tracers (after scaling by constant Prandtl number)
C
C-- Time-stepping code options:
C
C o Include/exclude combined Surf.Pressure and Drag Implicit solver code
C
C o Include/exclude Implicit vertical advection code
C
C o Include/exclude AdamsBashforth-3rd-Order code
C
C o Include/exclude Quasi-Hydrostatic Stagger Time-step AdamsBashforth code
C
C-- Model formulation options:
C
C o Allow/exclude "Exact Convervation" of fluid in Free-Surface formulation
C   that ensures that d/dt(eta) is exactly equal to - Div.Transport
C
C o Allow the use of Non-Linear Free-Surface formulation
C   this implies that grid-cell thickness (hFactors) varies with time
C o Disable code for rStar coordinate and/or code for Sigma coordinate
C#define DISABLE_RSTAR_CODE
C
C o Include/exclude nonHydrostatic code
C
C o Include/exclude GM-like eddy stress in momentum code
C
C-- Algorithm options:
C
C o Include/exclude code for Non Self-Adjoint (NSA) conjugate-gradient solver
C
C o Include/exclude code for single reduction Conjugate-Gradient solver
C
C o Choices for implicit solver routines solve_*diagonal.F
C   The following has low memory footprint, but not suitable for AD
C   The following one suitable for AD but does not vectorize
C
C   Implementation alternative (might be faster on some platforms ?)
C
C-- Retired code options:
C
C o ALLOW isotropic scaling of harmonic and bi-harmonic terms when
C   using an locally isotropic spherical grid with (dlambda) x (dphi*cos(phi))
C *only for use on a lat-lon grid*
C   Setting this flag here affects both momentum and tracer equation unless
C   it is set/unset again in other header fields (e.g., GAD_OPTIONS.h).
C   The definition of the flag is commented to avoid interference with
C   such other header files.
C   The preferred method is specifying a value for viscAhGrid or viscA4Grid
C   in data which is then automatically scaled by the grid size;
C   the old method of specifying viscAh/viscA4 and this flag is provided
C   for completeness only (and for use with the adjoint).
C#define ISOTROPIC_COS_SCALING
C
C o This flag selects the form of COSINE(lat) scaling of bi-harmonic term.
C *only for use on a lat-lon grid*
C   Has no effect if ISOTROPIC_COS_SCALING is undefined.
C   Has no effect on vector invariant momentum equations.
C   Setting this flag here affects both momentum and tracer equation unless
C   it is set/unset again in other header fields (e.g., GAD_OPTIONS.h).
C   The definition of the flag is commented to avoid interference with
C   such other header files.
C#define COSINEMETH_III
C
C o Use LONG.bin, LATG.bin, etc., initialization for ini_curviliear_grid.F
C   Default is to use "new" grid files (OLD_GRID_IO undef) but OLD_GRID_IO
C   is still useful with, e.g., single-domain curvilinear configurations.
C
C-- Other option files:
C
C o Execution environment support options
C
CBOP
C     !ROUTINE: CPP_EEOPTIONS.h
C     !INTERFACE:
C     include "CPP_EEOPTIONS.h"
C
C     !DESCRIPTION:
C     *==========================================================*
C     | CPP\_EEOPTIONS.h                                         |
C     *==========================================================*
C     | C preprocessor "execution environment" supporting        |
C     | flags. Use this file to set flags controlling the        |
C     | execution environment in which a model runs - as opposed |
C     | to the dynamical problem the model solves.               |
C     | Note: Many options are implemented with both compile time|
C     |       and run-time switches. This allows options to be   |
C     |       removed altogether, made optional at run-time or   |
C     |       to be permanently enabled. This convention helps   |
C     |       with the data-dependence analysis performed by the |
C     |       adjoint model compiler. This data dependency       |
C     |       analysis can be upset by runtime switches that it  |
C     |       is unable to recoginise as being fixed for the     |
C     |       duration of an integration.                        |
C     |       A reasonable way to use these flags is to          |
C     |       set all options as selectable at runtime but then  |
C     |       once an experimental configuration has been        |
C     |       identified, rebuild the code with the appropriate  |
C     |       options set at compile time.                       |
C     *==========================================================*
CEOP
C
C     In general the following convention applies:
C     ALLOW  - indicates an feature will be included but it may
C     CAN      have a run-time flag to allow it to be switched
C              on and off.
C              If ALLOW or CAN directives are "undef'd" this generally
C              means that the feature will not be available i.e. it
C              will not be included in the compiled code and so no
C              run-time option to use the feature will be available.
C
C     ALWAYS - indicates the choice will be fixed at compile time
C              so no run-time option will be present
C
C=== Macro related options ===
C--   Control storage of floating point operands
C     On many systems it improves performance only to use
C     8-byte precision for time stepped variables.
C     Constant in time terms ( geometric factors etc.. )
C     can use 4-byte precision, reducing memory utilisation and
C     boosting performance because of a smaller working set size.
C     However, on vector CRAY systems this degrades performance.
C     Enable to switch REAL4_IS_SLOW from genmake2 (with LET_RS_BE_REAL4):
C
C--   Control use of "double" precision constants.
C     Use D0 where it means REAL*8 but not where it means REAL*16
C
C=== IO related options ===
C--   Flag used to indicate whether Fortran formatted write
C     and read are threadsafe. On SGI the routines can be thread
C     safe, on Sun it is not possible - if you are unsure then
C     undef this option.
C
C--   Flag used to indicate whether Binary write to Local file (i.e.,
C     a different file for each tile) and read are thread-safe.
C
C--   Flag to turn off the writing of error message to ioUnit zero
C
C--   Flag to turn on old default of opening scratch files with the
C     STATUS='SCRATCH' option. This method, while perfectly FORTRAN-standard,
C     caused filename conflicts on some multi-node/multi-processor platforms
C     in the past and has been replace by something (hopefully) more robust.
C
C--   Flag defined for eeboot_minimal.F, eeset_parms.F and open_copy_data_file.F
C     to write STDOUT, STDERR and scratch files from process 0 only.
C WARNING: to use only when absolutely confident that the setup is working
C     since any message (error/warning/print) from any proc <> 0 will be lost.
C
C=== MPI, EXCH and GLOBAL_SUM related options ===
C--   Flag turns off MPI_SEND ready_to_receive polling in the
C     gather_* subroutines to speed up integrations.
C
C--   Control MPI based parallel processing
CXXX We no longer select the use of MPI via this file (CPP_EEOPTIONS.h)
CXXX To use MPI, use an appropriate genmake2 options file or use
CXXX genmake2 -mpi .
CXXX #undef  ALLOW_USE_MPI
C
C--   Control use of communication that might overlap computation.
C     Under MPI selects/deselects "non-blocking" sends and receives.
C--   Control use of communication that is atomic to computation.
C     Under MPI selects/deselects "blocking" sends and receives.
C
C--   Control XY periodicity in processor to grid mappings
C     Note: Model code does not need to know whether a domain is
C           periodic because it has overlap regions for every box.
C           Model assume that these values have been
C           filled in some way.
C
C--   disconnect tiles (no exchange between tiles, just fill-in edges
C     assuming locally periodic subdomain)
C
C--   Always cumulate tile local-sum in the same order by applying MPI allreduce
C     to array of tiles ; can get slower with large number of tiles (big set-up)
C
C--   Alternative way of doing global sum without MPI allreduce call
C     but instead, explicit MPI send & recv calls. Expected to be slower.
C
C--   Alternative way of doing global sum on a single CPU
C     to eliminate tiling-dependent roundoff errors. Note: This is slow.
C
C=== Other options (to add/remove pieces of code) ===
C--   Flag to turn on checking for errors from all threads and procs
C     (calling S/R STOP_IF_ERROR) before stopping.
C
C--   Control use of communication with other component:
C     allow to import and export from/to Coupler interface.
C
C--   Activate some pieces of code for coupling to GEOS AGCM
C
C=== And define Macros ===
CBOP
C     !ROUTINE: CPP_EEMACROS.h
C     !INTERFACE:
C     include "CPP_EEMACROS.h"
C     !DESCRIPTION:
C     *==========================================================*
C     | CPP_EEMACROS.h
C     *==========================================================*
C     | C preprocessor "execution environment" supporting
C     | macros. Use this file to define macros for  simplifying
C     | execution environment in which a model runs - as opposed
C     | to the dynamical problem the model solves.
C     *==========================================================*
CEOP
C
C
C     In general the following convention applies:
C     ALLOW  - indicates an feature will be included but it may
C     CAN      have a run-time flag to allow it to be switched
C              on and off.
C              If ALLOW or CAN directives are "undef'd" this generally
C              means that the feature will not be available i.e. it
C              will not be included in the compiled code and so no
C              run-time option to use the feature will be available.
C
C     ALWAYS - indicates the choice will be fixed at compile time
C              so no run-time option will be present
C
C     Flag used to indicate which flavour of multi-threading
C     compiler directives to use. Only set one of these.
C     USE_SOLARIS_THREADING  - Takes directives for SUN Workshop
C                              compiler.
C     USE_KAP_THREADING      - Takes directives for Kuck and
C                              Associates multi-threading compiler
C                              ( used on Digital platforms ).
C     USE_IRIX_THREADING     - Takes directives for SGI MIPS
C                              Pro Fortran compiler.
C     USE_EXEMPLAR_THREADING - Takes directives for HP SPP series
C                              compiler.
C     USE_C90_THREADING      - Takes directives for CRAY/SGI C90
C                              system F90 compiler.
C
C
C
C
C
C
C--   Define the mapping for the _BARRIER macro
C     On some systems low-level hardware support can be accessed through
C     compiler directives here.
C
C--   Define the mapping for the BEGIN_CRIT() and  END_CRIT() macros.
C     On some systems we simply execute this section only using the
C     master thread i.e. its not really a critical section. We can
C     do this because we do not use critical sections in any critical
C     sections of our code!
C
C--   Define the mapping for the BEGIN_MASTER_SECTION() and
C     END_MASTER_SECTION() macros. These are generally implemented by
C     simply choosing a particular thread to be "the master" and have
C     it alone execute the BEGIN_MASTER..., END_MASTER.. sections.
C
CcnhDebugStarts
C      Alternate form to the above macros that increments (decrements) a counter each
C      time a MASTER section is entered (exited). This counter can then be checked in barrier
C      to try and detect calls to BARRIER within single threaded sections.
C      Using these macros requires two changes to Makefile - these changes are written
C      below.
C      1 - add a filter to the CPP command to kill off commented _MASTER lines
C      2 - add a filter to the CPP output the converts the string N EWLINE to an actual newline.
C      The N EWLINE needs to be changes to have no space when this macro and Makefile changes
C      are used. Its in here with a space to stop it getting parsed by the CPP stage in these
C      comments.
C      #define IF ( a .EQ. 1 ) THEN  IF ( a .EQ. 1 ) THEN  N EWLINE      CALL BARRIER_MS(a)
C      #define ENDIF    CALL BARRIER_MU(a) N EWLINE        ENDIF
C      'CPP = cat $< | $(TOOLSDIR)/set64bitConst.sh |  grep -v '^[cC].*_MASTER' | cpp  -traditional -P'
C      .F.f:
C      $(CPP) $(DEFINES) $(INCLUDES) |  sed 's/N EWLINE/\n/' > $@
CcnhDebugEnds
C
C--   Control storage of floating point operands
C     On many systems it improves performance only to use
C     8-byte precision for time stepped variables.
C     Constant in time terms ( geometric factors etc.. )
C     can use 4-byte precision, reducing memory utilisation and
C     boosting performance because of a smaller working
C     set size. However, on vector CRAY systems this degrades
C     performance.
C- Note: global_sum/max macros were used to switch to  JAM routines (obsolete);
C  in addition, since only the R4 & R8 S/R are coded, GLOBAL RS & RL macros
C  enable to call the corresponding R4 or R8 S/R.
C
C
C
C- Note: a) exch macros were used to switch to  JAM routines (obsolete)
C        b) exch R4 & R8 macros are not practically used ; if needed,
C           will directly call the corrresponding S/R.
C
C--   Control use of JAM routines for Artic network (no longer supported)
C     These invoke optimized versions of "exchange" and "sum" that
C     utilize the programmable aspect of Artic cards.
CXXX No longer supported ; started to remove JAM routines.
CXXX #ifdef LETS_MAKE_JAM
CXXX #define CALL GLOBAL_SUM_R8 ( a, b) CALL GLOBAL_SUM_R8_JAM ( a, b)
CXXX #define CALL GLOBAL_SUM_R8 ( a, b ) CALL GLOBAL_SUM_R8_JAM ( a, b )
CXXX #define CALL EXCH_XY_RS ( a, b ) CALL EXCH_XY_R8_JAM ( a, b )
CXXX #define CALL EXCH_XY_RL ( a, b ) CALL EXCH_XY_R8_JAM ( a, b )
CXXX #define CALL EXCH_XYZ_RS ( a, b ) CALL EXCH_XYZ_R8_JAM ( a, b )
CXXX #define CALL EXCH_XYZ_RL ( a, b ) CALL EXCH_XYZ_R8_JAM ( a, b )
CXXX #endif
C
C--   Control use of "double" precision constants.
C     Use d0 where it means REAL*8 but not where it means REAL*16
C
C--   Substitue for 1.D variables
C     Sun compilers do not use 8-byte precision for literals
C     unless .Dnn is specified. CRAY vector machines use 16-byte
C     precision when they see .Dnn which runs very slowly!
C
C--   Set the format for writing processor IDs, e.g. in S/R eeset_parms
C     and S/R open_copy_data_file. The default of I9.9 should work for
C     a long time (until we will use 10e10 processors and more)
C
C--   Set the format for writing ensemble task IDs in S/R eeset_parms
C     and S/R open_copy_data_file.
C
C--   Set ACTION= in OPEN instruction for input file (before doing IO)
C     leave it empty (if EXCLUDE_OPEN_ACTION) or set it to proper value
C
C
C
C o Include/exclude single header file containing multiple packages options
C   (AUTODIFF, COST, CTRL, ECCO, EXF ...) instead of the standard way where
C   each of the above pkg get its own options from its specific option file.
C   Although this method, inherited from ECCO setup, has been traditionally
C   used for all adjoint built, work is in progress to allow to use the
C   standard method also for adjoint built.
C#ifdef 
C# include "ECCO_CPPOPTIONS.h"
C#endif
C
C
CBOP
C !ROUTINE: AUTODIFF_OPTIONS.h
C !INTERFACE:
C #include "AUTODIFF_OPTIONS.h"
C
C !DESCRIPTION:
C *==================================================================*
C | CPP options file for AutoDiff (autodiff) package:
C | Control which optional features to compile in this package code.
C *==================================================================*
CEOP
C
C   ==================================================================
C-- Package-specific Options & Macros go here
C
C o Include/exclude code in order to automatically differentiate MITgcm code
C   using TAF (Transformation of Algorithms in Fortran, http://www.FastOpt.de)
C   or using TAMC (Tangent Linear & Adjoint Model Compiler, needs both defined):
C
C       >>> Checkpointing as handled by TAMC
C
C       >>> Extract adjoint state
C       >>> and DYNVARS_DIAG adjoint state
C
C       >>> DO 2-level checkpointing instead of 3-level
C
C extend to 4-level checkpointing
C
C o use divided adjoint to split adjoint computations
C
C o This flag is incredibly useful as it reduces the number of
C   tape-files on the disc. Maybe it should even be the default.
C   and related to above:
C
C o use standard MDSFINDUINTS instead of local pkg/autodiff version for
C   WHTAPEIO code I/O.
C   Note: comment out the #define below (instead of having an #undef) to
C   enable to set this Option in CPP command line (from the optfile)
C#define AUTODIFF_USE_MDSFINDUNITS
C
C o use the deprecated autodiff_store/restore method where multiple fields
C   are collected in a single buffer field array before storing to tape.
C   This functionality has been replaced by WHTAPEIO method (see above).
C   Might still be used for OBCS since WHTAPEIO does not support OBCS fields.
C
C o allow using viscFacInAd to recompute viscosities in AD
C
C o To remove part of MOM_CALC_VISC (better name would be: MOM_DISABLE_*)
C
C o for output of AD-variables (), specific code (e.g.,
C   in addummy_in_stepping.F) relies on adexch_uv_xy_rs and adexch_xy_rs S/R
C   which might not always be generated by TAF (e.g., when controls do not
C   include any 2D forcing field). In those cases, defining this cpp-option
C   allows to circumvent this missing code issue.
C
C   ==================================================================
CBOP
C !ROUTINE: GAD_OPTIONS.h
C
C !INTERFACE:
C #include "GAD_OPTIONS.h"
C
C !DESCRIPTION:
C Contains CPP macros/flags for controlling optional features of package.
CEOP
C
C CPP options file for GAD (Generic Advection Diffusion) package
C Use this file for selecting options within the GAD package
C
C
C     Package-specific Options & Macros go here
C
C This flag selects the form of COSINE(lat) scaling of horizontal
C bi-harmonic diffusivity -- only on lat-lon grid.
C Setting this flag here only affects tracer diffusivity; to use it
C in the momentum equations it needs to be set in MOM_COMMON_OPTIONS.h
C
C This selects isotropic scaling of horizontal harmonic and bi-harmonic
C diffusivity when using the COSINE(lat) scaling -- only on lat-lon grid.
C Setting this flag here only affects tracer diffusivity; to use it
C in the momentum equations it needs to be set in MOM_COMMON_OPTIONS.h
C
C As of checkpoint41, the inclusion of multi-dimensional advection
C introduces excessive recomputation/storage for the adjoint.
C We can disable it here using CPP because run-time flags are insufficient.
C
C Use compressible flow method for multi-dim advection instead of old, less
C accurate jmc method. Note: option has no effect on SOM advection which
C always use compressible flow method.
C
C This enable the use of 2nd-Order Moment advection scheme (Prather, 1986) for
C Temperature and Salinity ; due to large memory space (10 times more / tracer)
C requirement, by default, this part of the code is not compiled.
C
C Hack to get rid of negatives caused by Redi.  Works by restricting the
C outgoing flux (only contributions computed in gad_calc_rhs) for each cell
C to be no more than the amount of tracer in the cell (see Smolarkiewicz
C MWR 1989 and Bott MWR 1989).
C The flux contributions computed in gad_calc_rhs which are affected by
C this hack are:
C - explicit diffusion, Redi and the non-local part of KPP
C - advection is affected only if multiDimAdvection=.FALSE.
C - vertical diffusion (including the diagonal contribution from GMRedi)
C   only if implicitDiffusion=.FALSE.
C - GM is affected only if GMREDI_AdvForm=.FALSE.
C
C The parameter SmolarkiewiczMaxFrac (defined in gad_init_fixed.F)
C specifies the maximal fraction of tracer that can leave a cell.
C By default it is 1.  This will prevent the tracer from going negative
C due to contributions from gad_calc_rhs alone.  In the presence of other
C contributions (or roundoff errors), it may be necessary to reduce this
C value to achieve strict positivity.
C
C This hack applies to all tracers except temperature and salinity!
C Do not use with Adams-Bashforth (for ptracers)!
C Do not use with OBCS!
C
C
CBOP
C !ROUTINE: GMREDI_OPTIONS.h
C !INTERFACE:
C #include "GMREDI_OPTIONS.h"
C
C !DESCRIPTION:
C *==================================================================*
C | CPP options file for GM/Redi package:
C | Control which optional features to compile in this package code.
C *==================================================================*
CEOP
C
C     Package-specific Options & Macros go here
C
C Designed to simplify the Ajoint code:
C #define GMREDI_WITH_STABLE_ADJOINT
C -- exclude the clipping/tapering part of the code that is not used
C
C Allows to read-in background 3-D Redi and GM diffusivity coefficients
C Note: need these to be defined for use as control (pkg/ctrl) parameters
C
C This allows to use Visbeck et al formulation to compute K_GM+Redi
C Use old calculation (before 2007/05/24) of Visbeck etal K_GM+Redi
C (which depends on tapering scheme)
C
C This allows the Bates et al formulation to calculate the
C bolus transport and K for Redi
C
C This allows the leading diagonal (top two rows) to be non-unity
C (a feature required when tapering adiabatically).
C
C Allows to use different values of K_GM and K_Redi ; also to
C be used with the advective form (Bolus velocity) of GM
C
C Allows to use the advective form (Bolus velocity) of GM
C  instead of the Skew-Flux form (=default)
C
C Allows to use the Boundary-Value-Problem method to evaluate GM Bolus transport
C
C Allow QG Leith variable viscosity to be added to GMRedi coefficient
C
C Related to Adjoint-code:
C
C
C     *==========================================================*
C     | SEAICE_OPTIONS.h
C     | o CPP options file for sea ice package.
C     *==========================================================*
C     | Use this file for selecting options within the sea ice
C     | package.
C     *==========================================================*
C
C---  Package-specific Options & Macros go here
C
C--   Write "text-plots" of certain fields in STDOUT for debugging.
C
C--   By default, the sea-ice package uses its own integrated bulk
C     formulae to compute fluxes (fu, fv, EmPmR, Qnet, and Qsw) over
C     open-ocean.  When this flag is set, these variables are computed
C     in a separate external package, for example, pkg/exf, and then
C     modified for sea-ice effects by pkg/seaice.
C
C--   This CPP flag has been retired.  The number of ice categories
C     used to solve for seaice flux is now specified by run-time
C     parameter SEAICE_multDim.
C     Note: be aware of pickup_seaice.* compatibility issues when
C     restarting a simulation with a different number of categories.
C#define SEAICE_MULTICATEGORY
C
C--   run with sea Ice Thickness Distribution (ITD);
C     set number of categories (nITD) in SEAICE_SIZE.h
C
C--   Since the missing sublimation term is now included
C     this flag is needed for backward compatibility
C
C--   Suspected missing term in coupled ocn-ice heat budget (to be confirmed)
C
C--   Default is constant seaice salinity (SEAICE_salt0); Define the following
C     flag to consider (space & time) variable salinity: advected and forming
C     seaice with a fraction (=SEAICE_saltFrac) of freezing seawater salinity.
C- Note: SItracer also offers an alternative way to handle variable salinity.
C
C--   Enable grease ice parameterization (requires to define ALLOW_SITRACER):
C     The grease ice parameterization delays formation of solid sea ice from
C     frazil ice by a time constant and provides a dynamic calculation of the
C     initial solid sea ice thickness HO as a function of winds, currents and
C     available grease ice volume. Grease ice does not significantly reduce heat
C     loss from the ocean in winter and area covered by grease is thus handled
C     like open water (For details see Smedsrud and Martin, 2014, Ann.Glac.).
C     Set SItrName(1) = 'grease' in namelist SEAICE_PARM03 in data.seaice
C     then output SItr01 is SItrNameLong(1) = 'grease ice volume fraction',
C     with SItrUnit(1) = '[0-1]', which needs to be multiplied by SIheff to
C     yield grease ice volume. Additionally, the actual grease ice layer
C     thickness (diagnostic SIgrsLT) can be saved.
C
C--   Tracers of ice and/or ice cover.
C
C--   Allow sea-ice dynamic code. These options are provided so that,
C     if turned off (#undef), to compile (and process with TAF) only the
C     the thermodynamics component of the code. Note that, if needed,
C     sea-ice dynamics can be turned off at runtime (SEAICEuseDYNAMICS=F).
C
C--   Historically, the seaice model was discretized on a B-Grid. This
C     discretization should still work but it is not longer actively
C     tested and supported. Define this flag to compile it. It cannot be
C     defined together with SEAICE_CGRID
C
C--   The following flag should always be set in order to use C the
C--   operational C-grid discretization.
C
C--   Options for the C-grid version only:
C
C     enable advection of sea ice momentum
C
C     enable JFNK code by defining the following flag
C
C     enable Krylov code by defining the following flag
C
C--   Use a different order when mapping 2D velocity arrays to 1D vector
C     before passing it to FGMRES.
C
C     to reproduce old verification results for JFNK
C
C     enable LSR to use global (multi-tile) tri-diagonal solver
C
C     enable EVP code by defining the following flag
C-    When set use SEAICE_zetaMin and SEAICE_evpDampC to limit viscosities
C     from below and above in seaice_evp: not necessary, and not recommended
C
C     Include code to avoid underflows in EVP-code (copied from CICE).
C     Many compilers can handle this more efficiently with the help of a flag.
C
C     Include code to print residual of EVP iteration for debugging/diagnostics
C
C     smooth regularization (without max-function) of delta for
C     better differentiability
C
C     regularize zeta to zmax with a smooth tanh-function instead
C     of a min(zeta,zmax). This improves convergence of iterative
C     solvers (Lemieux and Tremblay 2009, JGR). No effect on EVP
C
C--   Different yield curves within the VP rheology framework
C     allow the truncated ellipse rheology (runtime flag SEAICEuseTEM)
C
C     allow the use of the Mohr Coulomb rheology (runtime flag SEAICEuseMCS)
C     as defined in (Ip 1991) /!\ This is known to give unstable results,
C     use with caution
C
C     allow the use of Mohr Coulomb with elliptical plastic potential
C     (runtime flag SEAICEuseMCE)
C
C     allow the teardrop and parabolic lens  rheology
C     (runtime flag SEAICEuseTD and SEAICEusePL)
C
C--   LSR solver settings
C     Use LSR vector code; not useful on non-vector machines, because it
C     slows down convergence considerably, but the extra iterations are
C     more than made up by the much faster code on vector machines. For
C     the only regularly test vector machine these flags a specified
C     in the build options file SUPER-UX_SX-8_sxf90_awi, so that we comment
C     them out here.
C
C     Use zebra-method (alternate lines) for line-successive-relaxation
C     This modification improves the convergence of the vector code
C     dramatically, so that is may actually be useful in general, but
C     that needs to be tested. Can be used without vectorization options.
C
C     Include code to print residual of nonlinear outer loop of LSR
C
C     This flag is also required for an actual adjoint of seaice_lsr;
C     increases memory requirements a lot.
C
C     Use parameterisation of grounding ice for a better representation
C     of fastice in shallow seas
C
C     Allow using the flexible LSR solver, where the number of non-linear
C     iteration depends on the residual. Good for when a non-linear
C     convergence criterion must be satified
C
C     Use parameterisation of explicit lateral drag for a better
C     representation of fastice along coast lines and islands
C
C
C
C--   Some regularisations
C-    When set limit the Ice-Loading to mass of 1/5 of Surface ocean grid-box
C
C-    When set use SEAICE_clipVelocties = .true., to clip U/VICE at 40cm/s,
C     not recommended
C
C-    When set cap the sublimation latent heat flux in solve4temp according
C     to the available amount of ice+snow. Otherwise this term is treated
C     like all of the others -- residuals heat and fw stocks are passed to
C     the ocean at the end of seaice_growth in a conservative manner.
C     SEAICE_CAP_SUBLIM is not needed as of now, but kept just in case.
C
C--   AD flags
C-    TAF related flag, currently only used in seaice_ad_check_lev[1-4]_dir.h;
C     it is unclear if this is ever needed.
C
C-    Reset fields to zero to stabilise AD code of dynamics solver
C     (resulting in wrong gradients)
C
C-    Another flag to simplify dependencies for TAF-generated AD-code
C     the thermodynamic part, mostly by resetting variables to zero
C
C-    Special seaice flag for AD testing
C
C--   Use the adjointable sea-ice thermodynamic model
C     in seaice_growth_adx.F instead of seaice_growth.F
C     This options excludes more complex physics such
C     as sublimation, ITD, and frazil.
C
C--   These flags are not strictly AD-related but may help obtaining
C     simpler AD-code:
C-    Do not compile code that resets AREA (or AREAITD) to a mininum value
C     of SEAICE_area_floor (=SIeps with default of 1e-5) if there is
C     some finite sea ice thickness
C
C-    Do not compile growth/thermodynamics code (avoiding this code can
C     also be done by setting runtime parameter usePWthermodynamics=F)
C
C-    Do not compile/use seaice-related obcs code when using obcs.
C
C--   Enable free drift code
C
C--   pkg/seaice cost functions compile flags
C-    Sea-ice volume (requires pkg/cost)
C
C CPP options file for salt_plume package
C Use this file for selecting options within the salt_plume package
C
C
C Place CPP define/undef flag here
C
C SALT_PLUME_IN_LEADS
C   Motivation: As ice concentration AREA -> 1, leads occur -> ice
C     production is no longer uniform in grid box -> assumptions
C     which motivate KPP no longer holds -> treat overturn more
C     realistic with this flag.
C   if defined: Activate pkg/salt_plume only when seaice AREA exceeds
C               a certain value representative of lead opening AND only
C               if seaice growth dh is from atmospheric cooling.
C   if undefined: Activate pkg/salt_plume whenever seaice forms.
C                 This is the default of pkg/salt_plume.
C
C
CBOP
C !ROUTINE: EXF_OPTIONS.h
C !INTERFACE:
C #include "EXF_OPTIONS.h"
C
C !DESCRIPTION:
C *==================================================================*
C | CPP options file for EXternal Forcing (EXF) package:
C | Control which optional features to compile in this package code.
C *==================================================================*
CEOP
C
C
C-- Package-specific Options & Macros go here
C
C   --------------------
C   pkg/exf CPP options:
C   (see also table below on how to combine options)
C
C   > ( EXF_VERBOSE ) < replaced with run-time integer parameter "exf_debugLev"
C
C   >>> ALLOW_ATM_WIND <<<
C       If defined, set default value of run-time param. "useAtmWind" to True.
C       If useAtmWind=True, read-in and use wind vector (uwind/vwind)
C       to compute surface wind stress.
C
C   >>> ALLOW_ATM_TEMP <<<
C       This is the main EXF option controlling air-sea buoyancy fluxes:
C      If undefined, net heat flux (Qnet) and net fresh water flux
C       (EmP or EmPmR) are set according to hfluxfile & sfluxfile setting.
C      If defined, net heat flux and net fresh water flux are computed
C       from sum of various components (radiative SW,LW + turbulent heat
C       fluxes SH,LH ; Evap, Precip and optionally RunOff) thus ignoring
C       hfluxfile & sfluxfile.
C      In addition, it allows to read-in from files atmospheric temperature
C       and specific humidity, net radiative fluxes, and precip.
C       Also enable to read-in Evap (if EXF_READ_EVAP is defined) or
C       turbulent heat fluxes (if ALLOW_READ_TURBFLUXES is defined).
C
C   >>> ALLOW_DOWNWARD_RADIATION <<<
C       If defined, downward long-wave and short-wave radiation
C       can be read-in form files to compute net lwflux and swflux.
C
C   >>> ALLOW_ZENITHANGLE <<<
C       If defined, ocean albedo varies with the zenith angle, and
C       incoming fluxes at the top of the atmosphere are computed
C
C   >>> ALLOW_BULKFORMULAE <<<
C       Allows the use of bulk formulae in order to estimate
C       turbulent fluxes (Sensible,Latent,Evap) at the ocean surface.
C
C   >>> EXF_CALC_ATMRHO
C       Calculate the local air density as function of temp, humidity
C       and pressure
C
C   >>> EXF_READ_EVAP <<<
C       If defined, evaporation field is read-in from file;
C     Note: if ALLOW_BULKFORMULAE is defined, evap that is computed from
C       atmospheric state will be replaced by read-in evap but computed
C       latent heat flux will be kept.
C
C   >>> ALLOW_READ_TURBFLUXES <<<
C       If defined, turbulent heat fluxes (sensible and latent) can be read-in
C       from files (but overwritten if ALLOW_BULKFORMULAE is defined).
C
C   >>> ALLOW_RUNOFF <<<
C       If defined, river and glacier runoff can be read-in from files.
C
C   >>> ALLOW_SALTFLX <<<
C       If defined, upward salt flux can be read-in from files.
C
C   >>> ALLOW_RUNOFTEMP <<<
C       If defined, river and glacier runoff temperature
C       can be read-in from files.
C
C   >>>  <<<
C       If defined, atmospheric pressure can be read-in from files.
C   WARNING: this flag is set (define/undef) in CPP_OPTIONS.h
C            and cannot be changed here (in EXF_OPTIONS.h)
C
C   >>> EXF_ALLOW_TIDES <<<
C       If defined, 2-D tidal geopotential can be read-in from files
C
C   >>> EXF_SEAICE_FRACTION <<<
C       If defined, seaice fraction can be read-in from files (areaMaskFile)
C
C   >>> ALLOW_CLIMSST_RELAXATION <<<
C       Allow the relaxation of surface level temperature to SST (climatology),
C       e.g. the Reynolds climatology.
C
C   >>> ALLOW_CLIMSSS_RELAXATION <<<
C       Allow the relaxation of surface level salinity to SSS (climatology),
C       e.g. the Levitus climatology.
C
C   >>> USE_EXF_INTERPOLATION <<<
C       Allows to provide input field on arbitrary Lat-Lon input grid
C       (as specified in EXF_NML_04) and to interpolate to model grid.
C     Note: default is to interpolate unless {FLD}_interpMethod is set to 0
C
C   ====================================================================
C
C    The following CPP options:
C       ALLOW_ATM_WIND / useAtmWind (useWind)
C       ALLOW_ATM_TEMP               (TEMP)
C       ALLOW_DOWNWARD_RADIATION     (DOWN)
C       ALLOW_BULKFORMULAE           (BULK)
C       EXF_READ_EVAP                (EVAP)
C       ALLOW_READ_TURBFLUXES        (TURB)
C
C    permit all ocean-model forcing configurations listed in the 2 tables below.
C    The first configuration (A1,B1) is the flux-forced, ocean model.
C    Configurations A2,B3 and A2,B4 use pkg/exf open-water bulk formulae
C    to compute, from atmospheric variables, the missing surface fluxes.
C    The forcing fields in the rightmost column are defined in EXF_FIELDS.h
C    (ocean-model surface forcing field are defined in model/inc/FFIELDS.h)
C
C    (A) Surface momentum flux: [model: fu,fv ; exf: ustress,vstress]
C
C    # |useWind|        actions
C   ---|-------|-------------------------------------------------------------
C   (1)| False | Read-in ustress,vstress (if needed in B, compute wind-speed)
C      |       |
C   (2)| True  | Read-in uwind,vwind ; compute wind stress ustress,vstress.
C   ---|-------|-------------------------------------------------------------
C
C    (B) Surface buoyancy flux:
C        [ net heat flux: Qnet (exf: hflux), net short-wave: Qsw (exf: swflux)
C          fresh-water flux: EmPmR (exf: sflux) and saltFlux (exf: saltflx) ]
C
C    # |TEMP |DOWN |BULK |EVAP |TURB |            actions
C   ---|-----|-----|-----|-----|-----|-------------------------------------
C   (1)|  -  |  -  |  -  |  -  |  -  | Read-in hflux, swflux and sflux.
C      |     |     |     |     |     |
C   (2)|  -  | def |  -  |  -  |  -  | Read-in hflux, swdown and sflux.
C      |     |     |     |     |     | Compute swflux.
C      |     |     |     |     |     |
C   (3)| def | def | def |  -  |  -  | Read-in atemp, aqh, swdown, lwdown,
C      |     |     |     |     |     |  precip, and runoff.
C      |     |     |     |     |     | Compute hflux, swflux and sflux.
C      |     |     |     |     |     |
C   (4)| def |  -  | def |  -  |  -  | Read-in atemp, aqh, swflux, lwflux,
C      |     |     |     |     |     |  precip, and runoff.
C      |     |     |     |     |     | Compute hflux and sflux.
C      |     |     |     |     |     |
C   (5)| def | def |  -  | def | def | Read-in hs, hl, swdown, lwdown,
C      |     |     |     |     |     |  evap, precip and runoff.
C      |     |     |     |     |     | Compute hflux, swflux and sflux.
C      |     |     |     |     |     |
C   (6)| def |  -  |  -  | def | def | Read-in hs, hl, swflux, lwflux,
C      |     |     |     |     |     |  evap, precip and runoff.
C      |     |     |     |     |     | Compute  hflux and sflux.
C
C   =======================================================================
C
C-  Bulk formulae related flags.
C Note: To use ALLOW_BULKFORMULAE or EXF_READ_EVAP, needs #define 
C use Large and Yeager (2004) modification to Large and Pond bulk formulae
C use drag formulation of Large and Yeager (2009), Climate Dyn., 33, pp 341-364
C
C-  Other forcing fields
C
C Note: To use EXF_CALC_ATMRHO, both 
C       and  need to be defined
C
C-  Zenith Angle/Albedo related flags.
C
C-  Use ocean_emissivity*lwdown in lwFlux. This flag should be defined
C   unless to reproduce old results (obtained with inconsistent old code)
C
C-  Surface level relaxation to prescribed fields (e.g., climatologies)
C
C-  Allows to read-in (2-d) tidal geopotential forcing
C
C-  Allows to read-in seaice fraction from files (areaMaskFile)
C
C-  Use spatial interpolation to interpolate
C   forcing files from input grid to model grid.
C   for interpolated vector fields, rotate towards model-grid axis
C   using old rotation formulae (instead of grid-angles)
C   for interpolation around N & S pole, use the old formulation
C   (no pole symmetry, single vector-comp interp, reset to 0 zonal-comp @ N.pole)
C
C
C-  Not recommended (not tested nor maintained) and un-documented Options:
C
C
CBOP
C !ROUTINE: COST_OPTIONS.h
C !INTERFACE:
C #include "COST_OPTIONS.h"
C
C !DESCRIPTION:
C *==================================================================*
C | CPP options file for Cost-Function (cost) package:
C | Control which optional features to compile in this package code.
C *==================================================================*
CEOP
C
C   ==================================================================
C-- Package-specific Options & Macros go here
C
C
C       >>> Cost function contributions
C
C
C   List these options here:
C
C   ==================================================================
C
CBOP
C !ROUTINE: CTRL_OPTIONS.h
C !INTERFACE:
C #include "CTRL_OPTIONS.h"
C
C !DESCRIPTION:
C *==================================================================*
C | CPP options file for Control (ctrl) package:
C | Control which optional features to compile in this package code.
C *==================================================================*
CEOP
C
C   ==================================================================
C-- Package-specific Options & Macros go here
C
C o I/O and pack settings
C   This option is only relevant (for pack/unpack) with OBCS_CONTROL:
C
C       >>> Other Control.
C   Allows for GMREDI controls
C   Allows for Vertical Diffusivity controls
C
C   Allows bathymetry as a control vector
C   Note: keep this Option separated from generic control since this control
C     involves many new dependencies that we would like to avoid in general.
C
C       >>> Generic Control.
C
C       >>> Open boundaries
C
C  o Set ALLOW_OBCS_CONTROL (Do not edit/modify):
C
C  o Impose bounds on controls
C
C  o Rotation of wind/stress controls adjustments
C    from Eastward/Northward to model grid directions
C
C  o Originally the first two time-reccords of control
C    variable tau u and tau v were skipped.
C    The CTRL_SKIP_FIRST_TWO_ATM_REC_ALL option extends this
C    to the other the time variable atmospheric controls.
C
C  Note: this flag turns on extra smoothing code in ctrl_get_gen.F which
C  is inconsistent with the Weaver and Courtier, 2001 algorithm, and
C  should probably not be used. The corresponding 3D flag applied only
C  to deprecated code that is now removed. At some point we will remove
C  this flag and associated code as well.
C  o apply pkg/smooth/smooth_diff2d.F to 2D controls (outside of Smooth_Correl2D)
C
C  o Print more debug info to STDOUT
C
C   ==================================================================
C
CBOP
C     !ROUTINE: THE_MAIN_LOOP
C     !INTERFACE:
      SUBROUTINE THE_MAIN_LOOP_B(mytime, myiter, mythid)
      IMPLICIT NONE
C     == Global variables ==
CBOP
C    !ROUTINE: SIZE.h
C    !INTERFACE:
C    include SIZE.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | SIZE.h Declare size of underlying computational grid.
C     *==========================================================*
C     | The design here supports a three-dimensional model grid
C     | with indices I,J and K. The three-dimensional domain
C     | is comprised of nPx*nSx blocks (or tiles) of size sNx
C     | along the first (left-most index) axis, nPy*nSy blocks
C     | of size sNy along the second axis and one block of size
C     | Nr along the vertical (third) axis.
C     | Blocks/tiles have overlap regions of size OLx and OLy
C     | along the dimensions that are subdivided.
C     *==========================================================*
C     \ev
C
C     Voodoo numbers controlling data layout:
C     sNx :: Number of X points in tile.
C     sNy :: Number of Y points in tile.
C     OLx :: Tile overlap extent in X.
C     OLy :: Tile overlap extent in Y.
C     nSx :: Number of tiles per process in X.
C     nSy :: Number of tiles per process in Y.
C     nPx :: Number of processes to use in X.
C     nPy :: Number of processes to use in Y.
C     Nx  :: Number of points in X for the full domain.
C     Ny  :: Number of points in Y for the full domain.
C     Nr  :: Number of points in vertical direction.
CEOP
      INTEGER snx
      INTEGER sny
      INTEGER olx
      INTEGER oly
      INTEGER nsx
      INTEGER nsy
      INTEGER npx
      INTEGER npy
      INTEGER nx
      INTEGER ny
      INTEGER nr
      PARAMETER (snx=62, sny=62, olx=4, oly=4, nsx=1, nsy=1, npx=1, npy=
     +   1, nx=snx*nsx*npx, ny=sny*nsy*npy, nr=31)
C
C     MAX_OLX :: Set to the maximum overlap region size of any array
C     MAX_OLY    that will be exchanged. Controls the sizing of exch
C                routine buffers.
      INTEGER max_olx
      INTEGER max_oly
      PARAMETER (max_olx=olx, max_oly=oly)
C
CBOP
C     !ROUTINE: EEPARAMS.h
C     !INTERFACE:
C     include "EEPARAMS.h"
C
C     !DESCRIPTION:
C     *==========================================================*
C     | EEPARAMS.h                                               |
C     *==========================================================*
C     | Parameters for "execution environemnt". These are used   |
C     | by both the particular numerical model and the execution |
C     | environment support routines.                            |
C     *==========================================================*
CEOP
C
C     ========  EESIZE.h  ========================================
C
C     MAX_LEN_MBUF  :: Default message buffer max. size
C     MAX_LEN_FNAM  :: Default file name max. size
C     MAX_LEN_PREC  :: Default rec len for reading "parameter" files
C
      INTEGER max_len_mbuf
      PARAMETER (max_len_mbuf=512)
      INTEGER max_len_fnam
      PARAMETER (max_len_fnam=512)
      INTEGER max_len_prec
      PARAMETER (max_len_prec=200)
C
C     MAX_NO_THREADS  :: Maximum number of threads allowed.
C     GSVec_size      :: Maximum buffer size for Global Sum Vector array
      INTEGER max_no_threads
      PARAMETER (max_no_threads=4)
      INTEGER gsvec_size
      PARAMETER (gsvec_size=1024)
C
C     Particularly weird and obscure voodoo numbers
C     lShare :: This wants to be the length in
C               [148]-byte words of the size of
C               the address "window" that is snooped
C               on an SMP bus. By separating elements in
C               the global sum buffer we can avoid generating
C               extraneous invalidate traffic between
C               processors. The length of this window is usually
C               a cache line i.e. small O(64 bytes).
C               The buffer arrays are usually short arrays
C               and are declared REAL ARRA(lShare[148],LBUFF).
C               Setting lShare[148] to 1 is like making these arrays
C               one dimensional.
      INTEGER cachelinesize
      INTEGER lshare1
      INTEGER lshare4
      INTEGER lshare8
      PARAMETER (cachelinesize=256)
      PARAMETER (lshare1=cachelinesize)
      PARAMETER (lshare4=cachelinesize/4)
      PARAMETER (lshare8=cachelinesize/8)
C
C     ========  EESIZE.h  ========================================
C
C     Symbolic values
C     precXXXX :: precision used for I/O
      INTEGER precfloat32
      PARAMETER (precfloat32=32)
      INTEGER precfloat64
      PARAMETER (precfloat64=64)
C
C     Real-type constant for some frequently used simple number (0,1,2,1/2):
      REAL*8 zerors, oners, twors, halfrs
      PARAMETER (zerors=0.0d0, oners=1.0d0)
      PARAMETER (twors=2.0d0, halfrs=0.5d0)
      REAL*8 zerorl, onerl, tworl, halfrl
      PARAMETER (zerorl=0.0d0, onerl=1.0d0)
      PARAMETER (tworl=2.0d0, halfrl=0.5d0)
C
C     UNSET_xxx :: Used to indicate variables that have not been given a value
      REAL*8 unset_float8
      PARAMETER (unset_float8=1.234567d5)
      REAL*4 unset_float4
      PARAMETER (unset_float4=1.234567e5)
      REAL*8 unset_rl
      PARAMETER (unset_rl=1.234567d5)
      REAL*8 unset_rs
      PARAMETER (unset_rs=1.234567d5)
      INTEGER unset_i
      PARAMETER (unset_i=123456789)
C
C     debLevX  :: used to decide when to print debug messages
      INTEGER deblevzero
      INTEGER debleva, deblevb, deblevc, deblevd, debleve
      PARAMETER (deblevzero=0)
      PARAMETER (debleva=1)
      PARAMETER (deblevb=2)
      PARAMETER (deblevc=3)
      PARAMETER (deblevd=4)
      PARAMETER (debleve=5)
C
C     SQUEEZE_RIGHT      :: Flag indicating right blank space removal
C                           from text field.
C     SQUEEZE_LEFT       :: Flag indicating left blank space removal
C                           from text field.
C     SQUEEZE_BOTH       :: Flag indicating left and right blank
C                           space removal from text field.
C     PRINT_MAP_XY       :: Flag indicating to plot map as XY slices
C     PRINT_MAP_XZ       :: Flag indicating to plot map as XZ slices
C     PRINT_MAP_YZ       :: Flag indicating to plot map as YZ slices
C     commentCharacter   :: Variable used in column 1 of parameter
C                           files to indicate comments.
C     INDEX_I            :: Variable used to select an index label
C     INDEX_J               for formatted input parameters.
C     INDEX_K
C     INDEX_NONE
      CHARACTER*(*) squeeze_right
      PARAMETER (squeeze_right='R')
      CHARACTER*(*) squeeze_left
      PARAMETER (squeeze_left='L')
      CHARACTER*(*) squeeze_both
      PARAMETER (squeeze_both='B')
      CHARACTER*(*) print_map_xy
      PARAMETER (print_map_xy='XY')
      CHARACTER*(*) print_map_xz
      PARAMETER (print_map_xz='XZ')
      CHARACTER*(*) print_map_yz
      PARAMETER (print_map_yz='YZ')
      CHARACTER*(*) commentcharacter
      PARAMETER (commentcharacter='#')
      INTEGER index_i
      INTEGER index_j
      INTEGER index_k
      INTEGER index_none
      PARAMETER (index_i=1, index_j=2, index_k=3, index_none=4)
C
C     EXCH_IGNORE_CORNERS :: Flag to select ignoring or
C     EXCH_UPDATE_CORNERS    updating of corners during an edge exchange.
      INTEGER exch_ignore_corners
      INTEGER exch_update_corners
      PARAMETER (exch_ignore_corners=0, exch_update_corners=1)
C
C     FORWARD_SIMULATION
C     REVERSE_SIMULATION
C     TANGENT_SIMULATION
      INTEGER forward_simulation
      INTEGER reverse_simulation
      INTEGER tangent_simulation
      PARAMETER (forward_simulation=0, reverse_simulation=1, 
     +   tangent_simulation=2)
C
C--   COMMON /EEPARAMS_L/ Execution environment public logical variables.
C     eeBootError    :: Flags indicating error during multi-processing
C     eeEndError     :: initialisation and termination.
C     fatalError     :: Flag used to indicate that the model is ended with an error
C     debugMode      :: controls printing of debug msg (sequence of S/R calls).
C     useSingleCpuIO :: When useSingleCpuIO is set, MDS_WRITE_FIELD outputs from
C                       master MPI process only. -- NOTE: read from main parameter
C                       file "data" and not set until call to INI_PARMS.
C     useSingleCpuInput :: When useSingleCpuInput is set, EXF_INTERP_READ
C                       reads forcing files from master MPI process only.
C                       -- NOTE: read from main parameter file "data"
C                          and defaults to useSingleCpuInput = useSingleCpuIO
C     printMapIncludesZeros  :: Flag that controls whether character constant
C                               map code ignores exact zero values.
C     useCubedSphereExchange :: use Cubed-Sphere topology domain.
C     useCoupler     :: use Coupler for a multi-components set-up.
C     useNEST_PARENT :: use Parent Nesting interface (pkg/nest_parent)
C     useNEST_CHILD  :: use Child  Nesting interface (pkg/nest_child)
C     useNest2W_parent :: use Parent 2-W Nesting interface (pkg/nest2w_parent)
C     useNest2W_child  :: use Child  2-W Nesting interface (pkg/nest2w_child)
C     useOASIS       :: use OASIS-coupler for a multi-components set-up.
      COMMON /eeparams_l/ eebooterror, eeenderror, fatalerror, debugmode
     +, usesinglecpuio, usesinglecpuinput, printmapincludeszeros, 
     +usecubedsphereexchange, usecoupler, usenest_parent, usenest_child
     +, usenest2w_parent, usenest2w_child, useoasis, usesetrlstk, 
     +usesigreg
C    &  eeBootError, fatalError, eeEndError,
      LOGICAL eebooterror
      LOGICAL eeenderror
      LOGICAL fatalerror
      LOGICAL debugmode
      LOGICAL usesinglecpuio
      LOGICAL usesinglecpuinput
      LOGICAL printmapincludeszeros
      LOGICAL usecubedsphereexchange
      LOGICAL usecoupler
      LOGICAL usenest_parent
      LOGICAL usenest_child
      LOGICAL usenest2w_parent
      LOGICAL usenest2w_child
      LOGICAL useoasis
      LOGICAL usesetrlstk
      LOGICAL usesigreg
C
C--   COMMON /EPARAMS_I/ Execution environment public integer variables.
C     errorMessageUnit    :: Fortran IO unit for error messages
C     standardMessageUnit :: Fortran IO unit for informational messages
C     maxLengthPrt1D :: maximum length for printing (to Std-Msg-Unit) 1-D array
C     scrUnit1      :: Scratch file 1 unit number
C     scrUnit2      :: Scratch file 2 unit number
C     eeDataUnit    :: Unit # for reading "execution environment" parameter file
C     modelDataUnit :: Unit number for reading "model" parameter file.
C     numberOfProcs :: Number of processes computing in parallel
C     pidIO         :: Id of process to use for I/O.
C     myBxLo, myBxHi :: Extents of domain in blocks in X and Y
C     myByLo, myByHi :: that each threads is responsble for.
C     myProcId      :: My own "process" id.
C     myPx          :: My X coord on the proc. grid.
C     myPy          :: My Y coord on the proc. grid.
C     myXGlobalLo   :: My bottom-left (south-west) x-index global domain.
C                      The x-coordinate of this point in for example m or
C                      degrees is *not* specified here. A model needs to
C                      provide a mechanism for deducing that information
C                      if it is needed.
C     myYGlobalLo   :: My bottom-left (south-west) y-index in global domain.
C                      The y-coordinate of this point in for example m or
C                      degrees is *not* specified here. A model needs to
C                      provide a mechanism for deducing that information
C                      if it is needed.
C     nThreads      :: No. of threads
C     nTx, nTy      :: No. of threads in X and in Y
C                      This assumes a simple cartesian gridding of the threads
C                      which is not required elsewhere but that makes it easier
C     ioErrorCount  :: IO Error Counter. Set to zero initially and increased
C                      by one every time an IO error occurs.
      COMMON /eeparams_i/ errormessageunit, standardmessageunit, 
     +maxlengthprt1d, scrunit1, scrunit2, eedataunit, modeldataunit, 
     +numberofprocs, pidio, myprocid, mypx, mypy, myxgloballo, 
     +myygloballo, nthreads, mybxlo, mybxhi, mybylo, mybyhi, ntx, nty, 
     +ioerrorcount
      INTEGER errormessageunit
      INTEGER standardmessageunit
      INTEGER maxlengthprt1d
      INTEGER scrunit1
      INTEGER scrunit2
      INTEGER eedataunit
      INTEGER modeldataunit
      INTEGER ioerrorcount(max_no_threads)
      INTEGER mybxlo(max_no_threads)
      INTEGER mybxhi(max_no_threads)
      INTEGER mybylo(max_no_threads)
      INTEGER mybyhi(max_no_threads)
      INTEGER myprocid
      INTEGER mypx
      INTEGER mypy
      INTEGER myxgloballo
      INTEGER myygloballo
      INTEGER nthreads
      INTEGER ntx
      INTEGER nty
      INTEGER numberofprocs
      INTEGER pidio
C
C---+----1----+----2----+----3----+----4----+----5----+----6----+----7-|--+----|
CBOP
C     !ROUTINE: PARAMS.h
C     !INTERFACE:
C     #include PARAMS.h
C
C     !DESCRIPTION:
C     Header file defining model "parameters".  The values from the
C     model standard input file are stored into the variables held
C     here. Notes describing the parameters can also be found here.
C
CEOP
C
C--   Contants
C     Useful physical values
      REAL*8 pi
      PARAMETER (pi=3.14159265358979323844d0)
      REAL*8 deg2rad
      PARAMETER (deg2rad=2.d0*pi/360.d0)
C
C--   COMMON /PARM_C/ Character valued parameters used by the model.
C     buoyancyRelation :: Flag used to indicate which relation to use to
C                         get buoyancy.
C     eosType         :: choose the equation of state:
C                        LINEAR, POLY3, UNESCO, JMD95Z, JMD95P, MDJWF, IDEALGAS
C     pickupSuff      :: force to start from pickup files (even if nIter0=0)
C                        and read pickup files with this suffix (max 10 Char.)
C     mdsioLocalDir   :: read-write tiled file from/to this directory name
C                        (+ 4 digits Processor-Rank) instead of current dir.
C     adTapeDir       :: read-write checkpointing tape files from/to this
C                        directory name instead of current dir. Conflicts
C                        mdsioLocalDir, so only one of the two can be set.
C     tRefFile      :: File containing reference Potential Temperat.  tRef (1.D)
C     sRefFile      :: File containing reference salinity/spec.humid. sRef (1.D)
C     rhoRefFile    :: File containing reference density profile rhoRef (1.D)
C     gravityFile   :: File containing gravity vertical profile (1.D)
C     delRFile      :: File containing vertical grid spacing delR  (1.D array)
C     delRcFile     :: File containing vertical grid spacing delRc (1.D array)
C     hybSigmFile   :: File containing hybrid-sigma vertical coord. coeff. (2x 1.D)
C     delXFile      :: File containing X-spacing grid definition (1.D array)
C     delYFile      :: File containing Y-spacing grid definition (1.D array)
C     horizGridFile :: File containing horizontal-grid definition
C                        (only when using curvilinear_grid)
C     bathyFile       :: File containing bathymetry. If not defined bathymetry
C                        is taken from inline function.
C     topoFile        :: File containing the topography of the surface (unit=m)
C                        (mainly used for the atmosphere = ground height).
C     addWwallFile    :: File containing 2-D additional Western  cell-edge wall
C     addSwallFile    :: File containing 2-D additional Southern cell-edge wall
C                        (e.g., to add "thin-wall" where it is =1)
C     hydrogThetaFile :: File containing initial hydrographic data (3-D)
C                        for potential temperature.
C     hydrogSaltFile  :: File containing initial hydrographic data (3-D)
C                        for salinity.
C     diffKrFile      :: File containing 3D specification of vertical diffusivity
C     viscAhDfile     :: File containing 3D specification of horizontal viscosity
C     viscAhZfile     :: File containing 3D specification of horizontal viscosity
C     viscA4Dfile     :: File containing 3D specification of horizontal viscosity
C     viscA4Zfile     :: File containing 3D specification of horizontal viscosity
C     zonalWindFile   :: File containing zonal wind data
C     meridWindFile   :: File containing meridional wind data
C     thetaClimFile   :: File containing surface theta climataology used
C                        in relaxation term -lambda(theta-theta*)
C     saltClimFile    :: File containing surface salt climataology used
C                        in relaxation term -lambda(salt-salt*)
C     surfQfile       :: File containing surface heat flux, excluding SW
C                        (old version, kept for backward compatibility)
C     surfQnetFile    :: File containing surface net heat flux
C     surfQswFile     :: File containing surface shortwave radiation
C     EmPmRfile       :: File containing surface fresh water flux
C           NOTE: for backward compatibility EmPmRfile is specified in
C                 m/s when using external_fields_load.F.  It is converted
C                 to kg/m2/s by multiplying by rhoConstFresh.
C     saltFluxFile    :: File containing surface salt flux
C     pLoadFile       :: File containing pressure loading
C     geoPotAnomFile  :: File containing constant geopotential anomaly due to
C                        density structure
C     addMassFile     :: File containing source/sink of fluid in the interior
C     eddyPsiXFile    :: File containing zonal Eddy streamfunction data
C     eddyPsiYFile    :: File containing meridional Eddy streamfunction data
C     geothermalFile  :: File containing geothermal heat flux
C     lambdaThetaFile :: File containing SST relaxation coefficient
C     lambdaSaltFile  :: File containing SSS relaxation coefficient
C     wghtBalanceFile :: File containing weight used in balancing net EmPmR
C     the_run_name    :: string identifying the name of the model "run"
      COMMON /parm_c/ buoyancyrelation, eostype, pickupsuff, 
     +mdsiolocaldir, adtapedir, treffile, sreffile, rhoreffile, 
     +gravityfile, delrfile, delrcfile, hybsigmfile, delxfile, delyfile
     +, horizgridfile, bathyfile, topofile, addwwallfile, addswallfile, 
     +viscahdfile, viscahzfile, visca4dfile, visca4zfile, 
     +hydrogthetafile, hydrogsaltfile, diffkrfile, zonalwindfile, 
     +meridwindfile, thetaclimfile, saltclimfile, empmrfile, 
     +saltfluxfile, surfqfile, surfqnetfile, surfqswfile, uvelinitfile, 
     +vvelinitfile, psurfinitfile, ploadfile, geopotanomfile, 
     +addmassfile, eddypsixfile, eddypsiyfile, geothermalfile, 
     +lambdathetafile, lambdasaltfile, wghtbalancefile, the_run_name
      CHARACTER*(max_len_fnam) buoyancyrelation
      CHARACTER*6 eostype
      CHARACTER*10 pickupsuff
      CHARACTER*(max_len_fnam) mdsiolocaldir
      CHARACTER*(max_len_fnam) adtapedir
      CHARACTER*(max_len_fnam) treffile
      CHARACTER*(max_len_fnam) sreffile
      CHARACTER*(max_len_fnam) rhoreffile
      CHARACTER*(max_len_fnam) gravityfile
      CHARACTER*(max_len_fnam) delrfile
      CHARACTER*(max_len_fnam) delrcfile
      CHARACTER*(max_len_fnam) hybsigmfile
      CHARACTER*(max_len_fnam) delxfile
      CHARACTER*(max_len_fnam) delyfile
      CHARACTER*(max_len_fnam) horizgridfile
      CHARACTER*(max_len_fnam) bathyfile, topofile
      CHARACTER*(max_len_fnam) addwwallfile, addswallfile
      CHARACTER*(max_len_fnam) hydrogthetafile, hydrogsaltfile
      CHARACTER*(max_len_fnam) diffkrfile
      CHARACTER*(max_len_fnam) viscahdfile
      CHARACTER*(max_len_fnam) viscahzfile
      CHARACTER*(max_len_fnam) visca4dfile
      CHARACTER*(max_len_fnam) visca4zfile
      CHARACTER*(max_len_fnam) zonalwindfile
      CHARACTER*(max_len_fnam) meridwindfile
      CHARACTER*(max_len_fnam) thetaclimfile
      CHARACTER*(max_len_fnam) saltclimfile
      CHARACTER*(max_len_fnam) surfqfile
      CHARACTER*(max_len_fnam) surfqnetfile
      CHARACTER*(max_len_fnam) surfqswfile
      CHARACTER*(max_len_fnam) empmrfile
      CHARACTER*(max_len_fnam) saltfluxfile
      CHARACTER*(max_len_fnam) uvelinitfile
      CHARACTER*(max_len_fnam) vvelinitfile
      CHARACTER*(max_len_fnam) psurfinitfile
      CHARACTER*(max_len_fnam) ploadfile
      CHARACTER*(max_len_fnam) geopotanomfile
      CHARACTER*(max_len_fnam) addmassfile
      CHARACTER*(max_len_fnam) eddypsixfile
      CHARACTER*(max_len_fnam) eddypsiyfile
      CHARACTER*(max_len_fnam) geothermalfile
      CHARACTER*(max_len_fnam) lambdathetafile
      CHARACTER*(max_len_fnam) lambdasaltfile
      CHARACTER*(max_len_fnam) wghtbalancefile
      CHARACTER*(max_len_prec/2) the_run_name
C
C--   COMMON /PARM_I/ Integer valued parameters used by the model.
C     cg2dMaxIters        :: Maximum number of iterations in the
C                            two-dimensional con. grad solver.
C     cg2dMinItersNSA     :: Minimum number of iterations in the
C                            not-self-adjoint version (cg2d_nsa.F) of the
C                            two-dimensional con. grad solver (default = 0).
C     cg2dPreCondFreq     :: Frequency for updating cg2d preconditioner
C                            (non-linear free-surf.)
C     cg2dUseMinResSol    :: =0 : use last-iteration/converged solution
C                            =1 : use solver minimum-residual solution
C     cg3dMaxIters        :: Maximum number of iterations in the
C                            three-dimensional con. grad solver.
C     printResidualFreq   :: Frequency for printing residual in CG iterations
C     nIter0              :: Start time-step number of for this run
C     nTimeSteps          :: Number of timesteps to execute
C     nTimeSteps_l2       :: Number of inner timesteps to execute per timestep
C     selectCoriMap       :: select setting of Coriolis parameter map:
C                           =0 f-Plane (Constant Coriolis, = f0)
C                           =1 Beta-Plane Coriolis (= f0 + beta.y)
C                           =2 Spherical Coriolis (= 2.omega.sin(phi))
C                           =3 Read Coriolis 2-d fields from files.
C     selectSigmaCoord    :: option related to sigma vertical coordinate
C     nonlinFreeSurf      :: option related to non-linear free surface
C                           =0 Linear free surface ; >0 Non-linear
C     select_rStar        :: option related to r* vertical coordinate
C                           =0 (default) use r coord. ; > 0 use r*
C     selectNHfreeSurf    :: option for Non-Hydrostatic (free-)Surface formulation:
C                           =0 (default) hydrostatic surf. ; > 0 add NH effects.
C     selectP_inEOS_Zc    :: select which pressure to use in EOS (for z-coords)
C                           =0: simply: -g*rhoConst*z
C                           =1: use pRef = integral{-g*rho(Tref,Sref,pRef)*dz}
C                           =2: use hydrostatic dynamical pressure
C                           =3: use full (Hyd+NH) dynamical pressure
C     selectAddFluid      :: option to add mass source/sink of fluid in the interior
C                            (3-D generalisation of oceanic real-fresh water flux)
C                           =0 off ; =1 add fluid ; =-1 virtual flux (no mass added)
C     selectBalanceEmPmR  :: option to balance net surface fresh-water flux:
C                           =0 off ; =1 uniform correction ; = 2 weighted correction
C     selectImplicitDrag  :: select Implicit treatment of bottom/top drag
C                           = 0: fully explicit
C                           = 1: implicit on provisional velocity
C                                (i.e., before grad.Eta increment)
C                           = 2: fully implicit (combined with Impl Surf.Press)
C     selectPenetratingSW :: select treatment of penetrating shortwave radiation
C                            (requires to define ):
C                           = 0: no shortwave penetration
C                           = 1: constant in time and horizontally uniform
C                                fraction of shortwave penetration (default)
C                           = 2: constant in time, but non-uniform fraction of
C                                shortwave penetration (not yet coded)
C                           > 2: time varying fraction of shortwave penetration
C                                according to external function (e.g. BGC model,
C                                not yet coded)
C     momForcingOutAB     :: =1: take momentum forcing contribution
C                            out of (=0: in) Adams-Bashforth time stepping.
C     tracForcingOutAB    :: =1: take tracer (Temp,Salt,pTracers) forcing contribution
C                            out of (=0: in) Adams-Bashforth time stepping.
C     tempAdvScheme       :: Temp. Horiz.Advection scheme selector
C     tempVertAdvScheme   :: Temp. Vert. Advection scheme selector
C     saltAdvScheme       :: Salt. Horiz.advection scheme selector
C     saltVertAdvScheme   :: Salt. Vert. Advection scheme selector
C     selectKEscheme      :: Kinetic Energy scheme selector (Vector Inv.)
C     selectVortScheme    :: Scheme selector for Vorticity term (Vector Inv.)
C     selectMetricTerms   :: Scheme selector for Metric terms (Flux-Form)
C     selectCoriScheme    :: Scheme selector for Coriolis term
C     select3dCoriScheme  :: Scheme selector for 3-D Coriolis (in Omega.cos Phi)
C     selectBotDragQuadr  :: quadratic bottom drag discretisation option:
C                           =0: average KE from grid center to U & V location
C                           =1: use local velocity norm @ U & V location
C                           =2: same with wet-point averaging of other component
C     pCellMix_select     :: select option to enhance mixing near surface & bottom
C                            unit digit: near bottom ; tens digit: near surface
C                            with digit =0 : disable ;
C                           = 1 : increases mixing linearly with recip_hFac
C                           = 2,3,4 : increases mixing by recip_hFac^(2,3,4)
C     readBinaryPrec      :: Precision used for reading binary files
C     writeBinaryPrec     :: Precision used for writing binary files
C     rwSuffixType        :: controls the format of the mds file suffix.
C                          =0 (default): use iteration number (myIter, I10.10);
C                          =1: 100*myTime (100th sec); =2: myTime (seconds);
C                          =3: myTime/360 (10th of hr); =4: myTime/3600 (hours).
C     monitorSelect       :: select group of variables to monitor
C                            =1 : dynvars ; =2 : + vort ; =3 : + surface
C-    debugLevel          :: controls printing of algorithm intermediate results
C                            and statistics ; higher -> more writing
C-    plotLevel           :: controls printing of field maps ; higher -> more flds
C
      COMMON /parm_i/ cg2dmaxiters, cg2dminitersnsa, cg2dprecondfreq, 
     +cg2duseminressol, cg3dmaxiters, printresidualfreq, niter0, 
     +ntimesteps, ntimesteps_l2, nenditer, selectcorimap, 
     +selectsigmacoord, nonlinfreesurf, select_rstar, selectnhfreesurf, 
     +selectp_ineos_zc, selectaddfluid, selectbalanceempmr, 
     +selectimplicitdrag, momforcingoutab, tracforcingoutab, 
     +tempadvscheme, tempvertadvscheme, saltadvscheme, saltvertadvscheme
     +, selectkescheme, selectvortscheme, selectmetricterms, 
     +selectcorischeme, select3dcorischeme, selectbotdragquadr, 
     +selectpenetratingsw, pcellmix_select, readbinaryprec, 
     +writebinaryprec, rwsuffixtype, monitorselect, debuglevel, 
     +plotlevel
      INTEGER cg2dmaxiters
      INTEGER cg2dminitersnsa
      INTEGER cg2dprecondfreq
      INTEGER cg2duseminressol
      INTEGER cg3dmaxiters
      INTEGER printresidualfreq
      INTEGER niter0
      INTEGER ntimesteps
      INTEGER ntimesteps_l2
      INTEGER nenditer
      INTEGER selectcorimap
      INTEGER selectsigmacoord
      INTEGER nonlinfreesurf
      INTEGER select_rstar
      INTEGER selectnhfreesurf
      INTEGER selectp_ineos_zc
      INTEGER selectaddfluid
      INTEGER selectbalanceempmr
      INTEGER selectimplicitdrag
      INTEGER momforcingoutab, tracforcingoutab
      INTEGER tempadvscheme, tempvertadvscheme
      INTEGER saltadvscheme, saltvertadvscheme
      INTEGER selectkescheme
      INTEGER selectvortscheme
      INTEGER selectmetricterms
      INTEGER selectcorischeme
      INTEGER select3dcorischeme
      INTEGER selectbotdragquadr
      INTEGER selectpenetratingsw
      INTEGER pcellmix_select
      INTEGER readbinaryprec
      INTEGER writebinaryprec
      INTEGER rwsuffixtype
      INTEGER monitorselect
      INTEGER debuglevel
      INTEGER plotlevel
C
C--   COMMON /PARM_L/ Logical valued parameters used by the model.
C- Coordinate + Grid params:
C     fluidIsAir       :: Set to indicate that the fluid major constituent
C                         is air
C     fluidIsWater     :: Set to indicate that the fluid major constituent
C                         is water
C     usingPCoords     :: Set to indicate that we are working in a pressure
C                         type coordinate (p or p*).
C     usingZCoords     :: Set to indicate that we are working in a height
C                         type coordinate (z or z*)
C     usingCartesianGrid :: If TRUE grid generation will be in a cartesian
C                           coordinate frame.
C     usingSphericalPolarGrid :: If TRUE grid generation will be in a
C                                spherical polar frame.
C     rotateGrid      :: rotate grid coordinates to geographical coordinates
C                        according to Euler angles phiEuler, thetaEuler, psiEuler
C     usingCylindricalGrid :: If TRUE grid generation will be Cylindrical
C     usingCurvilinearGrid :: If TRUE, use a curvilinear grid (to be provided)
C     hasWetCSCorners :: domain contains CS-type corners where dynamics is solved
C     deepAtmosphere :: deep model (drop the shallow-atmosphere approximation)
C     setInterFDr    :: set Interface depth (put cell-Center at the middle)
C     setCenterDr    :: set cell-Center depth (put Interface at the middle)
C     useMin4hFacEdges :: set hFacW,hFacS as minimum of adjacent hFacC factor
C     interViscAr_pCell :: account for partial-cell in interior vert. viscosity
C     interDiffKr_pCell :: account for partial-cell in interior vert. diffusion
C- Momentum params:
C     no_slip_sides  :: Impose "no-slip" at lateral boundaries.
C     no_slip_bottom :: Impose "no-slip" at bottom boundary.
C     bottomVisc_pCell :: account for partial-cell in bottom visc. (no-slip BC)
C     useSmag3D      :: Use isotropic 3-D Smagorinsky
C     useFullLeith   :: Set to true to use full Leith viscosity(may be unstable
C                       on irregular grids)
C     useStrainTensionVisc:: Set to true to use Strain-Tension viscous terms
C     useAreaViscLength :: Set to true to use old scaling for viscous lengths,
C                          e.g., L2=Raz.  May be preferable for cube sphere.
C     momViscosity  :: Flag which turns momentum friction terms on and off.
C     momAdvection  :: Flag which turns advection of momentum on and off.
C     momForcing    :: Flag which turns external forcing of momentum on and off.
C     momTidalForcing    :: Flag which turns tidal forcing on and off.
C     momPressureForcing :: Flag which turns pressure term in momentum equation
C                          on and off.
C     useNHMTerms   :: If TRUE use non-hydrostatic metric terms.
C     useCoriolis   :: Flag which turns the coriolis terms on and off.
C     useCDscheme   :: use CD-scheme to calculate Coriolis terms.
C     vectorInvariantMomentum :: use Vector-Invariant form (mom_vecinv package)
C                                (default = F = use mom_fluxform package)
C     useJamartMomAdv :: Use wet-point method for V.I. non-linear term
C     upwindVorticity :: bias interpolation of vorticity in the Coriolis term
C     highOrderVorticity :: use 3rd/4th order interp. of vorticity (V.I., advection)
C     useAbsVorticity :: work with f+zeta in Coriolis terms
C     upwindShear     :: use 1rst order upwind interp. (V.I., vertical advection)
C     momStepping    :: Turns momentum equation time-stepping off
C     calc_wVelocity :: Turns vertical velocity calculation off
C- Temp. & Salt params:
C     tempStepping   :: Turns temperature equation time-stepping on/off
C     saltStepping   :: Turns salinity equation time-stepping on/off
C     addFrictionHeating :: account for frictional heating
C     temp_stayPositive :: use Smolarkiewicz Hack to ensure Temp stays positive
C     salt_stayPositive :: use Smolarkiewicz Hack to ensure Salt stays positive
C     tempAdvection  :: Flag which turns advection of temperature on and off.
C     tempVertDiff4  :: use vertical bi-harmonic diffusion for temperature
C     tempIsActiveTr :: Pot.Temp. is a dynamically active tracer
C     tempForcing    :: Flag which turns external forcing of temperature on/off
C     saltAdvection  :: Flag which turns advection of salinity on and off.
C     saltVertDiff4  :: use vertical bi-harmonic diffusion for salinity
C     saltIsActiveTr :: Salinity  is a dynamically active tracer
C     saltForcing    :: Flag which turns external forcing of salinity on/off
C     maskIniTemp    :: apply mask to initial Pot.Temp.
C     maskIniSalt    :: apply mask to initial salinity
C     checkIniTemp   :: check for points with identically zero initial Pot.Temp.
C     checkIniSalt   :: check for points with identically zero initial salinity
C- Pressure solver related parameters (PARM02)
C     useNSACGSolver :: Set to true to use "not self-adjoint" conjugate
C                       gradient solver that stores the iteration history
C                       for an iterative adjoint as accuate as possible
C     useSRCGSolver  :: Set to true to use conjugate gradient
C                       solver with single reduction (only one call of
C                       s/r mpi_allreduce), default is false
C- Time-stepping & free-surface params:
C     rigidLid            :: Set to true to use rigid lid
C     implicitFreeSurface :: Set to true to use implicit free surface
C     uniformLin_PhiSurf  :: Set to true to use a uniform Bo_surf in the
C                            linear relation Phi_surf = Bo_surf*eta
C     uniformFreeSurfLev  :: TRUE if free-surface level-index is uniform (=1)
C     exactConserv        :: Set to true to conserve exactly the total Volume
C     linFSConserveTr     :: Set to true to correct source/sink of tracer
C                            at the surface due to Linear Free Surface
C     useRealFreshWaterFlux :: if True (=Natural BCS), treats P+R-E flux
C                         as a real Fresh Water (=> changes the Sea Level)
C                         if F, converts P+R-E to salt flux (no SL effect)
C     storePhiHyd4Phys :: store hydrostatic potential for use in Physics/EOS
C                         this requires specific code for restart & exchange
C     quasiHydrostatic :: Using non-hydrostatic terms in hydrostatic algorithm
C     nonHydrostatic   :: Using non-hydrostatic algorithm
C     use3Dsolver      :: set to true to use 3-D pressure solver
C     implicitIntGravWave :: treat Internal Gravity Wave implicitly
C     staggerTimeStep   :: enable a Stagger time stepping U,V (& W) then T,S
C     applyExchUV_early :: Apply EXCH to U,V earlier, just before integr_continuity
C     doResetHFactors   :: Do reset thickness factors @ beginning of each time-step
C     implicitDiffusion :: Turns implicit vertical diffusion on
C     implicitViscosity :: Turns implicit vertical viscosity on
C     tempImplVertAdv   :: Turns on implicit vertical advection for Temperature
C     saltImplVertAdv   :: Turns on implicit vertical advection for Salinity
C     momImplVertAdv    :: Turns on implicit vertical advection for Momentum
C     multiDimAdvection :: Flag that enable multi-dimension advection
C     useMultiDimAdvec  :: True if multi-dim advection is used at least once
C     momDissip_In_AB   :: if False, put Dissipation tendency contribution
C                          out off Adams-Bashforth time stepping.
C     doAB_onGtGs       :: if the Adams-Bashforth time stepping is used, always
C                          apply AB on tracer tendencies (rather than on Tracer)
C- Other forcing params -
C     balanceQnet     :: substract global mean of Qnet at every time step
C     balancePrintMean:: print substracted global means to STDOUT
C     doThetaClimRelax :: Set true if relaxation to temperature
C                        climatology is required.
C     doSaltClimRelax  :: Set true if relaxation to salinity
C                        climatology is required.
C     balanceThetaClimRelax :: substract global mean effect at every time step
C     balanceSaltClimRelax :: substract global mean effect at every time step
C     allowFreezing  :: Allows surface water to freeze and form ice
C     periodicExternalForcing :: Set true if forcing is time-dependant
C- I/O parameters -
C     globalFiles    :: Selects between "global" and "tiled" files.
C                       On some platforms with MPI, option globalFiles is either
C                       slow or does not work. Use useSingleCpuIO instead.
C     useSingleCpuIO :: moved to EEPARAMS.h
C     pickupStrictlyMatch :: check and stop if pickup-file do not stricly match
C     startFromPickupAB2 :: with AB-3 code, start from an AB-2 pickup
C     usePickupBeforeC54 :: start from old-pickup files, generated with code from
C                           before checkpoint-54a, Jul 06, 2004.
C     pickup_write_mdsio :: use mdsio to write pickups
C     pickup_read_mdsio  :: use mdsio to read  pickups
C     pickup_write_immed :: echo the pickup immediately (for conversion)
C     writePickupAtEnd   :: write pickup at the last timestep
C     timeave_mdsio      :: use mdsio for timeave output
C     snapshot_mdsio     :: use mdsio for "snapshot" (dumpfreq/diagfreq) output
C     monitor_stdio      :: use stdio for monitor output
C     dumpInitAndLast :: dumps model state to files at Initial (nIter0)
C                        & Last iteration, in addition multiple of dumpFreq iter.
C
      COMMON /parm_l/ fluidisair, fluidiswater, usingpcoords, 
     +usingzcoords, usingcartesiangrid, usingsphericalpolargrid, 
     +rotategrid, usingcylindricalgrid, usingcurvilineargrid, 
     +haswetcscorners, deepatmosphere, setinterfdr, setcenterdr, 
     +usemin4hfacedges, interviscar_pcell, interdiffkr_pcell, 
     +no_slip_sides, no_slip_bottom, bottomvisc_pcell, usesmag3d, 
     +usefullleith, usestraintensionvisc, useareavisclength, 
     +momviscosity, momadvection, momforcing, momtidalforcing, 
     +mompressureforcing, usenhmterms, usecoriolis, usecdscheme, 
     +vectorinvariantmomentum, usejamartmomadv, upwindvorticity, 
     +highordervorticity, useabsvorticity, upwindshear, momstepping, 
     +calc_wvelocity, tempstepping, saltstepping, addfrictionheating, 
     +temp_staypositive, salt_staypositive, tempadvection, tempvertdiff4
     +, tempisactivetr, tempforcing, saltadvection, saltvertdiff4, 
     +saltisactivetr, saltforcing, maskinitemp, maskinisalt, 
     +checkinitemp, checkinisalt, usensacgsolver, usesrcgsolver, 
     +rigidlid, implicitfreesurface, uniformlin_phisurf, 
     +uniformfreesurflev, exactconserv, linfsconservetr, 
     +userealfreshwaterflux, storephihyd4phys, quasihydrostatic, 
     +nonhydrostatic, use3dsolver, implicitintgravwave, staggertimestep
     +, applyexchuv_early, doresethfactors, implicitdiffusion, 
     +implicitviscosity, tempimplvertadv, saltimplvertadv, 
     +momimplvertadv, multidimadvection, usemultidimadvec, 
     +momdissip_in_ab, doab_ongtgs, balanceqnet, balanceprintmean, 
     +balancethetaclimrelax, balancesaltclimrelax, dothetaclimrelax, 
     +dosaltclimrelax, allowfreezing, periodicexternalforcing, 
     +globalfiles, pickupstrictlymatch, usepickupbeforec54, 
     +startfrompickupab2, pickup_read_mdsio, pickup_write_mdsio, 
     +pickup_write_immed, writepickupatend, timeave_mdsio, 
     +snapshot_mdsio, monitor_stdio, outputtypesinclusive, 
     +dumpinitandlast
C
      LOGICAL fluidisair
      LOGICAL fluidiswater
      LOGICAL usingpcoords
      LOGICAL usingzcoords
      LOGICAL usingcartesiangrid
      LOGICAL usingsphericalpolargrid, rotategrid
      LOGICAL usingcylindricalgrid
      LOGICAL usingcurvilineargrid, haswetcscorners
      LOGICAL deepatmosphere
      LOGICAL setinterfdr
      LOGICAL setcenterdr
      LOGICAL usemin4hfacedges
      LOGICAL interviscar_pcell
      LOGICAL interdiffkr_pcell
C
      LOGICAL no_slip_sides
      LOGICAL no_slip_bottom
      LOGICAL bottomvisc_pcell
      LOGICAL usesmag3d
      LOGICAL usefullleith
      LOGICAL usestraintensionvisc
      LOGICAL useareavisclength
      LOGICAL momviscosity
      LOGICAL momadvection
      LOGICAL momforcing
      LOGICAL momtidalforcing
      LOGICAL mompressureforcing
      LOGICAL usenhmterms
C
      LOGICAL usecoriolis
      LOGICAL usecdscheme
      LOGICAL vectorinvariantmomentum
      LOGICAL usejamartmomadv
      LOGICAL upwindvorticity
      LOGICAL highordervorticity
      LOGICAL useabsvorticity
      LOGICAL upwindshear
      LOGICAL momstepping
      LOGICAL calc_wvelocity
      LOGICAL tempstepping
      LOGICAL saltstepping
      LOGICAL addfrictionheating
      LOGICAL temp_staypositive
      LOGICAL salt_staypositive
      LOGICAL tempadvection
      LOGICAL tempvertdiff4
      LOGICAL tempisactivetr
      LOGICAL tempforcing
      LOGICAL saltadvection
      LOGICAL saltvertdiff4
      LOGICAL saltisactivetr
      LOGICAL saltforcing
      LOGICAL maskinitemp
      LOGICAL maskinisalt
      LOGICAL checkinitemp
      LOGICAL checkinisalt
      LOGICAL usensacgsolver
      LOGICAL usesrcgsolver
      LOGICAL rigidlid
      LOGICAL implicitfreesurface
      LOGICAL uniformlin_phisurf
      LOGICAL uniformfreesurflev
      LOGICAL exactconserv
      LOGICAL linfsconservetr
      LOGICAL userealfreshwaterflux
      LOGICAL storephihyd4phys
      LOGICAL quasihydrostatic
      LOGICAL nonhydrostatic
      LOGICAL use3dsolver
      LOGICAL implicitintgravwave
      LOGICAL staggertimestep
      LOGICAL applyexchuv_early
      LOGICAL doresethfactors
      LOGICAL implicitdiffusion
      LOGICAL implicitviscosity
      LOGICAL tempimplvertadv
      LOGICAL saltimplvertadv
      LOGICAL momimplvertadv
      LOGICAL multidimadvection
      LOGICAL usemultidimadvec
      LOGICAL momdissip_in_ab
      LOGICAL doab_ongtgs
      LOGICAL balanceqnet
      LOGICAL balanceprintmean
      LOGICAL dothetaclimrelax
      LOGICAL dosaltclimrelax
      LOGICAL balancethetaclimrelax
      LOGICAL balancesaltclimrelax
      LOGICAL allowfreezing
      LOGICAL periodicexternalforcing
      LOGICAL globalfiles
      LOGICAL pickupstrictlymatch
      LOGICAL usepickupbeforec54
      LOGICAL startfrompickupab2
      LOGICAL pickup_read_mdsio, pickup_write_mdsio
      LOGICAL pickup_write_immed, writepickupatend
      LOGICAL timeave_mdsio, snapshot_mdsio, monitor_stdio
      LOGICAL outputtypesinclusive
      LOGICAL dumpinitandlast
C
C--   COMMON /PARM_R/ "Real" valued parameters used by the model.
C     cg2dTargetResidual
C          :: Target residual for cg2d solver ; no unit (RHS normalisation)
C     cg2dTargetResWunit
C          :: Target residual for cg2d solver ; W unit (No RHS normalisation)
C     cg3dTargetResidual
C          :: Target residual for cg3d solver ; no unit (RHS normalisation)
C     cg3dTargetResWunit
C          :: Target residual for cg3d solver ; W unit (No RHS normalisation)
C     cg2dpcOffDFac :: Averaging weight for preconditioner off-diagonal.
C     Note. 20th May 1998
C           I made a weird discovery! In the model paper we argue
C           for the form of the preconditioner used here ( see
C           A Finite-volume, Incompressible Navier-Stokes Model
C           ...., Marshall et. al ). The algebra gives a simple
C           0.5 factor for the averaging of ac and aCw to get a
C           symmettric pre-conditioner. By using a factor of 0.51
C           i.e. scaling the off-diagonal terms in the
C           preconditioner down slightly I managed to get the
C           number of iterations for convergence in a test case to
C           drop form 192 -> 134! Need to investigate this further!
C           For now I have introduced a parameter cg2dpcOffDFac which
C           defaults to 0.51 but can be set at runtime.
C     delR      :: Vertical grid spacing ( units of r ).
C     delRc     :: Vertical grid spacing between cell centers (r unit).
C     delX      :: Separation between cell faces (m) or (deg), depending
C     delY         on input flags. Note: moved to header file SET_GRID.h
C     xgOrigin   :: Origin of the X-axis (Cartesian Grid) / Longitude of Western
C                :: most cell face (Lat-Lon grid) (Note: this is an "inert"
C                :: parameter but it makes geographical references simple.)
C     ygOrigin   :: Origin of the Y-axis (Cartesian Grid) / Latitude of Southern
C                :: most face (Lat-Lon grid).
C     rSphere    :: Radius of sphere for a spherical polar grid ( m ).
C     recip_rSphere :: Reciprocal radius of sphere ( m^-1 ).
C     radius_fromHorizGrid :: sphere Radius of input horiz. grid (Curvilinear Grid)
C     seaLev_Z   :: the reference height of sea-level (usually zero)
C     top_Pres   :: pressure (P-Coords) or reference pressure (Z-Coords) at the top
C     rSigmaBnd  :: vertical position (in r-unit) of r/sigma transition (Hybrid-Sigma)
C     gravity    :: Acceleration due to constant gravity ( m/s^2 )
C     recip_gravity :: Reciprocal gravity acceleration ( s^2/m )
C     gBaro      :: Accel. due to gravity used in barotropic equation ( m/s^2 )
C     gravFacC   :: gravity factor (vs surf. gravity) vert. profile at cell-Center
C     gravFacF   :: gravity factor (vs surf. gravity) vert. profile at cell-interF
C     rhoNil     :: Reference density for the linear equation of state
C     rhoConst   :: Vertically constant reference density (Boussinesq)
C     rho1Ref    :: reference vertical profile for density (anelastic)
C     rhoFacC    :: normalized (by rhoConst) reference density at cell-Center
C     rhoFacF    :: normalized (by rhoConst) reference density at cell-interFace
C     rhoConstFresh :: Constant reference density for fresh water (rain)
C     thetaConst :: Constant reference for potential temperature
C     tRef       :: reference vertical profile for potential temperature
C     sRef       :: reference vertical profile for salinity/specific humidity
C     rhoRef     :: density vertical profile from (tRef,sRef) [kg/m^3]
C     dBdrRef    :: vertical gradient of reference buoyancy  [(m/s/r)^2]:
C                :: z-coord: = N^2_ref = Brunt-Vaissala frequency [s^-2]
C                :: p-coord: = -(d.alpha/dp)_ref          [(m^2.s/kg)^2]
C     surf_pRef  :: surface reference pressure ( Pa )
C     pRef4EOS   :: reference pressure used in EOS (case selectP_inEOS_Zc=1)
C     phiRef     :: reference potential (press/rho, geopot) profile (m^2/s^2)
C     rVel2wUnit :: units conversion factor (Non-Hydrostatic code),
C                :: from r-coordinate vertical velocity to vertical velocity [m/s].
C                :: z-coord: = 1 ; p-coord: wSpeed [m/s] = rVel [Pa/s] * rVel2wUnit
C     wUnit2rVel :: units conversion factor (Non-Hydrostatic code),
C                :: from vertical velocity [m/s] to r-coordinate vertical velocity.
C                :: z-coord: = 1 ; p-coord: rVel [Pa/s] = wSpeed [m/s] * wUnit2rVel
C     rUnit2z    :: units conversion factor (for ocean in P-coord, only fct of k),
C                :: from r-coordinate to z [m] (at level center):
C                :: z-coord: = 1 ; p-coord: dz [m] = dr [Pa] * rUnit2z
C     z2rUnit    :: units conversion factor (for ocean in P-coord, only fct of k),
C                :: from z [m] to r-coordinate (at level center):
C                :: z-coord: = 1 ; p-coord: dr [Pa] = dz [m] * z2rUnit
C     mass2rUnit :: units conversion factor (surface forcing),
C                :: from mass per unit area [kg/m2] to vertical r-coordinate unit.
C                :: z-coord: = 1/rhoConst ( [kg/m2] / rho = [m] ) ;
C                :: p-coord: = gravity    ( [kg/m2] *  g = [Pa] ) ;
C     rUnit2mass :: units conversion factor (surface forcing),
C                :: from vertical r-coordinate unit to mass per unit area [kg/m2].
C                :: z-coord: = rhoConst  ( [m] * rho = [kg/m2] ) ;
C                :: p-coord: = 1/gravity ( [Pa] /  g = [kg/m2] ) ;
C     sIceLoadFac:: factor to scale (and turn off) sIceLoad (sea-ice loading)
C                   default = 1
C     f0         :: Reference coriolis parameter ( 1/s )
C                   ( Southern edge f for beta plane )
C     beta       :: df/dy ( s^-1.m^-1 )
C     fPrime     :: Second Coriolis parameter ( 1/s ), related to Y-component
C                   of rotation (reference value = 2.Omega.Cos(Phi))
C     omega      :: Angular velocity ( rad/s )
C     rotationPeriod :: Rotation period (s) (= 2.pi/omega)
C     viscArNr   :: vertical profile of Eddy viscosity coeff.
C                   for vertical mixing of momentum ( units of r^2/s )
C     viscAh     :: Eddy viscosity coeff. for mixing of
C                   momentum laterally ( m^2/s )
C     viscAhW    :: Eddy viscosity coeff. for mixing of vertical
C                   momentum laterally, no effect for hydrostatic
C                   model, defaults to viscAhD if unset ( m^2/s )
C                   Not used if variable horiz. viscosity is used.
C     viscA4     :: Biharmonic viscosity coeff. for mixing of
C                   momentum laterally ( m^4/s )
C     viscA4W    :: Biharmonic viscosity coeff. for mixing of vertical
C                   momentum laterally, no effect for hydrostatic
C                   model, defaults to viscA4D if unset ( m^2/s )
C                   Not used if variable horiz. viscosity is used.
C     viscAhD    :: Eddy viscosity coeff. for mixing of momentum laterally
C                   (act on Divergence part) ( m^2/s )
C     viscAhZ    :: Eddy viscosity coeff. for mixing of momentum laterally
C                   (act on Vorticity  part) ( m^2/s )
C     viscA4D    :: Biharmonic viscosity coeff. for mixing of momentum laterally
C                   (act on Divergence part) ( m^4/s )
C     viscA4Z    :: Biharmonic viscosity coeff. for mixing of momentum laterally
C                   (act on Vorticity  part) ( m^4/s )
C     smag3D_coeff     :: Isotropic 3-D Smagorinsky viscosity coefficient (-)
C     smag3D_diffCoeff :: Isotropic 3-D Smagorinsky diffusivity coefficient (-)
C     viscC2leith  :: Leith non-dimensional viscosity factor (grad(vort))
C     viscC2leithD :: Modified Leith non-dimensional visc. factor (grad(div))
C     viscC2LeithQG:: QG Leith non-dimensional viscosity factor
C     viscC4leith  :: Leith non-dimensional viscosity factor (grad(vort))
C     viscC4leithD :: Modified Leith non-dimensional viscosity factor (grad(div))
C     viscC2smag   :: Smagorinsky non-dimensional viscosity factor (harmonic)
C     viscC4smag   :: Smagorinsky non-dimensional viscosity factor (biharmonic)
C     viscAhMax    :: Maximum eddy viscosity coeff. for mixing of
C                    momentum laterally ( m^2/s )
C     viscAhReMax  :: Maximum gridscale Reynolds number for eddy viscosity
C                     coeff. for mixing of momentum laterally (non-dim)
C     viscAhGrid   :: non-dimensional grid-size dependent viscosity
C     viscAhGridMax:: maximum and minimum harmonic viscosity coefficients ...
C     viscAhGridMin::  in terms of non-dimensional grid-size dependent visc.
C     viscA4Max    :: Maximum biharmonic viscosity coeff. for mixing of
C                     momentum laterally ( m^4/s )
C     viscA4ReMax  :: Maximum Gridscale Reynolds number for
C                     biharmonic viscosity coeff. momentum laterally (non-dim)
C     viscA4Grid   :: non-dimensional grid-size dependent bi-harmonic viscosity
C     viscA4GridMax:: maximum and minimum biharmonic viscosity coefficients ...
C     viscA4GridMin::  in terms of non-dimensional grid-size dependent viscosity
C     diffKhT   :: Laplacian diffusion coeff. for mixing of
C                 heat laterally ( m^2/s )
C     diffK4T   :: Biharmonic diffusion coeff. for mixing of
C                 heat laterally ( m^4/s )
C     diffKrNrT :: vertical profile of Laplacian diffusion coeff.
C                 for mixing of heat vertically ( units of r^2/s )
C     diffKr4T  :: vertical profile of Biharmonic diffusion coeff.
C                 for mixing of heat vertically ( units of r^4/s )
C     diffKhS  ::  Laplacian diffusion coeff. for mixing of
C                 salt laterally ( m^2/s )
C     diffK4S   :: Biharmonic diffusion coeff. for mixing of
C                 salt laterally ( m^4/s )
C     diffKrNrS :: vertical profile of Laplacian diffusion coeff.
C                 for mixing of salt vertically ( units of r^2/s ),
C     diffKr4S  :: vertical profile of Biharmonic diffusion coeff.
C                 for mixing of salt vertically ( units of r^4/s )
C     diffKrBL79surf :: T/S surface diffusivity (m^2/s) Bryan and Lewis, 1979
C     diffKrBL79deep :: T/S deep diffusivity (m^2/s) Bryan and Lewis, 1979
C     diffKrBL79scl  :: depth scale for arctan fn (m) Bryan and Lewis, 1979
C     diffKrBL79Ho   :: depth offset for arctan fn (m) Bryan and Lewis, 1979
C     BL79LatVary    :: polarwise of this latitude diffKrBL79 is applied with
C                       gradual transition to diffKrBLEQ towards Equator
C     diffKrBLEQsurf :: same as diffKrBL79surf but at Equator
C     diffKrBLEQdeep :: same as diffKrBL79deep but at Equator
C     diffKrBLEQscl  :: same as diffKrBL79scl but at Equator
C     diffKrBLEQHo   :: same as diffKrBL79Ho but at Equator
C     pCellMix_maxFac :: maximum enhanced mixing factor for thin partial-cell
C     pCellMix_delR   :: thickness criteria   for too thin partial-cell
C     pCellMix_viscAr :: vertical viscosity   for too thin partial-cell
C     pCellMix_diffKr :: vertical diffusivity for too thin partial-cell
C     deltaT    :: Default timestep ( s )
C     deltaTClock  :: Timestep used as model "clock". This determines the
C                    IO frequencies and is used in tagging output. It can
C                    be totally different to the dynamical time. Typically
C                    it will be the deep-water timestep for accelerated runs.
C                    Frequency of checkpointing and dumping of the model state
C                    are referenced to this clock. ( s )
C     deltaTMom    :: Timestep for momemtum equations ( s )
C     dTtracerLev  :: Timestep for tracer equations ( s ), function of level k
C     deltaTFreeSurf :: Timestep for free-surface equation ( s )
C     freeSurfFac  :: Parameter to turn implicit free surface term on or off
C                     freeSurFac = 1. uses implicit free surface
C                     freeSurFac = 0. uses rigid lid
C     abEps        :: Adams-Bashforth-2 stabilizing weight
C     alph_AB      :: Adams-Bashforth-3 primary factor
C     beta_AB      :: Adams-Bashforth-3 secondary factor
C     implicSurfPress :: parameter of the Crank-Nickelson time stepping :
C                     Implicit part of Surface Pressure Gradient ( 0-1 )
C     implicDiv2DFlow :: parameter of the Crank-Nickelson time stepping :
C                     Implicit part of barotropic flow Divergence ( 0-1 )
C     implicitNHPress :: parameter of the Crank-Nickelson time stepping :
C                     Implicit part of Non-Hydrostatic Pressure Gradient ( 0-1 )
C     hFacMin      :: Minimum fraction size of a cell (affects hFacC etc...)
C     hFacMinDz    :: Minimum dimensional size of a cell (affects hFacC etc..., m)
C     hFacMinDp    :: Minimum dimensional size of a cell (affects hFacC etc..., Pa)
C     hFacMinDr    :: Minimum dimensional size of a cell (-> hFacC etc..., r units)
C     hFacInf      :: Threshold (inf and sup) for fraction size of surface cell
C     hFacSup          that control vanishing and creating levels
C     tauCD         :: CD scheme coupling timescale ( s )
C     rCD           :: CD scheme normalised coupling parameter (= 1 - deltaT/tauCD)
C     epsAB_CD      :: Adams-Bashforth-2 stabilizing weight used in CD scheme
C     baseTime      :: model base time (time origin) = time @ iteration zero
C     startTime     :: Starting time for this integration ( s ).
C     endTime       :: Ending time for this integration ( s ).
C     chkPtFreq     :: Frequency of rolling check pointing ( s ).
C     pChkPtFreq    :: Frequency of permanent check pointing ( s ).
C     dumpFreq      :: Frequency with which model state is written to
C                      post-processing files ( s ).
C     diagFreq      :: Frequency with which model writes diagnostic output
C                      of intermediate quantities.
C     afFacMom      :: Advection of momentum term multiplication factor
C     vfFacMom      :: Momentum viscosity term    multiplication factor
C     pfFacMom      :: Momentum pressure forcing  multiplication factor
C     cfFacMom      :: Coriolis term              multiplication factor
C     foFacMom      :: Momentum forcing           multiplication factor
C     mtFacMom      :: Metric terms               multiplication factor
C     cosPower      :: Power of cosine of latitude to multiply viscosity
C     cAdjFreq      :: Frequency of convective adjustment
C
C     taveFreq      :: Frequency with which time-averaged model state
C                      is written to post-processing files ( s ).
C     tave_lastIter :: (for state variable only) fraction of the last time
C                      step (of each taveFreq period) put in the time average.
C                      (fraction for 1rst iter = 1 - tave_lastIter)
C     tauThetaClimRelax :: Relaxation to climatology time scale ( s ).
C     tauSaltClimRelax :: Relaxation to climatology time scale ( s ).
C     latBandClimRelax :: latitude band where Relaxation to Clim. is applied,
C                         i.e. where |yC| <= latBandClimRelax
C     externForcingPeriod :: Is the period of which forcing varies (eg. 1 month)
C     externForcingCycle :: Is the repeat time of the forcing (eg. 1 year)
C                          (note: externForcingCycle must be an integer
C                           number times externForcingPeriod)
C     convertFW2Salt :: salinity, used to convert Fresh-Water Flux to Salt Flux
C                       (use model surface (local) value if set to -1)
C     temp_EvPrRn :: temperature of Rain & Evap.
C     salt_EvPrRn :: salinity of Rain & Evap.
C     temp_addMass :: temperature of addMass field
C     salt_addMass :: salinity of addMass field
C        (notes: a) tracer content of Rain/Evap only used if both
C                     NonLin_FrSurf & useRealFreshWater are set.
C                b) use model surface (local) value if set to UNSET_RL)
C     hMixCriteria:: criteria for mixed-layer diagnostic
C     dRhoSmall   :: parameter for mixed-layer diagnostic
C     hMixSmooth  :: Smoothing parameter for mixed-layer diag
C                    (default=0: no smoothing)
C     ivdc_kappa  :: implicit vertical diffusivity for convection [m^2/s]
C     sideDragFactor     :: side-drag scaling factor (used only if no_slip_sides)
C                           (default=2: full drag ; =1: gives half-slip BC)
C     bottomDragLinear    :: Linear    bottom-drag coefficient (units of [r]/s)
C     bottomDragQuadratic :: Quadratic bottom-drag coefficient (units of [r]/m)
C               (if using zcoordinate, units becomes linear: m/s, quadratic: [-])
C     zRoughBot :: roughness length for quadratic bottom friction coefficient
C                  (in m, typical values are order 0.01 m)
C     smoothAbsFuncRange :: 1/2 of interval around zero, for which FORTRAN ABS
C                           is to be replace by a smoother function
C                           (affects myabs, mymin, mymax)
C     nh_Am2        :: scales non-hydrostatic terms and changes internal scales
C                      (i.e. allows convection at different Rayleigh numbers)
C     tCylIn        :: Temperature of the cylinder inner boundary
C     tCylOut       :: Temperature of the cylinder outer boundary
C     phiEuler      :: Euler angle, rotation about original z-axis
C     thetaEuler    :: Euler angle, rotation about new x-axis
C     psiEuler      :: Euler angle, rotation about new z-axis
      COMMON /parm_r/ cg2dtargetresidual, cg2dtargetreswunit, 
     +cg2dpcoffdfac, cg3dtargetresidual, cg3dtargetreswunit, delr, delrc
     +, xgorigin, ygorigin, rsphere, recip_rsphere, radius_fromhorizgrid
     +, sealev_z, top_pres, rsigmabnd, deltat, deltatmom, dttracerlev, 
     +deltatfreesurf, deltatclock, abeps, alph_ab, beta_ab, f0, beta, 
     +fprime, omega, rotationperiod, viscfacadj, viscah, viscahw, 
     +smag3d_coeff, smag3d_diffcoeff, viscahmax, viscahgrid, 
     +viscahgridmax, viscahgridmin, viscc2leith, viscc2leithd, 
     +viscc2leithqg, viscc2smag, viscc4smag, viscahd, viscahz, visca4d, 
     +visca4z, visca4, visca4w, visca4max, visca4grid, visca4gridmax, 
     +visca4gridmin, viscahremax, visca4remax, viscc4leith, viscc4leithd
     +, viscarnr, diffkht, diffk4t, diffkrnrt, diffkr4t, diffkhs, 
     +diffk4s, diffkrnrs, diffkr4s, diffkrbl79surf, diffkrbl79deep, 
     +diffkrbl79scl, diffkrbl79ho, bl79latvary, diffkrbleqsurf, 
     +diffkrbleqdeep, diffkrbleqscl, diffkrbleqho, pcellmix_maxfac, 
     +pcellmix_delr, pcellmix_viscar, pcellmix_diffkr, taucd, rcd, 
     +epsab_cd, freesurffac, implicsurfpress, implicdiv2dflow, 
     +implicitnhpress, hfacmin, hfacmindz, hfacinf, hfacsup, gravity, 
     +recip_gravity, gbaro, gravfacc, recip_gravfacc, gravfacf, 
     +recip_gravfacf, rhonil, rhoconst, recip_rhoconst, rho1ref, rhofacc
     +, recip_rhofacc, rhofacf, recip_rhofacf, rhoconstfresh, thetaconst
     +, tref, sref, rhoref, dbdrref, surf_pref, pref4eos, phiref, 
     +rvel2wunit, wunit2rvel, runit2z, z2runit, mass2runit, runit2mass, 
     +basetime, starttime, endtime, chkptfreq, pchkptfreq, dumpfreq, 
     +adjdumpfreq, diagfreq, tavefreq, tave_lastiter, monitorfreq, 
     +adjmonitorfreq, affacmom, vffacmom, pffacmom, cffacmom, fofacmom, 
     +mtfacmom, cospower, cadjfreq, tauthetaclimrelax, tausaltclimrelax
     +, latbandclimrelax, externforcingcycle, externforcingperiod, 
     +convertfw2salt, temp_evprrn, salt_evprrn, temp_addmass, 
     +salt_addmass, hfacmindr, hfacmindp, ivdc_kappa, hmixcriteria, 
     +drhosmall, hmixsmooth, sidedragfactor, bottomdraglinear, 
     +bottomdragquadratic, zroughbot, nh_am2, smoothabsfuncrange, 
     +siceloadfac, tcylin, tcylout, phieuler, thetaeuler, psieuler
C
      REAL*8 cg2dtargetresidual
      REAL*8 cg2dtargetreswunit
      REAL*8 cg3dtargetresidual
      REAL*8 cg3dtargetreswunit
      REAL*8 cg2dpcoffdfac
      REAL*8 delr(nr)
      REAL*8 delrc(nr+1)
      REAL*8 xgorigin
      REAL*8 ygorigin
      REAL*8 rsphere
      REAL*8 recip_rsphere
      REAL*8 radius_fromhorizgrid
      REAL*8 sealev_z
      REAL*8 top_pres
      REAL*8 rsigmabnd
      REAL*8 deltat
      REAL*8 deltatclock
      REAL*8 deltatmom
      REAL*8 dttracerlev(nr)
      REAL*8 deltatfreesurf
      REAL*8 abeps, alph_ab, beta_ab
      REAL*8 f0
      REAL*8 beta
      REAL*8 fprime
      REAL*8 omega
      REAL*8 rotationperiod
      REAL*8 freesurffac
      REAL*8 implicsurfpress
      REAL*8 implicdiv2dflow
      REAL*8 implicitnhpress
      REAL*8 hfacmin
      REAL*8 hfacmindz
      REAL*8 hfacmindp
      REAL*8 hfacmindr
      REAL*8 hfacinf
      REAL*8 hfacsup
      REAL*8 viscarnr(nr)
      REAL*8 viscfacadj
      REAL*8 viscah
      REAL*8 viscahw
      REAL*8 viscahd
      REAL*8 viscahz
      REAL*8 smag3d_coeff, smag3d_diffcoeff
      REAL*8 viscahmax
      REAL*8 viscahremax
      REAL*8 viscahgrid, viscahgridmax, viscahgridmin
      REAL*8 viscc2leith
      REAL*8 viscc2leithd
      REAL*8 viscc2leithqg
      REAL*8 viscc2smag
      REAL*8 visca4
      REAL*8 visca4w
      REAL*8 visca4d
      REAL*8 visca4z
      REAL*8 visca4max
      REAL*8 visca4remax
      REAL*8 visca4grid, visca4gridmax, visca4gridmin
      REAL*8 viscc4leith
      REAL*8 viscc4leithd
      REAL*8 viscc4smag
      REAL*8 diffkht
      REAL*8 diffk4t
      REAL*8 diffkrnrt(nr)
      REAL*8 diffkr4t(nr)
      REAL*8 diffkhs
      REAL*8 diffk4s
      REAL*8 diffkrnrs(nr)
      REAL*8 diffkr4s(nr)
      REAL*8 diffkrbl79surf
      REAL*8 diffkrbl79deep
      REAL*8 diffkrbl79scl
      REAL*8 diffkrbl79ho
      REAL*8 bl79latvary
      REAL*8 diffkrbleqsurf
      REAL*8 diffkrbleqdeep
      REAL*8 diffkrbleqscl
      REAL*8 diffkrbleqho
      REAL*8 pcellmix_maxfac
      REAL*8 pcellmix_delr
      REAL*8 pcellmix_viscar(nr)
      REAL*8 pcellmix_diffkr(nr)
      REAL*8 taucd, rcd, epsab_cd
      REAL*8 gravity, recip_gravity
      REAL*8 gbaro
      REAL*8 gravfacc(nr), recip_gravfacc(nr)
      REAL*8 gravfacf(nr+1), recip_gravfacf(nr+1)
      REAL*8 rhonil
      REAL*8 rhoconst, recip_rhoconst
      REAL*8 rho1ref(nr)
      REAL*8 rhofacc(nr), recip_rhofacc(nr)
      REAL*8 rhofacf(nr+1), recip_rhofacf(nr+1)
      REAL*8 rhoconstfresh
      REAL*8 thetaconst
      REAL*8 tref(nr)
      REAL*8 sref(nr)
      REAL*8 rhoref(nr)
      REAL*8 dbdrref(nr)
      REAL*8 surf_pref, pref4eos(nr)
      REAL*8 phiref(2*nr+1)
      REAL*8 rvel2wunit(nr+1), wunit2rvel(nr+1)
      REAL*8 runit2z(nr), z2runit(nr)
      REAL*8 mass2runit, runit2mass
      REAL*8 basetime
      REAL*8 starttime
      REAL*8 endtime
      REAL*8 chkptfreq
      REAL*8 pchkptfreq
      REAL*8 dumpfreq
      REAL*8 adjdumpfreq
      REAL*8 diagfreq
      REAL*8 tavefreq
      REAL*8 tave_lastiter
      REAL*8 monitorfreq
      REAL*8 adjmonitorfreq
      REAL*8 affacmom
      REAL*8 vffacmom
      REAL*8 pffacmom
      REAL*8 cffacmom
      REAL*8 fofacmom
      REAL*8 mtfacmom
      REAL*8 cospower
      REAL*8 cadjfreq
      REAL*8 tauthetaclimrelax
      REAL*8 tausaltclimrelax
      REAL*8 latbandclimrelax
      REAL*8 externforcingcycle
      REAL*8 externforcingperiod
      REAL*8 convertfw2salt
      REAL*8 temp_evprrn
      REAL*8 salt_evprrn
      REAL*8 temp_addmass
      REAL*8 salt_addmass
      REAL*8 ivdc_kappa
      REAL*8 hmixcriteria
      REAL*8 drhosmall
      REAL*8 hmixsmooth
      REAL*8 sidedragfactor
      REAL*8 bottomdraglinear
      REAL*8 bottomdragquadratic
      REAL*8 zroughbot
      REAL*8 smoothabsfuncrange
      REAL*8 siceloadfac
      REAL*8 nh_am2
      REAL*8 tcylin, tcylout
      REAL*8 phieuler, thetaeuler, psieuler
C
C--   COMMON /PARM_A/ Thermodynamics constants ?
      COMMON /parm_a/ heatcapacity_cp
      REAL*8 heatcapacity_cp
C
C--   COMMON /PARM_ATM/ Atmospheric physical parameters (Ideal Gas EOS, ...)
C     celsius2K :: convert centigrade (Celsius) degree to Kelvin
C     atm_Po    :: standard reference pressure
C     atm_Cp    :: specific heat (Cp) of the (dry) air at constant pressure
C     atm_Rd    :: gas constant for dry air
C     atm_kappa :: kappa = R/Cp (R: constant of Ideal Gas EOS)
C     atm_Rq    :: water vapour specific volume anomaly relative to dry air
C                  (e.g. typical value = (29/18 -1) 10^-3 with q [g/kg])
C     integr_GeoPot :: option to select the way we integrate the geopotential
C                     (still a subject of discussions ...)
C     selectFindRoSurf :: select the way surf. ref. pressure (=Ro_surf) is
C             derived from the orography. Implemented: 0,1 (see INI_P_GROUND)
      COMMON /parm_atm/ celsius2k, atm_cp, atm_rd, atm_kappa, atm_rq, 
     +atm_po, integr_geopot, selectfindrosurf
      REAL*8 celsius2k
      REAL*8 atm_po, atm_cp, atm_rd, atm_kappa, atm_rq
      INTEGER integr_geopot, selectfindrosurf
C
C---+----1----+----2----+----3----+----4----+----5----+----6----+----7-|--+----|
C-- Logical flags for selecting packages
      LOGICAL usegad
      LOGICAL useobcs
      LOGICAL useshap_filt
      LOGICAL usezonal_filt
      LOGICAL useopps
      LOGICAL usepp81
      LOGICAL usekl10
      LOGICAL usemy82
      LOGICAL useggl90
      LOGICAL usekpp
      LOGICAL usegmredi
      LOGICAL usedown_slope
      LOGICAL usebbl
      LOGICAL usecal
      LOGICAL useexf
      LOGICAL usebulkforce
      LOGICAL useebm
      LOGICAL usecheapaml
      LOGICAL useautodiff
      LOGICAL usegrdchk
      LOGICAL usesmooth
      LOGICAL useprofiles
      LOGICAL useecco
      LOGICAL usectrl
      LOGICAL usesbo
      LOGICAL useflt
      LOGICAL useptracers
      LOGICAL usegchem
      LOGICAL userbcs
      LOGICAL useoffline
      LOGICAL usematrix
      LOGICAL usefrazil
      LOGICAL useseaice
      LOGICAL usesalt_plume
      LOGICAL useshelfice
      LOGICAL usestic
      LOGICAL usestreamice
      LOGICAL useicefront
      LOGICAL usethsice
      LOGICAL useland
      LOGICAL useatm2d
      LOGICAL useaim
      LOGICAL useatm_phys
      LOGICAL usefizhi
      LOGICAL usegridalt
      LOGICAL usediagnostics
      LOGICAL useregrid
      LOGICAL uselayers
      LOGICAL usemnc
      LOGICAL userunclock
      LOGICAL useembed_files
      LOGICAL usemypackage
      COMMON /parm_packages/ usegad, useobcs, useshap_filt, 
     +usezonal_filt, useopps, usepp81, usekl10, usemy82, useggl90, 
     +usekpp, usegmredi, usebbl, usedown_slope, usecal, useexf, 
     +usebulkforce, useebm, usecheapaml, usegrdchk, usesmooth, 
     +useprofiles, useecco, usectrl, usesbo, useflt, useautodiff, 
     +useptracers, usegchem, userbcs, useoffline, usematrix, usefrazil, 
     +useseaice, usesalt_plume, useshelfice, usestic, usestreamice, 
     +useicefront, usethsice, useland, useatm2d, useaim, useatm_phys, 
     +usefizhi, usegridalt, usediagnostics, useregrid, uselayers, usemnc
     +, userunclock, useembed_files, usemypackage
C
C---+----1----+----2----+----3----+----4----+----5----+----6----+----7-|--+----|
C
C**************************************
C
C These includes are needed for
C AD-checkpointing.
C They provide the fields to be stored.
C
C
CBOP
C    !ROUTINE: GRID.h
C    !INTERFACE:
C    include GRID.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | GRID.h
C     | o Header file defining model grid.
C     *==========================================================*
C     | Model grid is defined for each process by reference to
C     | the arrays set here.
C     | Notes
C     | =====
C     | The standard MITgcm convention of westmost, southern most
C     | and upper most having the (1,1,1) index is used here.
C     | i.e.
C     |----------------------------------------------------------
C     | (1)  Plan view schematic of model grid (top layer i.e. )
C     |      ================================= ( ocean surface )
C     |                                        ( or top of     )
C     |                                        ( atmosphere    )
C     |      This diagram shows the location of the model
C     |      prognostic variables on the model grid. The "T"
C     |      location is used for all tracers. The figure also
C     |      shows the southern most, western most indexing
C     |      convention that is used for all model variables.
C     |
C     |
C     |             V(i=1,                     V(i=Nx,
C     |               j=Ny+1,                    j=Ny+1,
C     |               k=1)                       k=1)
C     |                /|\                       /|\  "PWX"
C     |       |---------|------------------etc..  |---- *---
C     |       |                     |                   *  |
C     |"PWY"*******************************etc..  **********"PWY"
C     |       |                     |                   *  |
C     |       |                     |                   *  |
C     |       |                     |                   *  |
C     |U(i=1, ==>       x           |             x     *==>U
C     |  j=Ny,|      T(i=1,         |          T(i=Nx,  *(i=Nx+1,
C     |  k=1) |        j=Ny,        |            j=Ny,  *  |j=Ny,
C     |       |        k=1)         |            k=1)   *  |k=1)
C     |
C     |       .                     .                      .
C     |       .                     .                      .
C     |       .                     .                      .
C     |       e                     e                   *  e
C     |       t                     t                   *  t
C     |       c                     c                   *  c
C     |       |                     |                   *  |
C     |       |                     |                   *  |
C     |U(i=1, ==>       x           |             x     *  |
C     |  j=2, |      T(i=1,         |          T(i=Nx,  *  |
C     |  k=1) |        j=2,         |            j=2,   *  |
C     |       |        k=1)         |            k=1)   *  |
C     |       |                     |                   *  |
C     |       |        /|\          |            /|\    *  |
C     |      -----------|------------------etc..  |-----*---
C     |       |       V(i=1,        |           V(i=Nx, *  |
C     |       |         j=2,        |             j=2,  *  |
C     |       |         k=1)        |             k=1)  *  |
C     |       |                     |                   *  |
C     |U(i=1, ==>       x         ==>U(i=2,       x     *==>U
C     |  j=1, |      T(i=1,         |  j=1,    T(i=Nx,  *(i=Nx+1,
C     |  k=1) |        j=1,         |  k=1)      j=1,   *  |j=1,
C     |       |        k=1)         |            k=1)   *  |k=1)
C     |       |                     |                   *  |
C     |       |        /|\          |            /|\    *  |
C     |"SB"++>|---------|------------------etc..  |-----*---
C     |      /+\      V(i=1,                    V(i=Nx, *
C     |       +         j=1,                      j=1,  *
C     |       +         k=1)                      k=1)  *
C     |     "WB"                                      "PWX"
C     |
C     |   N, y increasing northwards
C     |  /|\ j increasing northwards
C     |   |
C     |   |
C     |   ======>E, x increasing eastwards
C     |             i increasing eastwards
C     |
C     |    i: East-west index
C     |    j: North-south index
C     |    k: up-down index
C     |    U: x-velocity (m/s)
C     |    V: y-velocity (m/s)
C     |    T: potential temperature (oC)
C     | "SB": Southern boundary
C     | "WB": Western boundary
C     |"PWX": Periodic wrap around in X.
C     |"PWY": Periodic wrap around in Y.
C     |----------------------------------------------------------
C     | (2) South elevation schematic of model grid
C     |     =======================================
C     |     This diagram shows the location of the model
C     |     prognostic variables on the model grid. The "T"
C     |     location is used for all tracers. The figure also
C     |     shows the upper most, western most indexing
C     |     convention that is used for all model variables.
C     |
C     |      "WB"
C     |       +
C     |       +
C     |      \+/       /|\                       /|\       .
C     |"UB"++>|-------- | -----------------etc..  | ----*---
C     |       |    rVel(i=1,        |        rVel(i=Nx, *  |
C     |       |         j=1,        |             j=1,  *  |
C     |       |         k=1)        |             k=1)  *  |
C     |       |                     |                   *  |
C     |U(i=1, ==>       x         ==>U(i=2,       x     *==>U
C     |  j=1, |      T(i=1,         |  j=1,    T(i=Nx,  *(i=Nx+1,
C     |  k=1) |        j=1,         |  k=1)      j=1,   *  |j=1,
C     |       |        k=1)         |            k=1)   *  |k=1)
C     |       |                     |                   *  |
C     |       |        /|\          |            /|\    *  |
C     |       |-------- | -----------------etc..  | ----*---
C     |       |    rVel(i=1,        |        rVel(i=Nx, *  |
C     |       |         j=1,        |             j=1,  *  |
C     |       |         k=2)        |             k=2)  *  |
C     |
C     |       .                     .                      .
C     |       .                     .                      .
C     |       .                     .                      .
C     |       e                     e                   *  e
C     |       t                     t                   *  t
C     |       c                     c                   *  c
C     |       |                     |                   *  |
C     |       |                     |                   *  |
C     |       |                     |                   *  |
C     |       |                     |                   *  |
C     |       |        /|\          |            /|\    *  |
C     |       |-------- | -----------------etc..  | ----*---
C     |       |    rVel(i=1,        |        rVel(i=Nx, *  |
C     |       |         j=1,        |             j=1,  *  |
C     |       |         k=Nr)       |             k=Nr) *  |
C     |U(i=1, ==>       x         ==>U(i=2,       x     *==>U
C     |  j=1, |      T(i=1,         |  j=1,    T(i=Nx,  *(i=Nx+1,
C     |  k=Nr)|        j=1,         |  k=Nr)     j=1,   *  |j=1,
C     |       |        k=Nr)        |            k=Nr)  *  |k=Nr)
C     |       |                     |                   *  |
C     |"LB"++>==============================================
C     |                                               "PWX"
C     |
C     | Up   increasing upwards.
C     |/|\                                                       .
C     | |
C     | |
C     | =====> E  i increasing eastwards
C     | |         x increasing eastwards
C     | |
C     |\|/
C     | Down,k increasing downwards.
C     |
C     | Note: r => height (m) => r increases upwards
C     |       r => pressure (Pa) => r increases downwards
C     |
C     |
C     |    i: East-west index
C     |    j: North-south index
C     |    k: up-down index
C     |    U: x-velocity (m/s)
C     | rVel: z-velocity ( units of r )
C     |       The vertical velocity variable rVel is in units of
C     |       "r" the vertical coordinate. r in m will give
C     |       rVel m/s. r in Pa will give rVel Pa/s.
C     |    T: potential temperature (oC)
C     | "UB": Upper boundary.
C     | "LB": Lower boundary (always solid - therefore om|w == 0)
C     | "WB": Western boundary
C     |"PWX": Periodic wrap around in X.
C     |----------------------------------------------------------
C     | (3) Views showing nomenclature and indexing
C     |     for grid descriptor variables.
C     |
C     |      Fig 3a. shows the orientation, indexing and
C     |      notation for the grid spacing terms used internally
C     |      for the evaluation of gradient and averaging terms.
C     |      These varaibles are set based on the model input
C     |      parameters which define the model grid in terms of
C     |      spacing in X, Y and Z.
C     |
C     |      Fig 3b. shows the orientation, indexing and
C     |      notation for the variables that are used to define
C     |      the model grid. These varaibles are set directly
C     |      from the model input.
C     |
C     | Figure 3a
C     | =========
C     |       |------------------------------------
C     |       |                       |
C     |"PWY"********************************* etc...
C     |       |                       |
C     |       |                       |
C     |       |                       |
C     |       |                       |
C     |       |                       |
C     |       |                       |
C     |       |                       |
C     |
C     |       .                       .
C     |       .                       .
C     |       .                       .
C     |       e                       e
C     |       t                       t
C     |       c                       c
C     |       |-----------v-----------|-----------v----------|-
C     |       |                       |                      |
C     |       |                       |                      |
C     |       |                       |                      |
C     |       |                       |                      |
C     |       |                       |                      |
C     |       u<--dxF(i=1,j=2,k=1)--->u           t          |
C     |       |/|\       /|\          |                      |
C     |       | |         |           |                      |
C     |       | |         |           |                      |
C     |       | |         |           |                      |
C     |       |dyU(i=1,  dyC(i=1,     |                      |
C     | ---  ---|--j=2,---|--j=2,-----------------v----------|-
C     | /|\   | |  k=1)   |  k=1)     |          /|\         |
C     |  |    | |         |           |          dyF(i=2,    |
C     |  |    | |         |           |           |  j=1,    |
C     |dyG(   |\|/       \|/          |           |  k=1)    |
C     |   i=1,u---        t<---dxC(i=2,j=1,k=1)-->t          |
C     |   j=1,|                       |           |          |
C     |   k=1)|                       |           |          |
C     |  |    |                       |           |          |
C     |  |    |                       |           |          |
C     | \|/   |           |<---dxV(i=2,j=1,k=1)--\|/         |
C     |"SB"++>|___________v___________|___________v__________|_
C     |       <--dxG(i=1,j=1,k=1)----->
C     |      /+\                                              .
C     |       +
C     |       +
C     |     "WB"
C     |
C     |   N, y increasing northwards
C     |  /|\ j increasing northwards
C     |   |
C     |   |
C     |   ======>E, x increasing eastwards
C     |             i increasing eastwards
C     |
C     |    i: East-west index
C     |    j: North-south index
C     |    k: up-down index
C     |    u: x-velocity point
C     |    V: y-velocity point
C     |    t: tracer point
C     | "SB": Southern boundary
C     | "WB": Western boundary
C     |"PWX": Periodic wrap around in X.
C     |"PWY": Periodic wrap around in Y.
C     |
C     | Figure 3b
C     | =========
C     |
C     |       .                       .
C     |       .                       .
C     |       .                       .
C     |       e                       e
C     |       t                       t
C     |       c                       c
C     |       |-----------v-----------|-----------v--etc...
C     |       |                       |
C     |       |                       |
C     |       |                       |
C     |       |                       |
C     |       |                       |
C     |       u<--delX(i=1)---------->u           t
C     |       |                       |
C     |       |                       |
C     |       |                       |
C     |       |                       |
C     |       |                       |
C     |       |-----------v-----------------------v--etc...
C     |       |          /|\          |
C     |       |           |           |
C     |       |           |           |
C     |       |           |           |
C     |       u        delY(j=1)      |           t
C     |       |           |           |
C     |       |           |           |
C     |       |           |           |
C     |       |           |           |
C     |       |          \|/          |
C     |"SB"++>|___________v___________|___________v__etc...
C     |      /+\                                                 .
C     |       +
C     |       +
C     |     "WB"
C     |
C     *==========================================================*
C     \ev
CEOP
C
C     Macros that override/modify standard definitions
C
CBOP
C    !ROUTINE: GRID_MACROS.h
C    !INTERFACE:
C    include GRID_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | GRID_MACROS.h
C     *==========================================================*
C     | These macros are used to substitute definitions for
C     | GRID.h variables for particular configurations.
C     | In setting these variables the following convention
C     | applies.
C     | undef  phi_CONST   - Indicates the variable phi is fixed
C     |                      in X, Y and Z.
C     | undef  phi_FX      - Indicates the variable phi only
C     |                      varies in X (i.e.not in X or Z).
C     | undef  phi_FY      - Indicates the variable phi only
C     |                      varies in Y (i.e.not in X or Z).
C     | undef  phi_FXY     - Indicates the variable phi only
C     |                      varies in X and Y ( i.e. not Z).
C     *==========================================================*
C     \ev
CEOP
C
C
CBOP
C    !ROUTINE: DXC_MACROS.h
C    !INTERFACE:
C    include DXC_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | DXC_MACROS.h                                              
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: DXF_MACROS.h
C    !INTERFACE:
C    include DXF_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | DXF_MACROS.h                                              
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: DXG_MACROS.h
C    !INTERFACE:
C    include DXG_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | DXG_MACROS.h                                              
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: DXV_MACROS.h
C    !INTERFACE:
C    include DXV_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | DXV_MACROS.h                                              
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: DYC_MACROS.h
C    !INTERFACE:
C    include DYC_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | DYC_MACROS.h                                              
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: DYF_MACROS.h
C    !INTERFACE:
C    include DYF_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | DYF_MACROS.h                                              
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: DYG_MACROS.h
C    !INTERFACE:
C    include DYG_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | DYG_MACROS.h                                              
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: DYU_MACROS.h
C    !INTERFACE:
C    include DYU_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | DYU_MACROS.h                                              
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: HFACC_MACROS.h
C    !INTERFACE:
C    include HFACC_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | HFACC_MACROS.h                                            
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
C
C
CBOP
C    !ROUTINE: HFACS_MACROS.h
C    !INTERFACE:
C    include HFACS_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | HFACS_MACROS.h                                            
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
C
C
CBOP
C    !ROUTINE: HFACW_MACROS.h
C    !INTERFACE:
C    include HFACW_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | HFACW_MACROS.h                                            
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
C
C
CBOP
C    !ROUTINE: RECIP_DXC_MACROS.h
C    !INTERFACE:
C    include RECIP_DXC_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | RECIP_DXC_MACROS.h                                        
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: RECIP_DXF_MACROS.h
C    !INTERFACE:
C    include RECIP_DXF_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | RECIP_DXF_MACROS.h                                        
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: RECIP_DXG_MACROS.h
C    !INTERFACE:
C    include RECIP_DXG_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | RECIP_DXG_MACROS.h                                        
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: RECIP_DXV_MACROS.h
C    !INTERFACE:
C    include RECIP_DXV_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | RECIP_DXV_MACROS.h                                        
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: RECIP_DYC_MACROS.h
C    !INTERFACE:
C    include RECIP_DYC_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | RECIP_DYC_MACROS.h                                        
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: RECIP_DYF_MACROS.h
C    !INTERFACE:
C    include RECIP_DYF_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | RECIP_DYF_MACROS.h                                        
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: RECIP_DYG_MACROS.h
C    !INTERFACE:
C    include RECIP_DYG_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | RECIP_DYG_MACROS.h                                        
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: RECIP_DYU_MACROS.h
C    !INTERFACE:
C    include RECIP_DYU_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | RECIP_DYU_MACROS.h                                        
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: RECIP_HFACC_MACROS.h
C    !INTERFACE:
C    include RECIP_HFACC_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | RECIP_HFACC_MACROS.h                                      
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
C
C
CBOP
C    !ROUTINE: RECIP_HFACS_MACROS.h
C    !INTERFACE:
C    include RECIP_HFACS_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | RECIP_HFACS_MACROS.h                                      
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
C
C
CBOP
C    !ROUTINE: RECIP_HFACW_MACROS.h
C    !INTERFACE:
C    include RECIP_HFACW_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | RECIP_HFACW_MACROS.h                                      
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
C
C
CBOP
C    !ROUTINE: XC_MACROS.h
C    !INTERFACE:
C    include XC_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | XC_MACROS.h                                               
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: YC_MACROS.h
C    !INTERFACE:
C    include YC_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | YC_MACROS.h                                               
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: RA_MACROS.h
C    !INTERFACE:
C    include RA_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | RA_MACROS.h                                               
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
CBOP
C    !ROUTINE: RAW_MACROS.h
C    !INTERFACE:
C    include RAW_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | RAW_MACROS.h                                              
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
CBOP
C    !ROUTINE: RAS_MACROS.h
C    !INTERFACE:
C    include RAS_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | RAS_MACROS.h                                              
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: MASKW_MACROS.h
C    !INTERFACE:
C    include MASKW_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | MASKW_MACROS.h                                            
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
C
CBOP
C    !ROUTINE: MASKS_MACROS.h
C    !INTERFACE:
C    include MASKS_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | MASKS_MACROS.h                                            
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
C
CBOP
C    !ROUTINE: TANPHIATU_MACROS.h
C    !INTERFACE:
C    include TANPHIATU_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | TANPHIATU_MACROS.h                                        
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: TANPHIATV_MACROS.h
C    !INTERFACE:
C    include TANPHIATV_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | TANPHIATV_MACROS.h                                        
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: FCORI_MACROS.h
C    !INTERFACE:
C    include FCORI_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | FCORI_MACROS.h                                            
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C--   COMMON /GRID_RL/ RL valued grid defining variables.
C     deepFacC  :: deep-model grid factor (fct of vertical only) for dx,dy
C     deepFacF     at level-center (deepFacC)  and level interface (deepFacF)
C     deepFac2C :: deep-model grid factor (fct of vertical only) for area dx*dy
C     deepFac2F    at level-center (deepFac2C) and level interface (deepFac2F)
C     gravitySign :: indicates the direction of gravity relative to R direction
C                   (= -1 for R=Z (Z increases upward, -gravity direction  )
C                   (= +1 for R=P (P increases downward, +gravity direction)
C     rkSign     :: Vertical coordinate to vertical index orientation.
C                   ( +1 same orientation, -1 opposite orientation )
C     globalArea :: Domain Integrated horizontal Area [m2]
      COMMON /grid_rl/ cosfacu, cosfacv, sqcosfacu, sqcosfacv, deepfacc
     +, deepfac2c, recip_deepfacc, recip_deepfac2c, deepfacf, deepfac2f
     +, recip_deepfacf, recip_deepfac2f, gravitysign, rksign, globalarea
      REAL*8 cosfacu(1-oly:sny+oly, nsx, nsy)
      REAL*8 cosfacv(1-oly:sny+oly, nsx, nsy)
      REAL*8 sqcosfacu(1-oly:sny+oly, nsx, nsy)
      REAL*8 sqcosfacv(1-oly:sny+oly, nsx, nsy)
      REAL*8 deepfacc(nr)
      REAL*8 deepfac2c(nr)
      REAL*8 deepfacf(nr+1)
      REAL*8 deepfac2f(nr+1)
      REAL*8 recip_deepfacc(nr)
      REAL*8 recip_deepfac2c(nr)
      REAL*8 recip_deepfacf(nr+1)
      REAL*8 recip_deepfac2f(nr+1)
      REAL*8 gravitysign
      REAL*8 rksign
      REAL*8 globalarea
C
C--   COMMON /GRID_RS/ RS valued grid defining variables.
C     dxC     :: Cell center separation in X across western cell wall (m)
C     dxG     :: Cell face separation in X along southern cell wall (m)
C     dxF     :: Cell face separation in X thru cell center (m)
C     dxV     :: V-point separation in X across south-west corner of cell (m)
C     dyC     :: Cell center separation in Y across southern cell wall (m)
C     dyG     :: Cell face separation in Y along western cell wall (m)
C     dyF     :: Cell face separation in Y thru cell center (m)
C     dyU     :: U-point separation in Y across south-west corner of cell (m)
C     drC     :: Cell center separation along Z axis ( units of r ).
C     drF     :: Cell face separation along Z axis ( units of r ).
C     R_low   :: base of fluid in r_unit (Depth(m) / Pressure(Pa) at top Atmos.)
C     rLowW   :: base of fluid column in r_unit at Western  edge location.
C     rLowS   :: base of fluid column in r_unit at Southern edge location.
C     Ro_surf :: surface reference (at rest) position, r_unit.
C     rSurfW  :: surface reference position at Western  edge location [r_unit].
C     rSurfS  :: surface reference position at Southern edge location [r_unit].
C     hFac    :: Fraction of cell in vertical which is open i.e how
C              "lopped" a cell is (dimensionless scale factor).
C              Note: The code needs terms like MIN(hFac,hFac(I-1))
C                    On some platforms it may be better to precompute
C                    hFacW, hFacS, ... here than do MIN on the fly.
C     maskInC :: Cell Center 2-D Interior mask (i.e., zero beyond OB)
C     maskInW :: West  face 2-D Interior mask (i.e., zero on and beyond OB)
C     maskInS :: South face 2-D Interior mask (i.e., zero on and beyond OB)
C     maskC   :: cell Center land mask
C     maskW   :: West face land mask
C     maskS   :: South face land mask
C     recip_dxC   :: Reciprocal of dxC
C     recip_dxG   :: Reciprocal of dxG
C     recip_dxF   :: Reciprocal of dxF
C     recip_dxV   :: Reciprocal of dxV
C     recip_dyC   :: Reciprocal of dxC
C     recip_dyG   :: Reciprocal of dyG
C     recip_dyF   :: Reciprocal of dyF
C     recip_dyU   :: Reciprocal of dyU
C     recip_drC   :: Reciprocal of drC
C     recip_drF   :: Reciprocal of drF
C     recip_Rcol  :: Inverse of cell center column thickness (1/r_unit)
C     recip_hFacC :: Inverse of cell open-depth f[X,Y,Z] ( dimensionless ).
C     recip_hFacW    rhFacC center, rhFacW west, rhFacS south.
C     recip_hFacS   Note: This is precomputed here because it involves division.
C     xC     :: X-coordinate of cell center f[X,Y]. The units of xc, yc
C               depend on the grid. They are not used in differencing or
C               averaging but are just a convient quantity for I/O,
C               diagnostics etc.. As such xc is in m for cartesian
C               coordinates but degrees for spherical polar.
C     yC     :: Y-coordinate of center of cell f[X,Y].
C     yG     :: Y-coordinate of corner of cell (c-grid vorticity point) f[X,Y].
C     rA     :: R-face are f[X,Y] ( m^2 ).
C               Note: In a cartesian framework rA is simply dx*dy,
C                   however we use rA to allow for non-globally
C                   orthogonal coordinate frames (with appropriate
C                   metric terms).
C     rC     :: R-coordinate of center of cell f[Z] (units of r).
C     rF     :: R-coordinate of face of cell f[Z] (units of r).
C - *HybSigm* - :: Hybrid-Sigma vert. Coord coefficients
C     aHybSigmF    at level-interface (*HybSigmF) and level-center (*HybSigmC)
C     aHybSigmC    aHybSigm* = constant r part, bHybSigm* = sigma part, such as
C     bHybSigmF    r(ij,k,t) = rLow(ij) + aHybSigm(k)*[rF(1)-rF(Nr+1)]
C     bHybSigmC              + bHybSigm(k)*[eta(ij,t)+Ro_surf(ij) - rLow(ij)]
C     dAHybSigF :: vertical increment of Hybrid-Sigma coeff.: constant r part,
C     dAHybSigC    between interface (dAHybSigF) and between center (dAHybSigC)
C     dBHybSigF :: vertical increment of Hybrid-Sigma coefficient: sigma part,
C     dBHybSigC    between interface (dBHybSigF) and between center (dBHybSigC)
C     tanPhiAtU :: tan of the latitude at U point. Used for spherical polar
C                  metric term in U equation.
C     tanPhiAtV :: tan of the latitude at V point. Used for spherical polar
C                  metric term in V equation.
C     angleCosC :: cosine of grid orientation angle relative to Geographic
C direction at cell center: alpha=(Eastward_dir,grid_uVel_dir)=(North_d,vVel_d)
C     angleSinC :: sine   of grid orientation angle relative to Geographic
C direction at cell center: alpha=(Eastward_dir,grid_uVel_dir)=(North_d,vVel_d)
C     u2zonDir  :: cosine of grid orientation angle at U point location
C     v2zonDir  :: minus sine of  orientation angle at V point location
C     fCori     :: Coriolis parameter at grid Center point
C     fCoriG    :: Coriolis parameter at grid Corner point
C     fCoriCos  :: Coriolis Cos(phi) parameter at grid Center point (for NH)
C
      COMMON /grid_rs/ dxc, dxf, dxg, dxv, dyc, dyf, dyg, dyu, rloww, 
     +rlows, ro_surf, rsurfw, rsurfs, recip_dxc, recip_dxf, recip_dxg, 
     +recip_dxv, recip_dyc, recip_dyf, recip_dyg, recip_dyu, xc, yc, ra
     +, raw, ras, raz, xg, yg, maskinc, maskinw, maskins, maskc, maskw, 
     +masks, recip_ra, recip_raw, recip_ras, recip_raz, drc, drf, 
     +recip_drc, recip_drf, rc, rf, ahybsigmf, bhybsigmf, ahybsigmc, 
     +bhybsigmc, dahybsigf, dbhybsigf, dbhybsigc, dahybsigc, tanphiatu, 
     +tanphiatv, anglecosc, anglesinc, u2zondir, v2zondir, fcori, fcorig
     +, fcoricos
      REAL*8 dxc(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 dxf(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 dxg(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 dxv(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 dyc(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 dyf(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 dyg(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 dyu(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 rloww(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 rlows(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 ro_surf(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 rsurfw(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 rsurfs(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 recip_dxc(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 recip_dxf(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 recip_dxg(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 recip_dxv(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 recip_dyc(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 recip_dyf(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 recip_dyg(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 recip_dyu(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 xc(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 xg(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 yc(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 yg(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 ra(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 raw(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 ras(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 raz(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 recip_ra(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 recip_raw(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 recip_ras(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 recip_raz(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 maskinc(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 maskinw(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 maskins(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 maskc(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 maskw(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 masks(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 drc(nr+1)
      REAL*8 drf(nr)
      REAL*8 recip_drc(nr+1)
      REAL*8 recip_drf(nr)
      REAL*8 rc(nr)
      REAL*8 rf(nr+1)
      REAL*8 ahybsigmf(nr+1)
      REAL*8 bhybsigmf(nr+1)
      REAL*8 ahybsigmc(nr)
      REAL*8 bhybsigmc(nr)
      REAL*8 dahybsigf(nr)
      REAL*8 dbhybsigf(nr)
      REAL*8 dbhybsigc(nr+1)
      REAL*8 dahybsigc(nr+1)
      REAL*8 tanphiatu(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 tanphiatv(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 anglecosc(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 anglesinc(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 u2zondir(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 v2zondir(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 fcori(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 fcorig(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 fcoricos(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
C--   COMMON /GRID_VAR_RS/ potentially time-dependent or active RS
C     valued grid defining variables. These grid defining variables are
C     time-dependent when using a non-linear free surface, or they are
C     active in an AD sense when using depth as a control parameter, or
C     both.
      COMMON /grid_var_rs/ hfacc, hfacw, hfacs, recip_hfacc, recip_hfacw
     +, recip_hfacs, r_low, recip_rcol
      COMMON /grid_var_rs_b/ hfaccb, hfacwb, hfacsb, recip_hfaccb, 
     +recip_hfacwb, recip_hfacsb
      REAL*8 hfacc(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 hfaccb(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 hfacw(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 hfacwb(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 hfacs(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 hfacsb(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 recip_hfacc(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 recip_hfaccb(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 recip_hfacw(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 recip_hfacwb(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 recip_hfacs(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 recip_hfacsb(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 r_low(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 recip_rcol(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
C
C--   COMMON /GRID_I/ INTEGER valued grid defining variables.
C     kSurfC  :: vertical index of the surface tracer cell
C     kSurfW  :: vertical index of the surface U point
C     kSurfS  :: vertical index of the surface V point
C     kLowC   :: index of the r-lowest "wet cell" (2D)
C IMPORTANT: kLowC = 0 and kSurfC,W,S = Nr+1 (or =Nr+2 on a thin-wall)
C            where the fluid column is empty (continent)
      COMMON /grid_i/ ksurfc, ksurfw, ksurfs, klowc
      INTEGER ksurfc(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      INTEGER ksurfw(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      INTEGER ksurfs(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      INTEGER klowc(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
C---+----1----+----2----+----3----+----4----+----5----+----6----+----7-|--+----|
CBOP
C     !ROUTINE: DYNVARS.h
C     !INTERFACE:
C     include "DYNVARS.h"
C     !DESCRIPTION:
C     \bv
C     *==========================================================*
C     | DYNVARS.h
C     | o Dynamical model variables (common block DYNVARS_R)
C     *==========================================================*
C     | The value and two levels of time tendency are held for
C     | each prognostic variable.
C     *==========================================================*
C     \ev
CEOP
C
C     State Variables:
C     etaN  :: free-surface r-anomaly (r unit) at current time level
C     uVel  :: zonal velocity (m/s, i=1 held at western face)
C     vVel  :: meridional velocity (m/s, j=1 held at southern face)
C     theta :: potential temperature (oC, held at pressure/tracer point)
C     salt  :: salinity (g/kg, held at pressure/tracer point; note that
C              salinity is either a conductivity ratio or, if using TEOS10,
C              a mass ratio;here we assume it is a mass ratio even though
C              it is only correct for TEOS10)
C     gX, gxNm1 :: Time tendencies at current and previous time levels.
C     etaH  :: surface r-anomaly, advanced in time consistently
C              with 2.D flow divergence (Exact-Conservation):
C                etaH^n+1 = etaH^n - delta_t*Div.(H^n U^n+1)
C  note: a) used with "exactConserv", necessary for Non-Lin free-surf and mixed
C           forward/backward free-surf time stepping (e.g., Crank-Nickelson)
C        b) same as etaN but not necessarily at the same time, e.g.:
C           implicDiv2DFlow=1 => etaH=etaN ; =0 => etaH=etaN^(n-1);
C
      COMMON /dynvars_r/ etan, uvel, vvel, wvel, theta, salt, gu, gv, 
     +gunm1, gvnm1, gtnm1, gsnm1
      COMMON /dynvars_r_b/ etanb, uvelb, vvelb, wvelb, thetab, saltb, 
     +gub, gvb, gunm1b, gvnm1b, gtnm1b, gsnm1b
      REAL*8 etan(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 etanb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 uvel(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 uvelb(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 vvel(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 vvelb(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 wvel(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 wvelb(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 theta(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 thetab(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 salt(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 saltb(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 gu(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 gub(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 gv(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 gvb(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 gunm1(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 gunm1b(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 gvnm1(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 gvnm1b(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 gtnm1(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 gtnm1b(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 gsnm1(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 gsnm1b(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
C
C
      COMMON /dynvars_r_2/ etah
      COMMON /dynvars_r_2_b/ etahb
      REAL*8 etah(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 etahb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
C
C
C   The following blocks containing requires anomaly fields of control vars
C   and related to Options:
C   ALLOW_KAPGM_CONTROL , ALLOW_KAPREDI_CONTROL and ALLOW_BOTTOMDRAG_CONTROL
C   have been moved to header file "CTRL_FIELDS.h"
C
C
C     Diagnostic Variables:
C     rhoInSitu    :: In-Situ density anomaly [kg/m^3] at cell center level.
C     totPhiHyd    :: total hydrostatic Potential (anomaly, for now),
C                     at cell center level ; includes surface contribution.
C                     (for diagnostic + used in Z-coord with EOS_funct_P)
C     phiHydLow    :: Phi-Hydrostatic at r-lower boundary
C                     (bottom in z-coordinates, top in p-coordinates)
C     hMixLayer    :: Mixed layer depth [m]
C                     (for diagnostic + used GMRedi "fm07")
C     IVDConvCount :: Impl.Vert.Diffusion convection counter:
C                     = 0 (not convecting) or 1 (convecting)
      COMMON /dynvars_diag/ rhoinsitu, totphihyd, phihydlow, hmixlayer, 
     +ivdconvcount
      COMMON /dynvars_diag_b/ rhoinsitub, totphihydb
      REAL*8 rhoinsitu(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 rhoinsitub(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 totphihyd(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 totphihydb(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 phihydlow(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 hmixlayer(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 ivdconvcount(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
C
C
C
C
C
CBOP
C    !ROUTINE: SURFACE.h
C    !INTERFACE:
C    include SURFACE.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | SURFACE.h
C     | o Header file defining surface-related model variables
C     *==========================================================*
C     | Contains variables relative to the surface position
C     | that are held fixed in linear free-surface formulation
C     | but can vary with time with a non-linear free-surface.
C     *==========================================================*
C     \ev
CEOP
C
C--   COMMON /SURF_FIXED/  fixed surface arrays (Real)
C     Bo_surf  :: Buoyancy|1/rho [ocean|atmos] at surface level [=g|alpha(p_o)]
C     recip_Bo :: 1/Bo_surf
C     topoZ    :: topographic height [m] (used mainly for atmosphere)
C     phi0surf :: starting point for integrating phi_Hyd
      COMMON /surf_fixed/ bo_surf, recip_bo, topoz, phi0surf
      COMMON /surf_fixed_b/ phi0surfb
      REAL*8 bo_surf(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 recip_bo(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 topoz(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 phi0surf(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 phi0surfb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
C--   COMMON /SURF_CORREC/ Common block for correction of source/sink of
C--                        Tracer due to W at the surface with Linear
C--                        Free Surface
C     TsurfCor :: Pot.Temp Linear-Free-Surface correction term [K.r_Unit/s]
C     SsurfCor :: Salinity Linear-Free-Surface correction term [g/kg.r_Unit/s]
      COMMON /surf_correc/ tsurfcor, ssurfcor
      COMMON /surf_correc_b/ tsurfcorb, ssurfcorb
      REAL*8 tsurfcor
      REAL*8 tsurfcorb
      REAL*8 ssurfcor
      REAL*8 ssurfcorb
C
C     etaHnm1 :: surface r-anomaly, etaH, at previous time level
C     dEtaHdt :: time derivative of total column height [r_unit/s = w unit]
C     PmEpR   :: keep the fresh water input (=-EmPmR) of the previous time step
      COMMON /exact_eta_local/ etahnm1, detahdt, pmepr
      COMMON /exact_eta_local_b/ detahdtb, pmeprb
      REAL*8 etahnm1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 detahdt(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 detahdtb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 pmepr(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 pmeprb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
C--   COMMON /SURF_CHANGE/ transient variables used for Non-Lin Free-Surf
C     hFac_surfC ::  New thickness factor of the surface level
C                        center (Tracer point)
C     hFac_surfW ::  idem, West  interface (U point)
C     hFac_surfS ::  idem, South interface (V point)
C     hFac_surfNm1C, etc. :: prior values
      COMMON /surf_change/ hfac_surfc, hfac_surfw, hfac_surfs, 
     +hfac_surfnm1c, hfac_surfnm1w, hfac_surfnm1s
      COMMON /surf_change_b/ hfac_surfcb, hfac_surfwb, hfac_surfsb, 
     +hfac_surfnm1cb, hfac_surfnm1wb, hfac_surfnm1sb
      REAL*8 hfac_surfc(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 hfac_surfcb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 hfac_surfw(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 hfac_surfwb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 hfac_surfs(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 hfac_surfsb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 hfac_surfnm1c(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 hfac_surfnm1cb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 hfac_surfnm1w(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 hfac_surfnm1wb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 hfac_surfnm1s(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 hfac_surfnm1sb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
C     Local variables in common block
C     Rmin_surf :: minimum r_value of the free surface position
C                  that satisfy  the hFacInf criteria
      COMMON /local_calc_surf_dr/ rmin_surf
      REAL*8 rmin_surf(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
C--   COMMON /RSTAR_CHANGE/ transient variables used with r* Coordinate
C     rStarFacC :: = dr/dr* = ratio of r-thickness / r*-thickness = h^n / H
C     rStarFacW :: same but for West  face
C     rStarFacS :: same but for South face
C     pStarFacK :: rStarFacC**atm_kappa (for atmosphere in p* coords)
C     rStarFacNm1C, etc. :: prior values
C     rStarExpC :: column expansion factor = h^n+1/h^n , Centered
C     rStarExpW :: column expansion factor = h^n+1/h^n , Western  face
C     rStarExpS :: column expansion factor = h^n+1/h^n , Southern face
C     rStarDhCDt:: relative time derivative of h_Center = d.eta/dt / H
C     rStarDhWDt:: relative time derivative of h_West_face  (u.point)
C     rStarDhSDt:: relative time derivative of h_South_face (v.point)
      COMMON /rstar_change/ rstarfacc, rstarfacw, rstarfacs, pstarfack, 
     +rstarfacnm1c, rstarfacnm1w, rstarfacnm1s, rstarexpc, rstarexpw, 
     +rstarexps, rstardhcdt, rstardhwdt, rstardhsdt
      COMMON /rstar_change_b/ rstarfaccb, rstarfacwb, rstarfacsb, 
     +pstarfackb, rstarfacnm1cb, rstarfacnm1wb, rstarfacnm1sb, 
     +rstarexpcb, rstarexpwb, rstarexpsb, rstardhcdtb, rstardhwdtb, 
     +rstardhsdtb
      REAL*8 rstarfacc(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 rstarfaccb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 rstarfacw(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 rstarfacwb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 rstarfacs(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 rstarfacsb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 pstarfack(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 pstarfackb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 rstarfacnm1c(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 rstarfacnm1cb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 rstarfacnm1w(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 rstarfacnm1wb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 rstarfacnm1s(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 rstarfacnm1sb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 rstarexpc(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 rstarexpcb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 rstarexpw(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 rstarexpwb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 rstarexps(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 rstarexpsb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 rstardhcdt(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 rstardhcdtb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 rstardhwdt(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 rstardhwdtb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 rstardhsdt(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 rstardhsdtb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
C--   COMMON /RSTAR_FIXED/ fixed thickness ratio ( r* discretization )
C     h0FacC :: initial (and fixed in time) hFacC factor
C     h0FacW :: initial (and fixed in time) hFacW factor
C     h0FacS :: initial (and fixed in time) hFacS factor
      COMMON /rstar_fixed/ h0facc, h0facw, h0facs
      REAL*8 h0facc(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 h0facw(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 h0facs(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
C
C--   COMMON /SIGMA_CHANGE/ transient variables used with r* Coordinate
C     etaHw    :: surface r-anomaly (etaH) at Western  edge (U location)
C     etaHs    :: surface r-anomaly (etaH) at Southern edge (V location)
C     dEtaWdt  :: time derivative of etaH at Western  edge (U location)
C     dEtaSdt  :: time derivative of etaH at Southern edge (V location)
      COMMON /sigma_change/ etahw, etahs, detawdt, detasdt
      REAL*8 etahw(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 etahs(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 detawdt(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 detasdt(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
CBOP
C     !ROUTINE: FFIELDS.h
C     !INTERFACE:
C     include "FFIELDS.h"
C     !DESCRIPTION:
C     \bv
C     *==========================================================*
C     | FFIELDS.h
C     | o Model forcing fields
C     *==========================================================*
C     | More flexible surface forcing configurations are
C     | available via, e.g., pkg/exf
C     *==========================================================*
C     \ev
CEOP
C
C     fu    :: Zonal surface wind stress in N/m^2
C              > 0 for increase in uVel, which is west to
C                  east for cartesian and spherical polar grids
C              Typical range: -0.5 < fu < 0.5
C              Southwest C-grid U point
C
C     fv    :: Meridional surface wind stress in N/m^2
C              > 0 for increase in vVel, which is south to
C                  north for cartesian and spherical polar grids
C              Typical range: -0.5 < fv < 0.5
C              Southwest C-grid V point
C
C     EmPmR :: Net upward freshwater flux in kg/m2/s
C              EmPmR = Evaporation - precipitation - runoff
C              > 0 for increase in salt (ocean salinity)
C              Typical range: -1e-4 < EmPmR < 1e-4
C              Southwest C-grid tracer point
C           NOTE: for backward compatibility EmPmRfile is specified in
C                 m/s when using external_fields_load.F.  It is converted
C                 to kg/m2/s by multiplying by rhoConstFresh.
C
C  saltFlux :: Net upward salt flux in g/kg.kg/m^2/s = g/m^2/s
C              flux of Salt taken out of the ocean per time unit (second).
C              Note: only used when salty sea-ice forms or melts.
C              > 0 for decrease in SSS.
C              Southwest C-grid tracer point
C
C     Qnet  :: Net upward surface heat flux (including shortwave) in W/m^2
C              Qnet = latent + sensible + net longwave + net shortwave
C              > 0 for decrease in theta (ocean cooling)
C              Typical range: -250 < Qnet < 600
C              Southwest C-grid tracer point
C
C     Qsw   :: Net upward shortwave radiation in W/m^2
C              Qsw = - ( downward - ice and snow absorption - reflected )
C              > 0 for decrease in theta (ocean cooling)
C              Typical range: -350 < Qsw < 0
C              Southwest C-grid tracer point
C
C     SST   :: Sea surface temperature in degrees C for relaxation
C              Southwest C-grid tracer point
C
C     SSS   :: Sea surface salinity in g/kg for relaxation
C              Southwest C-grid tracer point
C
C     lambdaThetaClimRelax :: Inverse time scale for SST relaxation ( 1/s ).
C
C     lambdaSaltClimRelax  :: Inverse time scale for SSS relaxation ( 1/s ).
C
C     phiTide2d :: vertically uniform (2d-map), time-dependent geopotential
C                  anomaly (e.g., tidal forcing); Units are m^2/s^2
C     pLoad :: for the ocean:      atmospheric pressure anomaly (relative to
C                                   "surf_pRef") at z=eta
C                Units are           Pa=N/m^2
C              for the atmosphere (hack): geopotential anomaly of the orography
C                Units are           m^2/s^2
C     sIceLoad :: sea-ice loading, expressed in Mass of ice+snow / area unit
C                Units are           kg/m^2
C              Note: only used with Sea-Ice & RealFreshWater formulation
C     addMass  :: source (<0: sink) of fluid in the domain interior
C                 (generalisation of oceanic real fresh-water flux)
C                Units are           kg/s  (mass per unit of time)
C     frictionHeating :: heating caused by friction and momentum dissipation
C                Units are           in W/m^2 (thickness integrated)
C     eddyPsiX -Zonal Eddy Streamfunction in m^2/s used in taueddy_external_forcing.F
C     eddyPsiY -Meridional Streamfunction in m^2/s used in taueddy_external_forcing.F
C     EfluxY - y-component of Eliassen-Palm flux vector
C     EfluxP - p-component of Eliassen-Palm flux vector
C
      COMMON /ffields_fu/ fu
      COMMON /ffields_fu_b/ fub
      COMMON /ffields_fv/ fv
      COMMON /ffields_fv_b/ fvb
      COMMON /ffields_qnet/ qnet
      COMMON /ffields_qnet_b/ qnetb
      COMMON /ffields_qsw/ qsw
      COMMON /ffields_qsw_b/ qswb
      COMMON /ffields_empmr/ empmr
      COMMON /ffields_empmr_b/ empmrb
      COMMON /ffields_saltflux/ saltflux
      COMMON /ffields_saltflux_b/ saltfluxb
      COMMON /ffields_sst/ sst
      COMMON /ffields_sst_b/ sstb
      COMMON /ffields_sss/ sss
      COMMON /ffields_sss_b/ sssb
      COMMON /ffields_lambdathetaclimrelax/ lambdathetaclimrelax
      COMMON /ffields_lambdasaltclimrelax/ lambdasaltclimrelax
      COMMON /ffields_phitide/ phitide2d
      COMMON /ffields_pload/ pload
      COMMON /ffields_pload_b/ ploadb
      COMMON /ffields_siceload/ siceload
      COMMON /ffields_siceload_b/ siceloadb
C
      REAL*8 fu(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 fub(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 fv(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 fvb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 qnet(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 qnetb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 qsw(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 qswb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 empmr(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 empmrb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 saltflux(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 saltfluxb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 sst(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 sstb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 sss(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 sssb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 lambdathetaclimrelax(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy
     +       )
      REAL*8 lambdasaltclimrelax(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 phitide2d(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 pload(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 ploadb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 siceload(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 siceloadb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
C     gcmSST :: model in-situ Sea Surface Temperature (SST); corresponds to
C               surface-level model variable "theta", except if using TEOS-10 ;
C               in that case a conversion from model Conservative Temperature
C               "theta" is applied. Note: not defined under an ice-shelf
      COMMON /ffields_insitu_temp/ gcmsst
      COMMON /ffields_insitu_temp_b/ gcmsstb
      REAL*8 gcmsst(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 gcmsstb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
C
C     SWFrac3D :: fraction of solar short-wave flux penetrating the vertical
C                 cell interfaces (no units), function of depth of cell
C                 interface, potentially turbidity, cholorphyll concentration,
C                 or other biogeochemical material;
C                 the vertical dimension is Nr+1, because this makes it easier
C                 to maintain the symmetry w.r.t. z vs. p-coordinates.
      COMMON /ffields_swfrac/ swfrac3d
      REAL*8 swfrac3d(1-olx:snx+olx, 1-oly:sny+oly, nr+1, nsx, nsy)
C
C
C     loadedRec     :: time-record currently loaded (in temp arrays *[1])
C     taux[0,1]     :: Temp. for zonal wind stress
C     tauy[0,1]     :: Temp. for merid. wind stress
C     Qnet[0,1]     :: Temp. for heat flux
C     EmPmR[0,1]    :: Temp. for fresh water flux
C     saltFlux[0,1] :: Temp. for isurface salt flux
C     SST[0,1]      :: Temp. for theta climatalogy
C     SSS[0,1]      :: Temp. for theta climatalogy
C     Qsw[0,1]      :: Temp. for short wave component of heat flux
C     pLoad[0,1]    :: Temp. for atmospheric pressure at z=eta
C     [0,1]         :: End points for interpolation
C
      COMMON /ffields_i/ loadedrec
      INTEGER loadedrec(nsx, nsy)
C
      COMMON /tdfields/ taux0, tauy0, qnet0, empmr0, sst0, sss0, taux1, 
     +tauy1, qnet1, empmr1, sst1, sss1, saltflux0, saltflux1, qsw0, qsw1
     +, pload0, pload1
C
      REAL*8 taux0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 tauy0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 qnet0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 empmr0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 saltflux0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 sst0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 sss0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 taux1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 tauy1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 qnet1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 empmr1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 saltflux1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 sst1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 sss1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 qsw0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 qsw1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 pload0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 pload1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
C     surfaceForcingU     units are  r_unit.m/s^2 (=m^2/s^2 if r=z)
C                -> usage in gU:     gU = gU + surfaceForcingU/drF [m/s^2]
C     surfaceForcingV     units are  r_unit.m/s^2 (=m^2/s^-2 if r=z)
C                -> usage in gU:     gV = gV + surfaceForcingV/drF [m/s^2]
C
C     surfaceForcingS     units are  r_unit.g/kg/s (=g/kg.m/s if r=z)
C            - EmPmR * S_surf plus salinity relaxation*drF(1)
C                -> usage in gS:     gS = gS + surfaceForcingS/drF [g/kg/s]
C
C     surfaceForcingT     units are  r_unit.Kelvin/s (=Kelvin.m/s if r=z)
C            - Qnet (+Qsw) plus temp. relaxation*drF(1)
C                -> calculate        -lambda*(T(model)-T(clim))
C            Qnet assumed to be net heat flux including ShortWave rad.
C                -> usage in gT:     gT = gT + surfaceforcingT/drF [K/s]
C     adjustColdSST_diag :: diagnostic field for how much too cold (below
C              Tfreezing) SST has been adjusted (with allowFreezing=T).
C              > 0 for increase of SST (up to Tfreezing).
C              Units are r_unit.K/s (=Kelvin.m/s if r=z).
C        Note: 1) allowFreezing option is a crude hack to fix too cold SST that
C              results from missing seaice component. It should never be used
C              with any seaice component, neither current seaice pkg (pkg/seaice
C              or pkg/thsice) nor a seaice component from atmos model when
C              coupled to it.
C              2) this diagnostic is currently used by KPP package (kpp_calc.F
C              and kpp_transport_t.F) although it is not very clear it should.
C
      COMMON /surface_forcing/ surfaceforcingu, surfaceforcingv, 
     +surfaceforcingt, surfaceforcings, adjustcoldsst_diag
      COMMON /surface_forcing_b/ surfaceforcingub, surfaceforcingvb, 
     +surfaceforcingtb, surfaceforcingsb, adjustcoldsst_diagb
      REAL*8 surfaceforcingu(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 surfaceforcingub(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 surfaceforcingv(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 surfaceforcingvb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 surfaceforcingt(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 surfaceforcingtb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 surfaceforcings(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 surfaceforcingsb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 adjustcoldsst_diag(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 adjustcoldsst_diagb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
C     botDragU :: bottom stress (for diagnostics), Zonal component
C                Units are N/m^2 ;   > 0 increase uVel @ bottom
C     botDragV :: bottom stress (for diagnostics), Merid. component
C                Units are N/m^2 ;   > 0 increase vVel @ bottom
      COMMON /ffields_bottomstress/ botdragu, botdragv
      REAL*8 botdragu(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 botdragv(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
C---+----1----+----2----+----3----+----4----+----5----+----6----+----7-|--+----|
CBOP
C    !ROUTINE: EOS.h
C    !INTERFACE:
C    include EOS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | EOS.h
C     | o Header file defining coefficients for equation of state.
C     *==========================================================*
C     | The values from the model standard input file are
C     | stored into the variables held here.
C     *==========================================================*
C     \ev
CEOP
C
C     SItoBar  :: conversion factor for pressure, from Pa (SI Unit) to Bar
C     SItodBar :: conversion factor for pressure, from Pa (SI Unit) to deci Bar
      REAL*8 sitobar, sitodbar
      PARAMETER (sitobar=1.d-05)
      PARAMETER (sitodbar=1.d-04)
C
C Shared EOS Parameter
C     eosRefP0  :: reference atmospheric pressure used in EOS formulation
      COMMON /parm_eos_shared/ eosrefp0, equationofstate
      REAL*8 eosrefp0
      CHARACTER*6 equationofstate
C
C Linear equation of state
C     tAlpha    :: Linear EOS thermal expansion coefficient ( 1/degree ).
C     sBeta     :: Linear EOS haline contraction coefficient.
      COMMON /parm_eos_lin/ talpha, sbeta
      REAL*8 talpha
      REAL*8 sbeta
C
C Equation of State (polynomial coeffients)
      COMMON /parm_eos_poly3/ eosc, eossig0, eosreft, eosrefs
      REAL*8 eosc(9, nr+1), eossig0(nr+1), eosreft(nr+1), eosrefs(nr+1)
C
C Full Equation of State
C     eosType = 'JMD95' (Jackett and McDougall 1995, JAOT)
C     eosType = 'UNESCO' (Millero et al. 1980, DSR)
C     COMMON /PARM_EOS_JMD95/
C     eosJMDCFw  :: of fresh water at pressure 0
C     eosJMDCSw  :: of sea water at pressure 0
C     eosJMDCKFw :: of secant bulk modulus K of fresh water at pressure 0
C     eosJMDCKSw :: of secant bulk modulus K of sea water at pressure 0
C     eosJMDCKP  :: of secant bulk modulus K at pressure p
C     eosType = 'MDJWF' (McDougall et al. 2003, JAOT)
C     COMMON /PARM_EOS_MDJWF/
C     eosMDJWFnum :: coefficients of numerator
C     eosMDJWFden :: coefficients of denominator
C     eosType = 'TEOS10' (McDougall et al. 2011, http://www.teos-10.org)
C     Note: this eos implies that variables THETA and SALT are interpreted
C     as conservative temperature and absolute salinity
C     COMMON /PARM_TEOS10/
C     teos        :: 48 coeffiencts of numerator and denominator
C     end nonlinear equation of state
      REAL*8 eosjmdcfw(6), eosjmdcsw(9)
      REAL*8 eosjmdckfw(5), eosjmdcksw(7), eosjmdckp(14)
      COMMON /parm_eos_jmd95/ eosjmdcfw, eosjmdcsw, eosjmdckfw, 
     +eosjmdcksw, eosjmdckp
      REAL*8 eosmdjwfnum(0:11), eosmdjwfden(0:12)
      COMMON /parm_eos_mdjwf/ eosmdjwfnum, eosmdjwfden
C
C     TEOS10 coefficients
      REAL*8 teos(48)
C
C     Parameters in the temperature conversion code for TEOS10
C     The TEOS 10 conversion factor to go from reference salinity to
C     practical salinity (nondim)
      REAL*8 sprac_sref
C     The inverse of a plausible range of oceanic salinities (kg g-1)
      REAL*8 i_s0
C     The inverse of a plausible range of oceanic temperatures (degC-1)
      REAL*8 i_ts
C     The inverse of the "specific heat" for use
C     with Conservative Temperature, as defined with TEOS10 (degC kg J-1)
      REAL*8 i_cp0
C
C     The following are coefficients of contributions to conservative
C     temperature as a function of the square root of normalized
C     absolute salinity with an offset (zS) and potential temperature
C     (T) with a contribution Hab * zS**a * T**b.  The numbers here are
C     copied directly from the corresponding gsw module, but the
C     expressions here do not use the same nondimensionalization for
C     pressure or temperature as they do.
C
C     Tp to Tc fit constant (degC)
      REAL*8 h00
C     Tp to Tc fit T coef. (nondim)
      REAL*8 h01
C     Tp to Tc fit T**2 coef. (degC-1)
      REAL*8 h02
C     Tp to Tc fit T**3 coef. (degC-2)
      REAL*8 h03
C     Tp to Tc fit T**4 coef. (degC-3)
      REAL*8 h04
C     Tp to Tc fit T**5 coef. (degC-4)
      REAL*8 h05
C     Tp to Tc fit T**6 coef. (degC-5)
      REAL*8 h06
C     Tp to Tc fit T**7 coef. (degC-6)
      REAL*8 h07
C     Tp to Tc fit zS**2 coef. (degC)
      REAL*8 h20
C     Tp to Tc fit zS**2 * T coef. (nondim)
      REAL*8 h21
C     Tp to Tc fit zS**2 * T**2 coef. (degC-1)
      REAL*8 h22
C     Tp to Tc fit zS**2 * T**3 coef. (degC-2)
      REAL*8 h23
C     Tp to Tc fit zS**2 * T**4 coef. (degC-3)
      REAL*8 h24
C     Tp to Tc fit zS**2 * T**5 coef. (degC-4)
      REAL*8 h25
C     Tp to Tc fit zS**2 * T**6 coef. (degC-5)
      REAL*8 h26
C     Tp to Tc fit zS**3 coef. (degC)
      REAL*8 h30
C     Tp to Tc fit zS** 3* T coef. (nondim)
      REAL*8 h31
C     Tp to Tc fit zS**3 * T**2 coef. (degC-1)
      REAL*8 h32
C     Tp to Tc fit zS**3 * T**3 coef. (degC-2)
      REAL*8 h33
C     Tp to Tc fit zS**3 * T**4 coef. (degC-3)
      REAL*8 h34
C     Tp to Tc fit zS**4 coef. (degC)
      REAL*8 h40
C     Tp to Tc fit zS**4 * T coef. (nondim)
      REAL*8 h41
C     Tp to Tc fit zS**4 * T**2 coef. (degC-1)
      REAL*8 h42
C     Tp to Tc fit zS**4 * T**3 coef. (degC-2)
      REAL*8 h43
C     Tp to Tc fit zS**4 * T**4 coef. (degC-3)
      REAL*8 h44
C     Tp to Tc fit zS**4 * T**5 coef. (degC-4)
      REAL*8 h45
C     Tp to Tc fit zS**5 coef. (degC)
      REAL*8 h50
C     Tp to Tc fit zS**6 coef. (degC)
      REAL*8 h60
C     Tp to Tc fit zS**7 coef. (degC)
      REAL*8 h70
C
C     The following are coefficients in the nominator (TPNxx) or
C     denominator (TPDxx) of a simple rational expression that
C     approximately converts conservative temperature to potential
C     temperature.
C     Simple fit numerator constant (degC)
      REAL*8 tpn00
C     Simple fit numerator Sa coef. (degC ppt-1)
      REAL*8 tpn10
C     Simple fit numerator Sa**2 coef. (degC ppt-2)
      REAL*8 tpn20
C     Simple fit numerator Tc coef. (nondim)
      REAL*8 tpn01
C     Simple fit numerator Sa * Tc coef. (ppt-1)
      REAL*8 tpn11
C     Simple fit numerator Tc**2 coef. (degC-1)
      REAL*8 tpn02
C     Simple fit denominator Sa coef. (ppt-1)
      REAL*8 tpd10
C     Simple fit denominator Tc coef. (degC-1)
      REAL*8 tpd01
C     Simple fit denominator Tc**2 coef. (degC-2)
      REAL*8 tpd02
C
      COMMON /parm_teos10/ teos, sprac_sref, i_s0, i_ts, i_cp0, h00, h01
     +, h02, h03, h04, h05, h06, h07, h20, h21, h22, h23, h24, h25, h26
     +, h30, h31, h32, h33, h34, h40, h41, h42, h43, h44, h45, h50, h60
     +, h70, tpn00, tpn10, tpn20, tpn01, tpn11, tpn02, tpd10, tpd01, 
     +tpd02
      COMMON /autodiff_whtapeio_i/ tapefilecounter, tapemaxcounter, 
     +tapefileunit, tapefileunits
      INTEGER tapefilecounter, tapemaxcounter
      INTEGER tapefileunit, tapefileunits(4)
      COMMON /autodiff_whtapeio_l/ tapeconcatio, tapesinglecpuio, 
     +tapebufferio
      LOGICAL tapeconcatio, tapesinglecpuio, tapebufferio
C
C ad dump record number (used only if dumpAdByRec is true)
      INTEGER dumpadrecmn
      INTEGER dumpadrecdy
      INTEGER dumpadrecsi
      INTEGER dumpadrecet
      COMMON /autodiff_dump_ad_rec/ dumpadrecmn, dumpadrecdy, 
     +dumpadrecsi, dumpadrecet
C
CBOP
C !ROUTINE: GAD.h
C
C !INTERFACE:
C #include "GAD.h"
C
C !DESCRIPTION:
C Contains enumerated constants for distinguishing between different
C advection schemes and tracers.
C
C Unfortunately, there is no easy way to make use of the
C tokens in namelist input so for now we have to enter the
C tokens value into "data" (ie. 2 for 2nd order etc.)
C
C !USES:
C
C !DEFINED PARAMETERS:
C
C ENUM_UPWIND_1RST :: 1rst Order Upwind
      INTEGER enum_upwind_1rst
      PARAMETER (enum_upwind_1rst=1)
C
C ENUM_CENTERED_2ND :: Centered 2nd order
      INTEGER enum_centered_2nd
      PARAMETER (enum_centered_2nd=2)
C
C ENUM_UPWIND_3RD :: 3rd order upwind
      INTEGER enum_upwind_3rd
      PARAMETER (enum_upwind_3rd=3)
C
C ENUM_CENTERED_4TH :: Centered 4th order
      INTEGER enum_centered_4th
      PARAMETER (enum_centered_4th=4)
C
C ENUM_DST2 :: 2nd Order Direct Space and Time (= Lax-Wendroff)
      INTEGER enum_dst2
      PARAMETER (enum_dst2=20)
C
C ENUM_FLUX_LIMIT :: Non-linear flux limiter
      INTEGER enum_flux_limit
      PARAMETER (enum_flux_limit=77)
C
C ENUM_DST3 :: 3rd Order Direct Space and Time
      INTEGER enum_dst3
      PARAMETER (enum_dst3=30)
C
C ENUM_DST3_FLUX_LIMIT :: 3-DST flux limited
      INTEGER enum_dst3_flux_limit
      PARAMETER (enum_dst3_flux_limit=33)
C
C ENUM_OS7MP :: 7th Order One Step method with Monotonicity Preserving Limiter
      INTEGER enum_os7mp
      PARAMETER (enum_os7mp=7)
C
C ENUM_SOM_PRATHER :: 2nd Order-Moment Advection Scheme, Prather, 1986
      INTEGER enum_som_prather
      PARAMETER (enum_som_prather=80)
C
C ENUM_SOM_LIMITER :: 2nd Order-Moment Advection Scheme, Prather Limiter
      INTEGER enum_som_limiter
      PARAMETER (enum_som_limiter=81)
C
C ENUM_PPM_NULL :: piecewise parabolic method with "null" limiter
      INTEGER enum_ppm_null_limit
      PARAMETER (enum_ppm_null_limit=40)
C
C ENUM_PPM_MONO :: piecewise parabolic method with "mono" limiter
      INTEGER enum_ppm_mono_limit
      PARAMETER (enum_ppm_mono_limit=41)
C
C ENUM_PPM_WENO :: piecewise parabolic method with "weno" limiter
      INTEGER enum_ppm_weno_limit
      PARAMETER (enum_ppm_weno_limit=42)
C
C ENUM_PQM_NULL :: piecewise quartic method with "null" limiter
      INTEGER enum_pqm_null_limit
      PARAMETER (enum_pqm_null_limit=50)
C
C ENUM_PQM_MONO :: piecewise quartic method with "mono" limiter
      INTEGER enum_pqm_mono_limit
      PARAMETER (enum_pqm_mono_limit=51)
C
C ENUM_PQM_WENO :: piecewise quartic method with "weno" limiter
      INTEGER enum_pqm_weno_limit
      PARAMETER (enum_pqm_weno_limit=52)
C
C GAD_Scheme_MaxNum :: maximum possible number for an advection scheme
      INTEGER gad_scheme_maxnum
      PARAMETER (gad_scheme_maxnum=100)
C
C nSOM :: number of 1rst & 2nd Order-Moments: 1+1 (1D), 2+3 (2D), 3+6 (3D)
      INTEGER nsom
      PARAMETER (nsom=3+6)
C
C oneSixth :: Third/fourth order interpolation factor
      REAL*8 onesixth
      PARAMETER (onesixth=1.d0/6.d0)
C
C loop range for computing vertical advection tendency
C  iMinAdvR,iMaxAdvR  :: 1rst index (X-dir) loop range for vertical advection
C  jMinAdvR,jMaxAdvR  :: 2nd  index (Y-dir) loop range for vertical advection
      INTEGER iminadvr, imaxadvr, jminadvr, jmaxadvr
      PARAMETER (iminadvr=1, imaxadvr=snx)
      PARAMETER (jminadvr=1, jmaxadvr=sny)
C
C Differentiate between tracers (needed for KPP - arrgh!!!)
Cph                              and GMRedi arrgh*arrgh!!!)
Cph  indices are used for TAF key computations, so need to
Cph  running from 1, 2, ...
C
C GAD_TEMPERATURE :: temperature
      INTEGER gad_temperature
      PARAMETER (gad_temperature=1)
C GAD_SALINITY :: salinity
      INTEGER gad_salinity
      PARAMETER (gad_salinity=2)
C GAD_TR1 :: passive tracer 1
      INTEGER gad_tr1
      PARAMETER (gad_tr1=3)
CEOP
C
C--   COMMON /GAD_PARM_C/ Character parameters for GAD pkg routines
C      somSfx       :: 1rst & 2nd Order moment suffix
      CHARACTER*2 somsfx(nsom)
      COMMON /gad_parm_c/ somsfx
C
C--   COMMON /GAD_PARM_I/ Integer parameters for GAD pkg routines
C GAD_OlMinSize     :: overlap minimum size for GAD routines
C           1: min required; 2: to add to current min; 3: factor to apply
      INTEGER gad_olminsize(3)
      COMMON /gad_parm_i/ gad_olminsize
C
C--   COMMON /GAD_PARM_L/ Logical parameters for GAD pkg routines
C tempSOM_Advection :: set to T if using 2nd-Order Moment advection for Temp
C saltSOM_Advection :: set to T if using 2nd-Order Moment advection for Salt
C tempMultiDimAdvec :: set to T if using multi-dim advection for Temp
C saltMultiDimAdvec :: set to T if using multi-dim advection for Salt
C AdamsBashforthGt  :: apply Adams-Bashforth extrapolation on T tendency (=Gt)
C AdamsBashforthGs  :: apply Adams-Bashforth extrapolation on S tendency (=Gs)
C AdamsBashforth_T  :: apply Adams-Bashforth extrapolation on Pot.Temp.
C AdamsBashforth_S  :: apply Adams-Bashforth extrapolation on Salinity
      LOGICAL tempsom_advection
      LOGICAL saltsom_advection
      LOGICAL tempmultidimadvec
      LOGICAL saltmultidimadvec
      LOGICAL adamsbashforthgt
      LOGICAL adamsbashforthgs
      LOGICAL adamsbashforth_t
      LOGICAL adamsbashforth_s
      COMMON /gad_parm_l/ tempsom_advection, saltsom_advection, 
     +tempmultidimadvec, saltmultidimadvec, adamsbashforthgt, 
     +adamsbashforthgs, adamsbashforth_t, adamsbashforth_s
C
      REAL*8 smolarkiewiczmaxfrac
      COMMON /gad_smol/ smolarkiewiczmaxfrac
C
CEH3 ;;; Local Variables: ***
CEH3 ;;; mode:fortran ***
CEH3 ;;; End: ***
CBOP
C     !ROUTINE: GAD_SOM_VARS.h
C     !INTERFACE:
C     include "GAD_SOM_VARS.h"
C     !DESCRIPTION:
C     \bv
C     *==========================================================*
C     | GAD_SOM_VARS.h
C     | o state variables for 2nd Order-Moment Advection
C     *==========================================================*
C     | Storage needed for Temperature and Salinity when using
C     | 2nd Order-Moment (SOM) Advection
C     *==========================================================*
C     \ev
CEOP
C
C
CBOP
C     !ROUTINE: MOM_FLUXFORM.h
C     !INTERFACE:
C     #include MOM_FLUXFORM.h
C     !DESCRIPTION:
C     Header file for pkg mom_fluxform subroutines
CEOP
C
C--   COMMON /LOCAL_MOM_CALC_RTRANS/
C       was part of mom_calc_rtrans.F, and moved later
C       to a separated header file for the adjoint.
C     == Local variables in common block ==
C     dWtransC :: vertical transp. difference between r & r* coordinates
C     dWtransU :: same but above u.point location (West  face)
C     dWtransV :: same but above v.point location (South face)
      COMMON /local_mom_calc_rtrans/ dwtransc, dwtransu, dwtransv
      COMMON /local_mom_calc_rtrans_b/ dwtranscb, dwtransub, dwtransvb
      REAL*8 dwtransc(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 dwtranscb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 dwtransu(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 dwtransub(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 dwtransv(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 dwtransvb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
C     uVelD  :: D grid zonal velocity
C     vVelD  :: D grid meridional velocity
C
      COMMON /dynvars_cd/ uveld, vveld, etanm1, unm1, vnm1
      COMMON /dynvars_cd_b/ uveldb, vveldb, etanm1b, unm1b, vnm1b
      REAL*8 uveld(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 uveldb(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 vveld(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 vveldb(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 etanm1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 etanm1b(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 unm1(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 unm1b(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 vnm1(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 vnm1b(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
C
C
CBOP
C    !ROUTINE: PTRACERS_SIZE.h
C    !INTERFACE:
C #include PTRACERS_SIZE.h
C
C    !DESCRIPTION:
C Contains passive tracer array size (number of tracers).
C
C PTRACERS_num defines how many passive tracers are allocated/exist.
C  and is set here (default 1)
C
C     Number of tracers
      INTEGER ptracers_num
      PARAMETER (ptracers_num=1)
C
C
CEOP
C
CEH3 ;;; Local Variables: ***
CEH3 ;;; mode:fortran ***
CEH3 ;;; End: ***
C
CBOP
C    !ROUTINE: PTRACERS_FIELDS.h
C    !INTERFACE:
C #include PTRACERS_FIELDS.h
C
C    !DESCRIPTION:
C Contains passive tracer fields
C
CEOP
C
C     COMMON /PTRACERS_FIELDS/
C     pTracer  :: passive tracer concentration (tr per unit volume).
C     gpTrNm1  :: work-space for time-stepping
C     surfaceForcingPTr :: passive tracer surface forcing
      REAL*8 ptracer(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy, 
     +       ptracers_num)
      REAL*8 ptracerb(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy, 
     +       ptracers_num)
      REAL*8 gptrnm1(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy, 
     +       ptracers_num)
      REAL*8 surfaceforcingptr(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy, 
     +       ptracers_num)
      REAL*8 surfaceforcingptrb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy, 
     +       ptracers_num)
      COMMON /ptracers_fields/ ptracer, gptrnm1, surfaceforcingptr
      COMMON /ptracers_fields_b/ ptracerb, surfaceforcingptrb
C
      REAL*8 totsurfcorptr(ptracers_num)
      REAL*8 meansurfcorptr(ptracers_num)
      COMMON /ptracers_surfcor_fields/ totsurfcorptr, meansurfcorptr
C
C
CEH3 ;;; Local Variables: ***
CEH3 ;;; mode:fortran ***
CEH3 ;;; End: ***
CBOP
C     !ROUTINE: PTRACERS_START.h
C     !INTERFACE:
C     include "PTRACERS_START.h"
C
C     !DESCRIPTION:
C     \bv
C     *==========================================================*
C     | PTRACERS_START.h
C     | o Holds passive-tracer internal parameters related
C     |   to start and restart process
C     *==========================================================*
C     | Passive-tracer internal parameters/variables related to
C     | a) which tracer is stepped forward
C     | b) writing or reading pickup for a restart.
C     | Note:
C     |  external parameters (read from parameter file "data.ptracers")
C     |  stay in PTRACERS_PARAMS.h and should not appear here ;
C     |  therefore, this header file should not be included
C     |  in S/R PTRACERS_READPARMS.
C     *==========================================================*
C     \ev
CEOP
C
C--   COMMON / PTRACERS_START_I / Integer valued parameters used for (re)start
C     PTRACERS_StartAB  :: number of gPtr previous time levels that are
C                      available to start (or restart) Adams-Bashforth
      COMMON /ptracers_start_i/ ptracers_startab
      INTEGER ptracers_startab(ptracers_num)
C
C--   COMMON / PTRACERS_START_L / Logical valued parameters used for (re)start
C     PTRACERS_StepFwd  :: switch on/off this tracer time-stepping
      COMMON /ptracers_start_l/ ptracers_stepfwd
      LOGICAL ptracers_stepfwd(ptracers_num)
C
C
C
C     ==================================================================
C     HEADER exf_constants
C     ==================================================================
C
C     o Header file for constants.
C       These include  - numbers (e.g. 1, 2, 1/2, ...)
C                      - physical constants (e.g. gravitational const.)
C                      - empirical parameters
C                      - control parameters (e.g. max. no of iteration)
C
C     started: Patrick Heimbach heimbach@mit.edu  06-May-2000
C     mods for pkg/seaice: menemenlis@jpl.nasa.gov 20-Dec-2002
C
C     ==================================================================
C     HEADER exf_constants
C     ==================================================================
C
C     1. numbers
C
C     exf_half   0.5
C     exf_one    1.0
C     exf_two    2.0
C
      REAL*8 exf_half
      REAL*8 exf_one
      REAL*8 exf_two
      PARAMETER (exf_half=0.5d0, exf_one=1.0d0, exf_two=2.0d0)
C
C     real       exf_undef
C     PARAMETER( exf_undef = -9000. )
C
C     2. physical constants
C
C     stefanBoltzmann :: Stefan-Boltzmann constant [J*K^-4*m^-2*s^-1]
C                        sigma = (2*pi^5*k^4)/(15*h^3*c^2)
C     karman          :: von Karman constant
      REAL*8 stefanboltzmann
      REAL*8 karman
      PARAMETER (stefanboltzmann=5.670d-8)
      PARAMETER (karman=0.4d0)
C
C     3. empirical parameters
C
C     To invert the relationship ustar = ustar(umagn) the following
C     parameterization is used:
C
C      ustar**2 = umagn**2 * CDN(umagn)
C
C                  / cquadrag_1 * umagn**2 + cquadrag_2; 0 < u < 11 m/s
C      CDN(umagn) =
C                  \ clindrag_1 * umagn + clindrag_2   ; u > 11 m/s
C
C      clindrag_[n] - n = 1, 2 coefficients used to evaluate
C                     LINEAR relationship of Large and Pond 1981
C      cquadrag_[n] - n = 1, 2 coefficients used to evaluate
C                     quadratic relationship
C      u11          - u = 11 m/s wind speed
C      ustofu11     - ustar = 0.3818 m/s, corresponding to u = 11 m/s
C
      REAL*8 clindrag_1, clindrag_2
      REAL*8 cquadrag_1, cquadrag_2
      REAL*8 u11
      REAL*8 ustofu11
      PARAMETER (ustofu11=0.381800d0, u11=11.d0, clindrag_1=0.000065d0, 
     +   clindrag_2=0.000490d0, cquadrag_1=clindrag_1/u11/2, cquadrag_2=
     +   clindrag_1*u11/2+clindrag_2)
C
C     4. control parameters
C
C     niter_bulk   - Number of iterations to be performed for the
C                    evaluation of the bulk surface fluxes. The ncom
C                    model uses 2 hardwired interation steps (loop
C                    unrolled).
C
      INTEGER niter_bulk
      PARAMETER (niter_bulk=2)
C
C     5. other constants or parameters
C
C     COMMON /EXF_PARAM_R_2/
C     cen2kel      :: conversion of deg. Centigrade to Kelvin
C     gravity_mks  :: gravitational acceleration [m/s^2]
C     atmrho       :: mean atmospheric density [kg/m^3]
C     atmcp        :: mean atmospheric specific heat [J/kg/K]
C     flamb        :: latent heat of evaporation [J/kg]
C     flami        :: latent heat of melting of pure ice [J/kg]
C     cvapor_[]    :: Coeff to calculate Saturation Specific Humidity
C                     see e.g. Gill (1982) p.41 Eq. (3.1.15)
C     humid_fac    :: constant entering the evaluation of the virtual
C                     temperature
C     gamma_blk    :: adiabatic lapse rate
C     saltsat      :: reduction of saturation vapor pressure over salt water
C     sstExtrapol  :: extrapolation coeff from 1rst 2 levels up to surface
C  snow_emissivity :: longwave  snow  emissivity [-] (with pkg thsice/seaice)
C-- to evaluate turbulent transfert coefficients:
C     cdrag_[n]    :: n = 1,2,3 coefficients used to evaluate
C                     drag coefficient,
C     For Large and Yeager (2009): extra coefficient n = 8 and
C     cdragMax     :: maximum drag coefficient ...
C     umax         :: ... at maximum wind
C     cstanton_[n] :: n = 1,2   coefficients used to evaluate
C                     the Stanton number (stable/unstable cond.)
C     cdalton      :: coefficient used to evaluate the Dalton number
C     zolmin       :: minimum stability parameter
C     psim_fac     :: coef used in turbulent fluxes calculation [-]
C     zref         :: reference height
C     hu           :: height of mean wind
C     ht           :: height of mean temperature
C     hq           :: height of mean rel. humidity
C     umin         :: minimum absolute wind speed used to evaluate
C                     drag coefficient [m/s]
C     exf_iceCd    :: drag coefficient over sea-ice (fixed)
C     exf_iceCe    :: transfert coeff. over sea-ice, for Evaporation (fixed)
C     exf_iceCh    :: transfert coeff. over sea-ice, for Sens.Heating (fixed)
C-- radiation:
C     exf_albedo   :: Sea-water albedo
C ocean_emissivity :: longwave ocean-surface emissivity [-]
C   ice_emissivity :: longwave seaice emissivity [-] (with pkg thsice/seaice)
C  snow_emissivity :: longwave  snow  emissivity [-] (with pkg thsice/seaice)
C
      REAL*8 cen2kel
      REAL*8 gravity_mks
      REAL*8 atmrho
      REAL*8 atmcp
      REAL*8 flamb, flami
      REAL*8 cvapor_fac, cvapor_exp
      REAL*8 cvapor_fac_ice, cvapor_exp_ice
      REAL*8 humid_fac
      REAL*8 gamma_blk
      REAL*8 saltsat
      REAL*8 sstextrapol
      REAL*8 cdrag_1, cdrag_2, cdrag_3, cdrag_8, cdragmax, umax
      REAL*8 cstanton_1, cstanton_2
      REAL*8 cdalton
      REAL*8 zolmin
      REAL*8 psim_fac
      REAL*8 zref
      REAL*8 hu
      REAL*8 ht
      REAL*8 hq
      REAL*8 umin
      REAL*8 exf_icecd
      REAL*8 exf_icece
      REAL*8 exf_icech
      REAL*8 exf_albedo
      REAL*8 ocean_emissivity
      REAL*8 ice_emissivity
      REAL*8 snow_emissivity
C
      COMMON /exf_param_r_2/ cen2kel, gravity_mks, atmrho, atmcp, flamb
     +, flami, cvapor_fac, cvapor_exp, cvapor_fac_ice, cvapor_exp_ice, 
     +humid_fac, gamma_blk, saltsat, sstextrapol, cdrag_1, cdrag_2, 
     +cdrag_3, cdrag_8, cdragmax, umax, cstanton_1, cstanton_2, cdalton
     +, zolmin, psim_fac, zref, hu, ht, hq, umin, exf_icecd, exf_icece, 
     +exf_icech, exf_albedo, ocean_emissivity, ice_emissivity, 
     +snow_emissivity
CBOP
C    !ROUTINE: EXF_INTERP_SIZE.h
C    !INTERFACE:
C #include EXF_INTERP_SIZE.h
C
C     ==================================================================
C     HEADER EXF_INTERP_SIZE.h
C     ==================================================================
C
C    !DESCRIPTION:
C   Contains maximum size of original input grid from which interpolation
C    to model grid is done.
C-  Note: This header file needs to be included before EXF_INTERP_PARAM.h
C    since it uses MAX_LAT_INC which is defined here.
CEOP
C
C
C-- Set dummy dimension
      INTEGER max_lat_inc
      INTEGER exf_max_nlon, exf_max_nlat
      INTEGER exf_interp_buffersize
      PARAMETER (max_lat_inc=1)
      PARAMETER (exf_max_nlon=1)
      PARAMETER (exf_max_nlat=1)
      PARAMETER (exf_interp_buffersize=1)
C
C     ==================================================================
C     HEADER exf_fields
C     ==================================================================
C
C     o Header file for the surface flux data.
C
C     started: Ralf.Giering@FastOpt.de 25-Mai-2000
C     changed: field swap in adj. mode; heimbach@mit.edu 10-Jan-2002
C     included runoff D. Stammer, Nov. 25, 2001
C     mods for pkg/seaice: menemenlis@jpl.nasa.gov 20-Dec-2002
C
C     ==================================================================
C     HEADER exf_fields
C     ==================================================================
C
C     Field definitions, units, and sign conventions:
C     ===============================================
C
C     ustress   :: Zonal surface wind stress in N/m^2
C                  > 0 for increase in uVel, which is west to
C                      east for cartesian and spherical polar grids
C                  Typical range: -0.5 < ustress < 0.5
C                  Input field
C
C     vstress   :: Meridional surface wind stress in N/m^2
C                  > 0 for increase in vVel, which is south to
C                      north for cartesian and spherical polar grids
C                  Typical range: -0.5 < vstress < 0.5
C                  Input field
C
C     hflux     :: Net upward surface heat flux including shortwave in W/m^2
C                  hflux = latent + sensible + lwflux + swflux
C                  > 0 for decrease in theta (ocean cooling)
C                  Typical range: -250 < hflux < 600
C                  Input field
C
C     sflux     :: Net upward freshwater flux in m/s
C                  sflux = evap - precip - runoff
C                  > 0 for increase in salt (ocean salinity)
C                  Typical range: -1e-7 < sflux < 1e-7
C                  Input field
C
C     swflux    :: Net upward shortwave radiation in W/m^2
C                  swflux = - ( swdown - ice and snow absorption - reflected )
C                  > 0 for decrease in theta (ocean cooling)
C                  Typical range: -350 < swflux < 0
C                  Input field
C
C     uwind     :: Surface (10-m) zonal wind velocity in m/s
C                  > 0 for increase in uVel, which is west to
C                      east for cartesian and spherical polar grids
C                  Typical range: -10 < uwind < 10
C                  Input or input/output field
C
C     vwind     :: Surface (10-m) meridional wind velocity in m/s
C                  > 0 for increase in vVel, which is south to
C                      north for cartesian and spherical polar grids
C                  Typical range: -10 < vwind < 10
C                  Input or input/output field
C
C     wspeed    :: Surface (10-m) wind speed in m/s
C                  >= 0 sqrt(u^2+v^2)
C                  Typical range: 0 < wspeed < 10
C                  Input or input/output field
C
C     atemp     :: Surface (2-m) air temperature in deg K
C                  Typical range: 200 < atemp < 300
C                  Input or input/output field
C
C     aqh       :: Surface (2m) specific humidity in kg/kg
C                  Typical range: 0 < aqh < 0.02
C                  Input or input/output field
C
C     hs        :: sensible heat flux into ocean in W/m^2
C                  > 0 for increase in theta (ocean warming)
C
C     hl        :: latent   heat flux into ocean in W/m^2
C                  > 0 for increase in theta (ocean warming)
C
C     lwflux    :: Net upward longwave radiation in W/m^2
C                  lwflux = - ( lwdown - ice and snow absorption - emitted )
C                  > 0 for decrease in theta (ocean cooling)
C                  Typical range: -20 < lwflux < 170
C                  Input field
C
C     evap      :: Evaporation in m/s
C                  > 0 for increase in salt (ocean salinity)
C                  Typical range: 0 < evap < 2.5e-7
C                  Input, input/output, or output field
C
C     precip    :: Total Precipitation (rain+snow) in m/s of liquid water
C                  > 0 for decrease in salt (ocean salinity)
C                  Typical range: 0 < precip < 5e-7
C                  Input or input/output field
C
C     snowprecip :: snow precipitation in m/s of equivalent liquid water
C                  > 0 for decrease in salt (ocean salinity)
C                  Typical range: 0 < precip < 5e-7
C                  Input or input/output field
C
C     runoff    :: River and glacier runoff in m/s
C                  > 0 for decrease in salt (ocean salinity)
C                  Typical range: 0 < runoff < ????
C                  Input or input/output field
C
C     runoftemp :: Temperature of runoff in deg C
C
C     saltflx   :: Net upward salt flux in (g/kg).kg/m^2/s = g/m^2/s
C                  > 0 for decrease in SSS.
C                  Typical origin: salty sea-ice formation / melting.
C
C     swdown    :: Downward shortwave radiation in W/m^2
C                  > 0 for increase in theta (ocean warming)
C                  Typical range: 0 < swdown < 450
C                  Input/output field
C
C     lwdown    :: Downward longwave radiation in W/m^2
C                  > 0 for increase in theta (ocean warming)
C                  Typical range: 50 < lwdown < 450
C                  Input/output field
C
C     apressure :: Atmospheric surface pressure field in Pa
C                  Typical range: 88000 < apressure < 108000
C                  Input field
C
C     tidePot   :: Tidal geopotential forcing in m^2/s^2
C                  Typical range: -10 < tidePot < +10
C                  Input field
C
C     NOTES:
C     ======
C
C     By default all surface forcing fields are defined at the center
C     of each grid (the rVel location in model/inc/GRID.h) unless
C     flags readStressOnAgrid or readStressOnCgrid are set.
C
C     Input and output units and sign conventions can be customized
C     using variables exf_inscal_* and exf_outscal_*, which are set
C     by exf_readparms.F
C
C     Output fields fu, fv, Qnet, Qsw, and EmPmR are
C     defined in FFIELDS.h
C
C     Arrays *0 and *1 below are used for temporal interpolation.
C
C
      COMMON /exf_stress_r/ ustress, vstress
      COMMON /exf_stress_r_b/ ustressb, vstressb
      REAL*8 ustress(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 ustressb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 vstress(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 vstressb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      COMMON /exfl_ustress_r/ ustress0, ustress1
      REAL*8 ustress0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 ustress1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      COMMON /exfl_vstress_r/ vstress0, vstress1
      REAL*8 vstress0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 vstress1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
      COMMON /exf_wspeed_r/ wspeed
      COMMON /exf_wspeed_r_b/ wspeedb
      REAL*8 wspeed(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 wspeedb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      COMMON /exfl_wspeed_r/ wspeed0, wspeed1
      REAL*8 wspeed0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 wspeed1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
      COMMON /exf_atm_wind_r/ uwind, vwind
      COMMON /exf_atm_wind_r_b/ uwindb, vwindb
      REAL*8 uwind(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 uwindb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 vwind(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 vwindb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      COMMON /exfl_uwind_r/ uwind0, uwind1
      REAL*8 uwind0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 uwind1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      COMMON /exfl_vwind_r/ vwind0, vwind1
      REAL*8 vwind0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 vwind1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
      COMMON /exf_netflux_r/ hflux, sflux
      COMMON /exf_netflux_r_b/ hfluxb, sfluxb
      REAL*8 hflux(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 hfluxb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 sflux(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 sfluxb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      COMMON /exfl_hflux_r/ hflux0, hflux1
      REAL*8 hflux0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 hflux1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      COMMON /exfl_sflux_r/ sflux0, sflux1
      REAL*8 sflux0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 sflux1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
      COMMON /exf_atm_temp_r/ atemp, aqh, hs, hl, lwflux, evap, precip, 
     +snowprecip
      COMMON /exf_atm_temp_r_b/ atempb, aqhb, hsb, hlb, lwfluxb, evapb, 
     +precipb, snowprecipb
      REAL*8 atemp(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 atempb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 aqh(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 aqhb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 hs(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 hsb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 hl(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 hlb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 lwflux(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 lwfluxb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 evap(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 evapb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 precip(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 precipb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 snowprecip(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 snowprecipb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      COMMON /exfl_atemp_r/ atemp0, atemp1
      REAL*8 atemp0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 atemp1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      COMMON /exfl_aqh_r/ aqh0, aqh1
      REAL*8 aqh0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 aqh1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      COMMON /exfl_lwflux_r/ lwflux0, lwflux1
      REAL*8 lwflux0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 lwflux1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      COMMON /exfl_precip_r/ precip0, precip1
      REAL*8 precip0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 precip1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      COMMON /exfl_snowprecip_r/ snowprecip0, snowprecip1
      REAL*8 snowprecip0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 snowprecip1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
C     wStress   :: wind-stress magnitude [Pa=N/m^2], @ grid-cell center
C     sh        :: wind-speed [m/s] (always larger than uMin)
      COMMON /exfl_wind_r/ wstress, cw, sw, sh
      COMMON /exfl_wind_r_b/ wstressb, cwb, swb, shb
      REAL*8 wstress(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 wstressb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 cw(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 cwb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 sw(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 swb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 sh(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 shb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
      COMMON /exf_swflux_r/ swflux
      COMMON /exf_swflux_r_b/ swfluxb
      REAL*8 swflux(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 swfluxb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      COMMON /exfl_swflux_r/ swflux0, swflux1
      REAL*8 swflux0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 swflux1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
      COMMON /exf_rad_down_r/ swdown, lwdown
      COMMON /exf_rad_down_r_b/ swdownb, lwdownb
      REAL*8 swdown(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 swdownb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 lwdown(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 lwdownb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      COMMON /exfl_rad_down_r/ swdown0, swdown1, lwdown0, lwdown1
      REAL*8 swdown0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 swdown1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 lwdown0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 lwdown1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
      COMMON /exf_apressure_r/ apressure, apressure0, apressure1
      COMMON /exf_apressure_r_b/ apressureb
      REAL*8 apressure(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 apressureb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 apressure0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 apressure1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
      COMMON /exfl_runoff_r/ runoff, runoff0, runoff1
      COMMON /exfl_runoff_r_b/ runoffb
      REAL*8 runoff(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 runoffb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 runoff0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 runoff1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
C
      COMMON /exfl_saltflx_r/ saltflx, saltflx0, saltflx1
      REAL*8 saltflx(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 saltflx0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 saltflx1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
C
C
      COMMON /exf_clim_sst_r/ climsst, climsst0, climsst1
      REAL*8 climsst(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 climsst0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 climsst1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
      COMMON /exf_clim_sss_r/ climsss, climsss0, climsss1
      REAL*8 climsss(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 climsss0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 climsss1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
C
CBOP
C    !ROUTINE: SEAICE_SIZE.h
C    !INTERFACE:
C #include SEAICE_SIZE.h
C
C    !DESCRIPTION:
C Contains seaice array-size definition (number of tracers,categories).
C
C SItrMaxNum :: number of passive tracers to allocate
C nITD       :: number of seaice categories to allocate
CEOP
C
C-    Maximum Number of categories
      INTEGER nitd
      PARAMETER (nitd=7)
C
C-    Maximum Number of tracers
      INTEGER sitrmaxnum
      PARAMETER (sitrmaxnum=3)
C
      INTEGER nevpstepmax
      PARAMETER (nevpstepmax=180)
      INTEGER nmax_tice
      PARAMETER (nmax_tice=10)
      INTEGER solv_max_fixed
      PARAMETER (solv_max_fixed=500)
      INTEGER mpseudotimesteps
      PARAMETER (mpseudotimesteps=2)
C
C
CEH3 ;;; Local Variables: ***
CEH3 ;;; mode:fortran ***
CEH3 ;;; End: ***
CBOP
C !ROUTINE: SEAICE.h
C
C !DESCRIPTION: \bv
C     *==========================================================*
C     | SEAICE.h
C     | o Basic header for sea ice model.
C     |   Contains most sea ice field declarations.
C     *==========================================================*
C
C     UICE  :: zonal ice velocity in m/s at South-West B-grid
C              (or C-grid #ifdef ) U point
C              >0 from West to East
C     VICE  :: meridional ice velocity in m/s at South-West B-grid
C              (or C-grid #ifdef ) V point
C              >0 from South to North
C              note: the South-West B-grid U and V points are on
C                the lower, left-hand corner of each grid cell
C     AREA  :: fractional ice-covered area in m^2/m^2
C              at center of grid, i.e., tracer point
C              0 is no cover, 1 is 100% cover
C     HEFF  :: effective ice thickness in m
C              at center of grid, i.e., tracer point
C              note: for non-zero AREA, actual ice thickness is HEFF / AREA
C     HSNOW :: effective snow thickness in m
C              at center of grid, i.e., tracer point
C              note: for non-zero AREA, actual snow thickness is HSNOW / AREA
C \ev
CEOP
C
C--   Grid variables for seaice
C     static masks (depend only on geometry)
C     HEFFM     :: land-sea mask at C-points (copy of maskC(k=kSrf))
C     SIMaskU/V :: land-sea mask at U/V-points (copies of maskW/S(k=kSrf))
      COMMON /array/ heffm, simasku, simaskv
      REAL*8 heffm(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 simasku(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 simaskv(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
      COMMON /arraymetric/ k1atc, k2atc
      REAL*8 k1atc(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 k2atc(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
      COMMON /arrayc/ seaicemasku, seaicemaskv
C     dynamic masks (depend on area)
      REAL*8 seaicemasku(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 seaicemaskv(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C     k1/2AtZ :: coefficients at C and Z points
C     k1/2AtC    for metric terms in U/V ice equations.
      COMMON /arraycmetric/ k1atz, k2atz
      REAL*8 k1atz(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 k2atz(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
C
C--   Dynamical variables
      COMMON /seaice_dynvars_1/ area, heff, hsnow, uice, vice
      COMMON /seaice_dynvars_1_b/ areab, heffb, hsnowb
      REAL*8 area(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 areab(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 heff(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 heffb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 hsnow(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 hsnowb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 uice(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 vice(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C     DWATN         :: (linear) ice-ocean drag coefficient
C                      ( units of [rho|u|] = kg/m^2/s )
C     u/vIceNm1     :: sea ice drift velocities of previous timestep (m/s)
      COMMON /seaice_dynvars_2/ dwatn, uicenm1, vicenm1
      REAL*8 dwatn(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 uicenm1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 vicenm1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
C
C     stressDivergenceX/Y :: div of (vert. integr.) stress tensor (N/m^2)
      COMMON /seaice_stressdiv/ stressdivergencex, stressdivergencey
      REAL*8 stressdivergencex(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 stressdivergencey(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C--   Additional fields needed by the EVP solver:
C     (vertically integrated) stress tensor, with diagonal terms sigma11/22
C     seaice_sigma1  :: sigma11+sigma22, defined at C-points   (N/m)
C     seaice_sigma2  :: sigma11-sigma22, defined at C-points   (N/m)
C     seaice_sigma12 :: off-diagonal term, defined at Z-points (N/m)
      COMMON /seaice_evp_fields/ seaice_sigma1, seaice_sigma2, 
     +seaice_sigma12
      REAL*8 seaice_sigma1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 seaice_sigma2(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 seaice_sigma12(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
C     ETA,  etaZ    :: shear viscosity as C-points, at Z-points (N s/m = kg/s)
C     ZETA, zetaA   :: bulk viscosity at C-points, at Z-points
C     PRESS         :: maximum vertically integrated ice strength/pressure (N/m)
C     e11, e22, e12 :: components strain rate tensor (1/s)
C     deltaC        :: deformation rate tensor invariant, for VP sea ice
C                      = sqrt( (e11+e22)**2 + (1/e)*(e11-e22)**2 + 4*e12**2) )
C     FORCEX/Y      :: momentum forcing
C                      ( units of [rho * h * u / deltaT] = kg/m/s^2 )
C     tensileStrFac :: factor k to compute the maximal tensile stress k*PRESS0
      COMMON /seaice_dynvars_3/ eta, etaz, zeta, zetaz, press, 
     +tensilestrfac, e11, e22, e12, deltac, forcex, forcey
C
      REAL*8 eta(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 etaz(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 zeta(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 zetaz(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C     ice strength/pressure term
      REAL*8 press(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 tensilestrfac(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C     strain rate tensor
      REAL*8 e11(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 e22(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 e12(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 deltac(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
      REAL*8 forcex(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 forcey(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
C     PRESS0        :: maximal compressive stress/strength (N/m)
C     FORCEX/Y0     :: external momentum forcing fields (part of FORCEX/Y)
C     SEAICE_zMax/zMin :: maximum/minimum bulk viscosities
      COMMON /seaice_dynvars_4/ press0, forcex0, forcey0, seaice_zmax, 
     +seaice_zmin
      REAL*8 press0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 forcex0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 forcey0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 seaice_zmax(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 seaice_zmin(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
C     seaiceMassC/U/V :: mass (ice+snow) at C/U/V-points ( kg/m^2 )
      COMMON /seaice_dynvars_cgrid/ seaicemassc, seaicemassu, 
     +seaicemassv
      REAL*8 seaicemassc(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 seaicemassu(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 seaicemassv(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
C
C
C     diagnostics for the JFNK and Krylov solver
      INTEGER totalnewtoniters
      INTEGER totalnewtonfails
      INTEGER totalkryloviters
      INTEGER totalkrylovfails
      INTEGER totaljfnktimesteps
      COMMON /seaice_solver_i/ totalnewtoniters, totalnewtonfails, 
     +totalkryloviters, totalkrylovfails, totaljfnktimesteps
C     Scalar product used in FGMRES needs a metric
      INTEGER nvec
      PARAMETER (nvec=2*snx*sny)
      REAL*8 scalarproductmetric(nvec, 1, nsx, nsy)
      COMMON /seaice_krylov_rl/ scalarproductmetric
C
C
C
      COMMON /seaice_reg_neg/ d_heffbyneg, d_hsnwbyneg
      COMMON /seaice_reg_neg_b/ d_heffbynegb, d_hsnwbynegb
C     The change of mean ice thickness due to out-of-bounds values following
C     sea ice dynamics and advection
      REAL*8 d_heffbyneg(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 d_heffbynegb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 d_hsnwbyneg(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 d_hsnwbynegb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
C
C
C     saltWtrIce :: contains m of salty ice melted (<0) or created (>0)
C     frWtrIce   :: contains m of freshwater ice melted (<0) or created (>0)
C                   that is, ice due to precipitation or snow
      COMMON /iceflux/ saltwtrice, frwtrice
      REAL*8 saltwtrice(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 frwtrice(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
C     TICES :: Seaice/snow surface temperature for each category
      COMMON /multicategory/ tices
      COMMON /multicategory_b/ ticesb
      REAL*8 tices(1-olx:snx+olx, 1-oly:sny+oly, nitd, nsx, nsy)
      REAL*8 ticesb(1-olx:snx+olx, 1-oly:sny+oly, nitd, nsx, nsy)
C
CEH3 ;;; Local Variables: ***
CEH3 ;;; mode:fortran ***
CEH3 ;;; End: ***
C     *==========================================================*
C     | SEAICE_PARAMS.h
C     | o Basic parameter header for sea ice model.
C     *==========================================================*
C
C--   COMMON /SEAICE_PARM_L/ Logical parameters of sea ice model.
C - dynamics:
C     SEAICEuseDYNAMICS :: If false, do not use dynamics;
C                          default is to use dynamics.
C     SEAICEuseFREEDRIFT :: If True use free drift velocity instead of EVP
C                           or LSR
C     SEAICEuseStrImpCpl:: If true use strongly implicit coupling formulation
C                          for LSR solver (Hutchings et al 2004,
C                          Ocean Modelling, eq.44)
C     SEAICEuseEVP      :: If true use elastic viscous plastic solver
C     SEAICEuseEVPstar  :: If true use modified elastic viscous plastic
C                          solver (EVP*) by Lemieux et al (2012)
C     SEAICEuseEVPrev   :: If true use "revisited" elastic viscous plastic
C                          solver following Bouillon et al. (2013), very similar
C                          to EVP*, but uses fewer implicit terms and drops
C                          one 1/e^2 in equations for sigma2 and sigma12
C     SEAICEuseEVPpickup :: Set to false in order to start EVP solver with
C                          non-EVP pickup files.  Default is true.
C                          Applied only if SEAICEuseEVP=.TRUE.
C     SEAICEuseMultiTileSolver :: in LSR, use full domain tri-diagonal solver
C     SEAICEuseLSR      :: If true, use default Picard solver with Line-
C                          Successive(-over)-Relaxation, can also be true
C                          if LSR is used as a preconditioner for the
C                          non-linear JFNK solver
C     SEAICEuseLSRflex  :: If true, use default Picard solver with Line-
C                          Successive(-over)-Relaxation, but determine the
C                          number of non-linear iterations depends on the
C                          residual resduction, similar to the Krylov and
C                          JFNK solvers
C     SEAICEusePicardAsPrecon :: If true, allow SEAICEuseLSR = .TRUE. as a
C                          preconditioner for non-linear JFNK problem (def. = F)
C     SEAICEuseKrylov   :: If true, use matrix-free Krylov solver with Picard
C                          solver instead of LSR (default: false)
C     SEAICEuseJFNK     :: If true, use Jacobi-free Newton-Krylov solver
C                          instead of LSR (default: false)
C     SEAICEuseIMEX     :: use IMplicit/EXplicit scheme with JFNK
C     SEAICEuseTEM      :: to use the truncated ellipse method (see Geiger et al.
C                          1998) set this parameter to true, default is false
C     SEAICEuseMCS      :: to use the Mohr-Coulomb yield curve with a shear
C                          only flow rule (Ip et al 1991), set this parameter to
C                          true, default is false
C     SEAICEuseMCE      :: to use the Mohr-Coulomb yield curve with elliptical
C                          plastic potential (similarly to Hibler and Schulson
C                          2000 without the elliptical cap) set this parameter
C                          to true, default is false
C     SEAICEuseTD       :: to use the teardrop yield curve (Zhang and Rothrock,
C                          2005) set this parameter to true, default is false
C     SEAICEusePL       :: to use the parabolic lens yield curve (Zhang and
C                          Rothrock, 2005) set this parameter to true,
C                          default is false
C     SEAICEuseTilt     :: If true then include surface tilt term in dynamics
C     SEAICEuseMetricTerms :: use metric terms for dynamics solver
C                          (default = .true. )
C     SEAICE_no_slip    :: apply no slip boundary conditions to seaice velocity
C     SEAICE_2ndOrderBC :: apply 2nd order no slip boundary conditions (works
C                          only with EVP, JFNK or KRYLOV solver, default=F)
C     SEAICE_maskRHS    :: mask the RHS of the solver where there is no ice
C     SEAICE_clipVelocities :: clip velocities to +/- 40cm/s
C     SEAICEaddSnowMass :: in computing seaiceMass, add snow contribution
C                          default is .TRUE.
C     useHB87stressCoupling :: use an intergral over ice and ocean surface
C                          layer to define surface stresses on ocean
C                          following Hibler and Bryan (1987, JPO)
C     SEAICEupdateOceanStress :: If TRUE, update ocean surface stress
C                                accounting for seaice cover (default= T)
C     SEAICEuseBDF2     :: use 2nd-order backward difference approach
C                          for momentum equations as described in
C                          Lemieux et al. 2014, JCP
C                          so far only implemented for JFNK-solver
C     useHibler79IceStrength :: if true original ice strength parameterization
C                          other use Rothrock (1975) parameterization based
C                          on energetics and an ice thickness distribution
C                          (default = .true.)
C     SEAICEscaleSurfStress :: if TRUE, scale ice-ocean and ice-atmosphere
C                          stress on ice by concenration (AREA) following
C                          Connolley et al. (2004), JPO. (default = .TRUE.)
C     SEAICEsimpleRidging :: use Hibler(1979) ridging (default=.true.)
C     SEAICEuseLinRemapITD :: use linear remapping (Lipscomb et al. 2001)
C                             .TRUE. by default
C - advection:
C     SEAICEuseFluxForm :: use flux form for advection and diffusion
C                          of seaice
C     SEAICEadvHeff     :: turn on advection of effective thickness
C                          (default = .true.)
C     SEAICEadvArea     :: turn on advection of fraction area
C                          (default = .true.)
C     SEAICEadvSnow     :: turn on advection of snow (does not work with
C                          non-default Leap-frog scheme for advection)
C     SEAICEadvSalt     :: turn on advection of salt (does not work with
C                          non-default Leap-frog scheme for advection)
C     SEAICEmultiDimAdvection:: internal flag, set to false if any sea ice
C                          variable uses a non-multi-dimensional advection
C                          scheme
C     SEAICEmomAdvection:: turn on advection of momentum (default = .false.)
C     SEAICEhighOrderVorticity :: momentum advection parameters analogous to
C     SEAICEupwindVorticity    :: highOrderVorticity, upwindVorticity,
C     SEAICEuseAbsVorticity    :: useAbsVorticity, useJamartMomAdv for vector
C     SEAICEuseJamartMomAdv    :: invariant momentum in the ocean
C - thermodynamics:
C     usePW79thermodynamics :: use "0-layer" thermodynamics as described in
C                           Parkinson and Washington (1979) and Hibler (1979)
C     SEAICE_useMultDimSnow :: use same fixed pdf for snow as for
C                              multi-thickness-category ice (default=.TRUE.)
C     SEAICEuseFlooding  :: turn on scheme to convert submerged snow into ice
C     SEAICEheatConsFix  :: If true then fix ocn<->seaice advective heat flux.
C     useMaykutSatVapPoly :: use Maykut Polynomial for saturation vapor pressure
C                         instead of extended temp-range exponential law; def=F.
C     SEAICE_mcPheeStepFunc :: use step function (not linear tapering) in
C                           ocean-ice turbulent flux
C     SEAICE_doOpenWaterGrowth :: use open water heat flux directly to grow ice
C                           (when false cool ocean, and grow later if needed)
C     SEAICE_doOpenWaterMelt   :: use open water heat flux directly to melt ice
C                           (when false warm ocean, and melt later if needed)
C     SEAICE_growMeltByConv :: grow/melt according to convergence of turbulence
C                              and conduction, rather than in two steps (default)
C     SEAICE_salinityTracer    :: use SItracer to exchange and trace ocean
C                           salt in ice
C     SEAICE_ageTracer         :: use SItracer to trace the age of ice
C     SEAICErestoreUnderIce :: restore surface T/S also underneath ice
C                          ( default is false )
C - other (I/O, ...):
C     SEAICEwriteState  :: If true, write sea ice state to file;
C                          default is false.
C     SEAICE_tave_mdsio :: write TimeAverage output using MDSIO
C     SEAICE_dump_mdsio :: write snap-shot output   using MDSIO
C     SEAICE_mon_stdio  :: write monitor to std-outp
C     SEAICE_tave_mnc   :: write TimeAverage output using MNC
C     SEAICE_dump_mnc   :: write snap-shot output   using MNC
C     SEAICE_mon_mnc    :: write monitor to netcdf file
      LOGICAL seaiceusedynamics, seaiceusefreedrift, seaiceusestrimpcpl
     +        , seaiceuseevp, seaiceuseevpstar, seaiceuseevprev, 
     +        seaiceuseevppickup, seaiceusemultitilesolver, seaiceuselsr
     +        , seaiceuselsrflex, seaiceusekrylov, seaiceusejfnk, 
     +        seaiceuseimex, seaiceusebdf2, seaiceusepicardasprecon, 
     +        usehibler79icestrength, seaicesimpleridging, 
     +        seaiceuselinremapitd, seaiceusetd, seaiceusepl, 
     +        seaiceusetem, seaiceusetilt, seaiceusemetricterms, 
     +        seaiceusemcs, seaiceusemce, seaice_no_slip, 
     +        seaice_2ndorderbc, seaice_maskrhs, seaicescalesurfstress, 
     +        seaice_clipvelocities, seaiceaddsnowmass, 
     +        usehb87stresscoupling, seaiceupdateoceanstress, 
     +        seaiceusefluxform, seaiceadvheff, seaiceadvarea, 
     +        seaicemultidimadvection, seaiceadvsnow, seaiceadvsalt, 
     +        seaicemomadvection, seaicehighordervorticity, 
     +        seaiceupwindvorticity, seaiceuseabsvorticity, 
     +        seaiceusejamartmomadv, usepw79thermodynamics, 
     +        seaice_usemultdimsnow, seaiceuseflooding, 
     +        seaiceheatconsfix, usemaykutsatvappoly, 
     +        seaice_mcpheestepfunc, seaice_doopenwatergrowth, 
     +        seaice_doopenwatermelt, seaice_salinitytracer, 
     +        seaice_agetracer, seaicerestoreunderice, 
     +        seaice_growmeltbyconv, seaicewritestate, seaice_tave_mdsio
     +        , seaice_dump_mdsio, seaice_mon_stdio, seaice_tave_mnc, 
     +        seaice_dump_mnc, seaice_mon_mnc
      COMMON /seaice_parm_l/ seaiceusedynamics, seaiceusefreedrift, 
     +seaiceusestrimpcpl, seaiceuseevp, seaiceuseevpstar, 
     +seaiceuseevprev, seaiceuseevppickup, seaiceusemultitilesolver, 
     +seaiceuselsr, seaiceuselsrflex, seaiceusekrylov, seaiceusejfnk, 
     +seaiceuseimex, seaiceusebdf2, seaiceusepicardasprecon, 
     +usehibler79icestrength, seaicesimpleridging, seaiceuselinremapitd
     +, seaiceusetd, seaiceusepl, seaiceusetem, seaiceusetilt, 
     +seaiceusemetricterms, seaiceusemcs, seaiceusemce, seaice_no_slip, 
     +seaice_2ndorderbc, seaice_maskrhs, seaicescalesurfstress, 
     +seaice_clipvelocities, seaiceaddsnowmass, usehb87stresscoupling, 
     +seaiceupdateoceanstress, seaiceusefluxform, seaiceadvheff, 
     +seaiceadvarea, seaiceadvsnow, seaiceadvsalt, seaicemomadvection, 
     +seaicemultidimadvection, seaicehighordervorticity, 
     +seaiceupwindvorticity, seaiceuseabsvorticity, 
     +seaiceusejamartmomadv, usepw79thermodynamics, 
     +seaice_usemultdimsnow, seaiceuseflooding, seaiceheatconsfix, 
     +usemaykutsatvappoly, seaice_mcpheestepfunc, 
     +seaice_doopenwatergrowth, seaice_doopenwatermelt, 
     +seaice_salinitytracer, seaice_agetracer, seaicerestoreunderice, 
     +seaice_growmeltbyconv, seaicewritestate, seaice_tave_mdsio, 
     +seaice_dump_mdsio, seaice_mon_stdio, seaice_tave_mnc, 
     +seaice_dump_mnc, seaice_mon_mnc
C
C--   COMMON /SEAICE_PARM_I/ Integer valued parameters of sea ice model.
C     IMAX_TICE         :: number of iterations for ice surface temp
C                          (default=10)
C     postSolvTempIter :: select flux calculation after surf. temp solver
C                         iteration
C                         0 = none, i.e., from last iter
C                         1 = use linearized approx (consistent with tsurf
C                             finding)
C                         2 = full non-lin form
C     SOLV_NCHECK         :: iteration interval for LSR-solver convergence test
C     SEAICEnonLinIterMax :: number of allowed non-linear solver iterations
C                            for implicit solvers (JFNK and Picard) (>= 2)
C     SEAICElinearIterMax :: number of allowed linear solver iterations for
C                            for implicit solvers (JFNK and Picard) C
C     SEAICEpreconNL_Iter :: number non-linear iterations in preconditioner
C     SEAICEpreconLinIter :: number linear iterations in preconditioner
C     SEAICEnEVPstarSteps :: number of evp*-steps
C     SEAICEmomStartBDF   :: number of previous u/vIce time levels available
C                          to start (or restart) BDF2 scheme.
C     SEAICE_JFNK_lsIter  :: number of Newton iterations after which the
C                            line search is started
C     SEAICE_JFNK_lsLmax  :: max. number line search iterations (default = 4)
C     SEAICE_JFNK_tolIter :: number of Newton iterations after which the
C                            the tolerance is relaxed again (default = 100)
C     SEAICE_OLx/y      :: overlaps for LSR-solver and for the
C                          LSR-preconditioner in JFNK and KRYLOV solver;
C                          for 0 < SEAICE_OLx/y 0 <= OLx/y-2 the LSR solver
C                          and preconditioner use a restricted additive
C                          Schwarz method (default = OLx/y-2).
C     LSR_mixIniGuess   :: control mixing of free-drift sol. into LSR initial
C                          guess
C                       :: =0 : nothing; =1 : no mix, but print free-drift
C                          resid.;
C                       :: =2,4 : mix with (1/local-residual)^2,4 factor
C     SEAICEpresPow0    :: HEFF exponent for ice strength below SEAICEpresH0
C     SEAICEpresPow1    :: HEFF exponent for ice strength above SEAICEpresH0
C     rigding parameters (only active when SEAICE_ITD is defined)
C     SEAICEpartFunc    :: =0 use Thorndyke et al (1975) participation function
C                       :: =1 use Lipscomb et al (2007) participation function
C     SEAICEredistFunc  :: =0 assume ridged ice is uniformly distributed
C                             (Hibler, 1980)
C                          =1 Following Lipscomb et al. (2007), ridged ice is
C                             distributed following an exponentially
C                             decaying function
C     SEAICEridgingIterMax :: maximum number of ridging iterations
C     end ridging parameters
C     SEAICEselectKEscheme   :: momentum advection parameters analogous
C     SEAICEselectVortScheme :: to selectKEscheme and selectVortScheme
C     SEAICEadvScheme   :: sets the advection scheme for thickness and area
C                          (default = 77)
C     SEAICEadvSchArea  :: sets the advection scheme for area
C     SEAICEadvSchHeff  :: sets the advection scheme for effective thickness
C                         (=volume), snow thickness, and salt if available
C     SEAICEadvSchSnow  :: sets the advection scheme for snow on sea-ice
C     SEAICEadvSchSalt  :: sets the advection scheme for sea ice salinity
C     SEAICEadvSchSnow  :: sets the advection scheme for snow on sea-ice
C     SEAICE_areaLossFormula :: selects formula for ice cover loss from melt
C                        :: 1=from all but only melt conributions by ATM and OCN
C                        :: 2=from net melt-growth>0 by ATM and OCN
C                        :: 3=from predicted melt by ATM
C     SEAICE_areaGainFormula :: selects formula for ice cover gain from open
C                               water growth
C                        :: 1=from growth by ATM
C                        :: 2=from predicted growth by ATM
C     SEAICEetaZmethod   :: determines how shear-viscosity eta is computed at
C                           Z-points
C                           0=simple averaging from C-points (default and old)
C                           3=weighted averaging of squares of strain rates
C                             (recommended for energy conservation)
C     SEAICE_multDim     :: number of ice categories
C     SEAICE_debugPointI :: I,J index for seaice-specific debuggin
C     SEAICE_debugPointJ
C
      INTEGER imax_tice, postsolvtempiter
      INTEGER solv_ncheck
      INTEGER seaicenonlinitermax, seaicelinearitermax
      INTEGER seaicepreconliniter, seaicepreconnl_iter
      INTEGER lsr_mixiniguess
      INTEGER seaicenevpstarsteps
      INTEGER seaicemomstartbdf
      INTEGER seaice_jfnk_lsiter, seaice_jfnk_toliter
      INTEGER seaice_jfnk_lslmax
      INTEGER seaice_olx, seaice_oly
      INTEGER seaiceselectkescheme, seaiceselectvortscheme
      INTEGER seaiceadvscheme
      INTEGER seaiceadvscharea
      INTEGER seaiceadvschheff
      INTEGER seaiceadvschsnow
      INTEGER seaiceadvschsalt
      INTEGER seaiceadjmode
      INTEGER seaice_arealossformula
      INTEGER seaice_areagainformula
      INTEGER seaiceetazmethod
      INTEGER seaice_multdim
      INTEGER seaice_debugpointi
      INTEGER seaice_debugpointj
      INTEGER seaiceprespow0, seaiceprespow1
      INTEGER seaicepartfunc, seaiceredistfunc
      INTEGER seaiceridgingitermax
      COMMON /seaice_parm_i/ imax_tice, postsolvtempiter, solv_ncheck, 
     +seaicenonlinitermax, seaicelinearitermax, seaicepreconliniter, 
     +seaicepreconnl_iter, lsr_mixiniguess, seaicenevpstarsteps, 
     +seaicemomstartbdf, seaice_jfnk_lsiter, seaice_olx, seaice_oly, 
     +seaice_jfnk_lslmax, seaice_jfnk_toliter, seaiceprespow0, 
     +seaiceprespow1, seaicepartfunc, seaiceredistfunc, 
     +seaiceridgingitermax, seaiceselectkescheme, seaiceselectvortscheme
     +, seaiceadvscheme, seaiceadvscharea, seaiceadvschheff, 
     +seaiceadvschsnow, seaiceadvschsalt, seaiceadjmode, 
     +seaice_arealossformula, seaice_areagainformula, seaice_multdim, 
     +seaiceetazmethod, seaice_debugpointi, seaice_debugpointj
C
C--   COMMON /SEAICE_PARM_C/ Character valued sea ice model parameters.
C     AreaFile       :: File containing initial sea-ice concentration
C     HsnowFile      :: File containing initial snow thickness
C     HsaltFile      :: File containing initial sea ice salt content
C     HeffFile       :: File containing initial sea-ice thickness
C     uIceFile       :: File containing initial sea-ice U comp. velocity
C     vIceFile       :: File containing initial sea-ice V comp. velocity
C     uCoastLineFile :: File containing the some measure of coastline
C                       roughness length (in m) at the U-points in the
C                       X-direction (i.e. for the U-equation).
C     vCoastLineFile :: Files containing the some measure of coastline
C                       roughness length (in m) at the V-points in the
C                       Y-direction (i.e. for the V-equation).
C
C                       This roughness length can be the subgrid
C                       scale length of the coastline in a grid cell
C                       projected in the direction normal to the u/v-
C                       direction as in Liu et al. (2022), but it can
C                       also be anything that is a good proxy of coast
C                       line roughness.
C
C        !!! NOTE !!! Initial sea-ice thickness can also be set using
C        SEAICE_initialHEFF below.  But a constant initial condition
C        can mean large artificial fluxes of heat and freshwater in
C        the surface layer during the first model time step.
C
      CHARACTER*(max_len_fnam) areafile
      CHARACTER*(max_len_fnam) hsnowfile
      CHARACTER*(max_len_fnam) hsaltfile
      CHARACTER*(max_len_fnam) hefffile
      CHARACTER*(max_len_fnam) uicefile
      CHARACTER*(max_len_fnam) vicefile
      CHARACTER*(max_len_fnam) ucoastlinefile
      CHARACTER*(max_len_fnam) vcoastlinefile
      COMMON /seaice_parm_c/ areafile, hsnowfile, hsaltfile, hefffile, 
     +uicefile, vicefile, ucoastlinefile, vcoastlinefile
C
C--   COMMON /SEAICE_PARM_RL/ Real valued parameters of sea ice model.
C     SEAICE_deltaTtherm :: Seaice timestep for thermodynamic equations (s)
C     SEAICE_deltaTdyn   :: Seaice timestep for dynamic solver          (s)
C     SEAICE_LSRrelaxU/V :: relaxation parameter for LSR-solver: U/V-component
C     SEAICE_deltaTevp   :: Seaice timestep for EVP solver              (s)
C     SEAICE_elasticParm :: parameter that sets relaxation timescale
C                           tau = SEAICE_elasticParm * SEAICE_deltaTdyn
C     SEAICE_evpTauRelax :: relaxation timescale tau                    (s)
C     SEAICE_evpDampC    :: evp damping constant (Hunke,JCP,2001)       (kg/m^2)
C     SEAICE_evpAlpha    :: dimensionless parameter 2*evpTauRelax/deltaTevp
C     SEAICE_evpBeta     :: dimensionless parameter deltaTdyn/deltaTevp
C     SEAICEaEVPcoeff    :: main coefficent for adaptive EVP (largest
C                           stabilized frequency)
C     SEAICEaEVPcStar    :: multiple of stabilty factor: alpha*beta=cstar*gamma
C     SEAICEaEVPalphaMin :: lower limit of alpha and beta, regularisation
C                           to prevent singularities of system matrix,
C                           e.g. when ice concentration is too low.
C     SEAICEnonLinTol    :: non-linear tolerance parameter for implicit solvers
C     JFNKgamma_lin_min/max :: tolerance parameters for linear JFNK solver
C     JFNKres_t          :: tolerance parameter for FGMRES residual
C     JFNKres_tFac       :: if set, JFNKres_t=JFNKres_tFac*(initial residual)
C     SEAICE_JFNKepsilon :: step size for the FD-gradient in s/r seaice_jacvec
C     SEAICE_JFNK_lsGamma:: reduction factor for line search (default 0.5)
C     SEAICE_JFNKphi     :: [0,1] parameter for inexact Newton Method (def = 1)
C     SEAICE_JFNKalpha   :: (1,2] parameter for inexact Newton Method (def = 1)
C     SEAICE_zetaMaxFac  :: factor determining the maximum viscosity    (s)
C                          (default = 5.e+12/2.e4 = 2.5e8)
C     SEAICE_zetaMin     :: lower bound for viscosity (default = 0)    (N s/m^2)
C     SEAICEpresH0       :: HEFF threshold for ice strength            (m)
C     SEAICE_monFreq     :: SEAICE monitor frequency.                   (s)
C     SEAICE_dumpFreq    :: SEAICE dump frequency.                      (s)
C     SEAICE_taveFreq    :: SEAICE time-averaging frequency.            (s)
C     SEAICE_initialHEFF :: initial sea-ice thickness                   (m)
C     SEAICE_rhoAir      :: density of air                              (kg/m^3)
C     SEAICE_rhoIce      :: density of sea ice                          (kg/m^3)
C     SEAICE_rhoSnow     :: density of snow                             (kg/m^3)
C     ICE2WATR           :: ratio of sea ice density to water density
C     SEAICE_cpAir       :: specific heat of air                        (J/kg/K)
C
C     OCEAN_drag         :: unitless air-ocean drag coefficient (default 0.001)
C     SEAICE_drag        :: unitless air-ice drag coefficient   (default 0.001)
C     SEAICE_waterDrag   :: unitless water-ice drag coefficient (default 0.0055)
C     SEAICEdWatMin      :: minimum linear water-ice drag applied to DWATN
C                           (default 0.25 m/s)
C
C     SEAICE_dryIceAlb   :: winter albedo
C     SEAICE_wetIceAlb   :: summer albedo
C     SEAICE_drySnowAlb  :: dry snow albedo
C     SEAICE_wetSnowAlb  :: wet snow albedo
C     HO                 :: AKA "lead closing parameter", demarcation thickness
C                           between thin and thick ice. Alternatively, HO (in
C                           meters) can be interpreted as the thickness of ice
C                           formed in open water.
C                           HO is a key ice-growth parameter that determines
C                           the partition between vertical and lateral growth.
C                           The default is 0.5m, increasing this value leads
C                           slower formation of a closed ice cover and thus to
C                           more ice (and thicker) ice, decreasing to faster
C                           formation of a closed ice cover (leads are closing
C                           faster) and thus less (thinner) ice.
C
C     SEAICE_drag_south       :: Southern Ocean SEAICE_drag
C     SEAICE_waterDrag_south  :: Southern Ocean SEAICE_waterDrag
C     SEAICE_dryIceAlb_south  :: Southern Ocean SEAICE_dryIceAlb
C     SEAICE_wetIceAlb_south  :: Southern Ocean SEAICE_wetIceAlb
C     SEAICE_drySnowAlb_south :: Southern Ocean SEAICE_drySnowAlb
C     SEAICE_wetSnowAlb_south :: Southern Ocean SEAICE_wetSnowAlb
C     HO_south                :: Southern Ocean HO
C
C     Parameters for basal drag of grounded ice following
C     Lemieux et al. (2015), doi:10.1002/2014JC010678
C     SEAICE_cBasalStar (default = SEAICE_cStar)
C     SEAICEbasalDragU0 (default = 5e-5)
C     SEAICEbasalDragK1 (default = 8)
C     SEAICEbasalDragK2  :: if > 0, turns on basal drag
C                           (default = 0, Lemieux suggests 15)
C     SEAICEsideDrag     :: if > 0, turns on lateral static drag
C                           if < 0, turns on lateral quadratic drag
C                           both are different landfast ice parameterisations
C                           (Liu et al 2022 use 2e-4,
C                            the default = 0 turns off the parameterisations)
C
C     SEAICE_wetAlbTemp  :: Temp (deg.C) above which wet-albedo values are used
C     SEAICE_waterAlbedo :: water albedo
C     SEAICE_strength    :: sea-ice strength Pstar
C     SEAICE_cStar       :: sea-ice strength paramter C* (def: 20)
C     SEAICE_tensilFac   :: sea-ice tensile strength factor, values in [0,1]
C     SEAICE_tensilDepth :: crtical depth for sea-ice tensile strength (def 0.)
C     SEAICEpressReplFac :: interpolator between PRESS0 and regularized PRESS
C                           1. (default): pure pressure replace method (PRESS)
C                           0.          : pure Hibler (1979) method (PRESS0)
C     SEAICE_eccen       :: sea-ice eccentricity of the elliptical yield curve
C     SEAICE_eccfr       :: sea-ice eccentricity of the elliptical flow rule
C     SEAICE_lhFusion    :: latent heat of fusion for ice and snow (J/kg)
C     SEAICE_lhEvap      :: latent heat of evaporation for water (J/kg)
C     SEAICE_dalton      :: Dalton number (= sensible heat transfer coefficient)
C     SEAICE_iceConduct  :: sea-ice conductivity
C     SEAICE_snowConduct :: snow conductivity
C     SEAICE_emissivity  :: longwave ocean-surface emissivity (-)
C     SEAICE_ice_emiss   :: longwave ice-surface emissivity (-)
C     SEAICE_snow_emiss  :: longwave snow-surface emissivity (-)
C     SEAICE_boltzmann   :: Stefan-Boltzman constant (not a run time parameter)
C     SEAICE_snowThick   :: cutoff snow thickness (for snow-albedo)
C     SEAICE_shortwave   :: ice penetration shortwave radiation factor
C     SEAICE_saltFrac    :: salinity of newly formed seaice defined as a
C                           fraction of the ocean surface salinity at the time
C                           of freezing
C     SEAICE_salt0       :: prescribed salinity of seaice (in g/kg).
C     facOpenGrow        :: 0./1. version of logical SEAICE_doOpenWaterGrowth
C     facOpenMelt        :: 0./1. version of logical SEAICE_doOpenWaterMelt
C     SEAICE_mcPheePiston:: ocean-ice turbulent flux "piston velocity" (m/s)
C                           that sets melt efficiency.
C     SEAICE_mcPheeTaper :: tapering down of turbulent flux term with ice
C                           concentration. The 100% cover turb. flux is
C                           multiplied by 1.-SEAICE_mcPheeTaper
C     SEAICE_frazilFrac  :: Fraction of surface level negative heat content
C                           anomalies (relative to the local freezing point)
C                           may contribute as frazil over one time step.
C     SEAICE_tempFrz0    :: sea water freezing point is
C     SEAICE_dTempFrz_dS :: tempFrz = SEAICE_tempFrz0 + salt*SEAICE_dTempFrz_dS
C     SEAICE_PDF         :: prescribed sea-ice distribution within grid box
C     SEAICEstressFactor :: factor by which ice affects wind stress (default=1)
C     LSR_ERROR          :: sets accuracy of LSR solver
C     DIFF1              :: parameter used in advect.F
C     SEAICEtdMU         :: slope parameter for the teardrop and parabolic lens
C                           yield curves
C     SEAICE_deltaMin    :: small number used to reduce singularities of Delta
C     SEAICE_area_max    :: usually set to 1. Seeting areaMax below 1 specifies
C                           the minimun amount of leads (1-areaMax) in the
C                           ice pack.
C     SEAICE_area_floor  :: usually set to 1x10^-5. Specifies a minimun
C                           ice fraction in the ice pack.
C     SEAICE_area_reg    :: usually set to 1x10^-5. Specifies a minimun
C                           ice fraction for the purposes of regularization
C     SEAICE_hice_reg    :: usually set to 5 cm. Specifies a minimun
C                           ice thickness for the purposes of regularization
C     SEAICEdiffKhArea   :: sets the diffusivity for area (m^2/s)
C     SEAICEdiffKhHeff   :: sets the diffusivity for effective thickness (m^2/s)
C     SEAICEdiffKhSnow   :: sets the diffusivity for snow on sea-ice (m^2/s)
C     SEAICEdiffKhSalt   :: sets the diffusivity for sea ice salinity (m^2/s)
C     SEAICE_airTurnAngle   :: turning angles of air-ice interfacial stress
C     SEAICE_waterTurnAngle :: and ice-water interfacial stress (in degrees)
C     SEAICE_tauAreaObsRelax :: Timescale of relaxation to observed
C                               sea ice concentration (s), default=unset
C     ridging parameters (Lipscomb et al, 2007, Bitz et al. 2001):
C     SEAICE_cf       :: ratio of total energy sinks to gravitational sink
C                        (scales ice strength, suggested values: 2 to 17)
C     SEAICEgStar     :: maximum ice concentration that participates in ridging
C     SEAICEhStar     :: empirical thickness (ridging parameter)
C     SEAICEaStar     :: ice concentration parameter similar to gStar for
C                        exponential distribution (Lipscomb et al 2007)
C     SEAICEshearParm :: <=1 reduces amount of energy lost to ridge building
C     SEAICEmuRidging :: tuning parameter similar to hStar for Lipcomb et al
C                        (2007)-scheme
C     SEAICEmaxRaft   :: regularization parameter (default=1)
C     SEAICEsnowFracRidge :: fraction of snow that remains on ridged
C     SINegFac        :: SIADV over/undershoot factor in FW/Adjoint
C     SEAICEmcMu      :: parameter for MC yield curve for useMCE, useMCS and
C                        useTEM options, default is one
C
      REAL*8 seaice_deltattherm, seaice_deltatdyn, seaice_deltatevp
      REAL*8 seaice_lsrrelaxu, seaice_lsrrelaxv
      REAL*8 seaice_monfreq, seaice_dumpfreq, seaice_tavefreq
      REAL*8 seaice_initialheff
      REAL*8 seaice_rhoair, seaice_rhoice, seaice_rhosnow, ice2watr
      REAL*8 seaice_cpair
      REAL*8 seaice_drag, seaice_waterdrag, seaicedwatmin
      REAL*8 seaice_dryicealb, seaice_weticealb
      REAL*8 seaice_drysnowalb, seaice_wetsnowalb, ho
      REAL*8 seaice_drag_south, seaice_waterdrag_south
      REAL*8 seaice_dryicealb_south, seaice_weticealb_south
      REAL*8 seaice_drysnowalb_south, seaice_wetsnowalb_south, ho_south
      REAL*8 seaice_cbasalstar, seaicebasaldragu0
      REAL*8 seaicebasaldragk1, seaicebasaldragk2
      REAL*8 seaicesidedrag
      REAL*8 seaice_wetalbtemp, seaice_wateralbedo
      REAL*8 seaice_strength, seaice_cstar, seaicepressreplfac
      REAL*8 seaice_tensilfac, seaice_tensildepth
      REAL*8 seaice_eccen, seaice_eccfr
      REAL*8 seaicemcmu, seaicetdmu
      REAL*8 seaice_lhfusion, seaice_lhevap
      REAL*8 seaice_dalton
      REAL*8 seaice_iceconduct, seaice_snowconduct
      REAL*8 seaice_emissivity, seaice_ice_emiss, seaice_snow_emiss
      REAL*8 seaice_boltzmann
      REAL*8 seaice_snowthick, seaice_shortwave
      REAL*8 seaice_saltfrac, seaice_salt0, seaicestressfactor
      REAL*8 seaice_mcpheetaper, seaice_mcpheepiston
      REAL*8 seaice_frazilfrac, seaice_availheatfrac
      REAL*8 facopengrow, facopenmelt
      REAL*8 seaice_tempfrz0, seaice_dtempfrz_ds
      REAL*8 seaice_pdf(nitd)
      REAL*8 ocean_drag, lsr_error, diff1
      REAL*8 seaicenonlintol, jfnkres_t, jfnkres_tfac
      REAL*8 jfnkgamma_lin_min, jfnkgamma_lin_max, seaice_jfnkepsilon
      REAL*8 seaice_jfnk_lsgamma
      REAL*8 seaice_jfnkphi, seaice_jfnkalpha
      REAL*8 seaice_deltamin
      REAL*8 seaice_area_reg, seaice_hice_reg
      REAL*8 seaice_area_floor, seaice_area_max
      REAL*8 seaice_airturnangle, seaice_waterturnangle
      REAL*8 seaice_elasticparm, seaice_evptaurelax
      REAL*8 seaice_evpalpha, seaice_evpbeta
      REAL*8 seaice_evpdampc, seaice_zetamin, seaice_zetamaxfac
      REAL*8 seaiceaevpcoeff, seaiceaevpcstar, seaiceaevpalphamin
      REAL*8 seaicepresh0
      REAL*8 seaicediffkharea, seaicediffkhheff, seaicediffkhsnow
      REAL*8 seaicediffkhsalt
      REAL*8 seaice_tauareaobsrelax
      REAL*8 seaicegstar, seaicehstar, seaiceastar, seaiceshearparm
      REAL*8 seaicemuridging, seaicemaxraft, seaice_cf
      REAL*8 seaicesnowfracridge
      REAL*8 sinegfac
C
      COMMON /seaice_parm_rl/ seaice_deltattherm, seaice_deltatdyn, 
     +seaice_lsrrelaxu, seaice_lsrrelaxv, seaice_deltatevp, 
     +seaice_elasticparm, seaice_evptaurelax, seaice_evpalpha, 
     +seaice_evpbeta, seaiceaevpcoeff, seaiceaevpcstar, 
     +seaiceaevpalphamin, seaice_evpdampc, seaice_zetamin, 
     +seaice_zetamaxfac, seaicepresh0, seaice_monfreq, seaice_dumpfreq, 
     +seaice_tavefreq, seaice_initialheff, seaice_rhoair, seaice_rhoice
     +, seaice_rhosnow, ice2watr, seaice_drag, seaice_waterdrag, 
     +seaicedwatmin, seaice_dryicealb, seaice_weticealb, 
     +seaice_drysnowalb, seaice_wetsnowalb, ho, seaice_drag_south, 
     +seaice_waterdrag_south, seaice_dryicealb_south, 
     +seaice_weticealb_south, seaice_drysnowalb_south, 
     +seaice_wetsnowalb_south, ho_south, seaice_cbasalstar, 
     +seaicebasaldragu0, seaicebasaldragk1, seaicebasaldragk2, 
     +seaicesidedrag, seaice_wetalbtemp, seaice_wateralbedo, 
     +seaice_strength, seaice_cstar, seaice_eccen, seaice_eccfr, 
     +seaicetdmu, seaicemcmu, seaicepressreplfac, seaice_tensilfac, 
     +seaice_tensildepth, seaice_lhfusion, seaice_lhevap, seaice_dalton
     +, seaice_cpair, seaice_iceconduct, seaice_snowconduct, 
     +seaice_emissivity, seaice_ice_emiss, seaice_snow_emiss, 
     +seaice_boltzmann, seaice_snowthick, seaice_shortwave, 
     +seaice_saltfrac, seaice_salt0, seaicestressfactor, 
     +seaice_mcpheetaper, seaice_mcpheepiston, seaice_frazilfrac, 
     +seaice_availheatfrac, facopengrow, facopenmelt, seaice_tempfrz0, 
     +seaice_dtempfrz_ds, seaice_pdf, ocean_drag, lsr_error, diff1, 
     +seaicenonlintol, jfnkres_t, jfnkres_tfac, jfnkgamma_lin_min, 
     +jfnkgamma_lin_max, seaice_jfnkepsilon, seaice_jfnk_lsgamma, 
     +seaice_jfnkphi, seaice_jfnkalpha, seaice_deltamin, seaice_area_reg
     +, seaice_hice_reg, seaice_area_floor, seaice_area_max, 
     +seaicediffkharea, seaicediffkhheff, seaicediffkhsnow, 
     +seaicediffkhsalt, seaice_tauareaobsrelax, seaice_airturnangle, 
     +seaice_waterturnangle, seaicegstar, seaicehstar, seaiceastar, 
     +seaiceshearparm, seaicemuridging, seaicemaxraft, seaice_cf, 
     +sinegfac, seaicesnowfracridge
C
C--   COMMON /SEAICE_BOUND_RL/ Various bounding values
C     MIN_ATEMP         :: minimum air temperature   (deg C)
C     MIN_LWDOWN        :: minimum downward longwave (W/m^2)
C     MIN_TICE          :: minimum ice temperature   (deg C)
C     SEAICE_EPS        :: small number
C     SEAICE_EPS_SQ     :: small number square
C
      REAL*8 min_atemp, min_lwdown, min_tice
      REAL*8 seaice_eps, seaice_eps_sq
      COMMON /seaice_bound_rl/ min_atemp, min_lwdown, min_tice, 
     +seaice_eps, seaice_eps_sq
C
C
C--   Constants used by sea-ice model
      REAL*8 zero, one, two
      PARAMETER (zero=0.0d0, one=1.0d0, two=2.0d0)
      REAL*8 quart, half
      PARAMETER (quart=0.25d0, half=0.5d0)
      REAL*8 sieps
      PARAMETER (sieps=1.d-5)
C
C--   Constants needed by McPhee formulas for turbulent ocean fluxes :
C        Stanton number (dimensionless), typical friction velocity
C        beneath sea ice (m/s), and tapering factor (dimensionless)
      REAL*8 stanton_number, ustar_base, mcphee_taper_fac
      PARAMETER (mcphee_taper_fac=12.5d0, stanton_number=0.0056d0, 
     +   ustar_base=0.0125d0)
C
C--   identifiers for advected properties
      INTEGER gad_heff, gad_area, gad_qice1, gad_qice2, gad_snow
      INTEGER gad_salt, gad_sitr
      PARAMETER (gad_heff=1, gad_area=2, gad_snow=3, gad_salt=4, 
     +   gad_qice1=5, gad_qice2=6, gad_sitr=7)
C
CEH3 ;;; Local Variables: ***
CEH3 ;;; mode:fortran ***
CEH3 ;;; End: ***
C     *==========================================================*
C     | SEAICE_COST.h                                            |
C     | o Sea ice cost terms.                                    |
C     *==========================================================*
C
C     objf_ice   :: sea-ice volume
      COMMON /seaice_cost_objf/ objf_ice, objf_ice_export
      REAL*8 objf_ice(nsx, nsy)
      REAL*8 objf_ice_export(nsx, nsy)
C
C-   SEAICE_cutoff_area & _heff :: only used in pkg/ecco GET_EXCONC_DECONC S/R
      COMMON /seaice_cost_aux_r/ num_ice, mult_ice, mult_ice_export, 
     +seaice_cutoff_area, seaice_cutoff_heff
      REAL*8 num_ice(nsx, nsy)
      REAL*8 mult_ice
      REAL*8 mult_ice_export
      REAL*8 seaice_cutoff_area
      REAL*8 seaice_cutoff_heff
C
      COMMON /seaice_cost_data_aux_i/ costicestart1, costicestart2, 
     +costiceend1, costiceend2
      INTEGER costicestart1
      INTEGER costicestart2
      INTEGER costiceend1
      INTEGER costiceend2
C
      COMMON /seaice_cost_data_times_r/ costicestart, costiceend
      REAL*8 costicestart
      REAL*8 costiceend
C
C     cost_ice_flag  :: cost_ice flag (see seaice_cost_test.F)
      COMMON /seaice_cost_i/ cost_ice_flag
      INTEGER cost_ice_flag
C
CBOP
C !ROUTINE: SEAICE_TRACER.h
C
C !DESCRIPTION: \bv
C     /==========================================================C     | SEAICE_TRACER.h                                         
C |
C     | o Begin header for sea ice tracers                       |
C     \==========================================================/
C
C \ev
CEOP
C
C
CEH3 ;;; Local Variables: ***
CEH3 ;;; mode:fortran ***
CEH3 ;;; End: ***
C
C--   SALT_PLUME parameters
C     Find surface where the potential density (ref.lev=surface) is
C     larger than surface density plus SaltPlumeCriterion.
C
C     SaltPlumeSouthernOcean: TRUE  = apply salt plume globally
C                             FALSE = apply salt plume in Arctic Ocean only
      LOGICAL saltplumesouthernocean
      COMMON /salt_plume_params_l/ saltplumesouthernocean
C
C     CriterionType: 1=delta_rho, 2=drhodz, default is 1
C     PlumeMethod: method of distributing salt plume vertically
C       1=power, 2=exp, 3=overshoot, 5=dump_at_top, 6=reverse of 1
C       default is 1
C     Npower: choices of distributing salt uniformly (0), linear (1),
C       or higher power (Npower>1); default is 0 when PlumeMethod = 1
      INTEGER criteriontype, plumemethod, npower
      COMMON /salt_plume_params_i/ criteriontype, plumemethod, npower
C
C     SaltPlumeCriterion
C       for CriterionType=1, default is 0.4 kg/m^3 of Duffy et al 1999
C       for CriterionType=2, default is 0.005 kg/m^3/m
C     SPovershoot: overshooting depth of penetrating salt plume,
C       so that 1.0 = no-overshoot, 1.2 = 20% overshoot.
C       default is 1.0
C     SPsalFRAC: fraction of the salt by-product of seaice growth (not melt) that
C       will be re-distributed vertically according to the salt_plume_frac.F
C       Its default is 1. (for 100% effect), and its range is [0. 1.]
C     SPinflectionPoint: the inflection point of a nonlinear function
C       f(AREA) controlling saltPlumeFlux. f(AREA) is a logistic curve
C       (sigmoid) with range [0. 1.] and f(SPinflectionPoint) == 0.5.
C       Usage: pkg/salt_plume activates when AREA>=SPinflectionPoint.
C       To assure only narrow leads generate plumes:
C       set SPinflectionPoint >= 0.8.
C     SPalpha :: fraction of grid volume designated to be brine, [0. 1.]
C       If grid cell 18km x 18km x 10m, take SPalpha=0.001 gives
C       volume of 0.001*drF(1)*[dx*dy] of brine. Thus SPbrineSalt
C       can be calc as adding SaltPlumeFlux into this fractional vol.
C       Default: 0.008 -> SPbrineSalt ~37 if SSS is ~32.
C     SPbrineSconst :: salinity of brine pocket (g/kg)
C
      REAL*8 saltplumecriterion, spovershoot, spsalfrac
      COMMON /salt_plume_params_r/ spsalfrac, saltplumecriterion, 
     +spovershoot
C--   SALT_PLUME 2-dim. fields
C     SaltPlumeDepth :: depth of penetration of salt plumes
C                       rejected during sea ice growth
C     saltPlumeFlux :: Net downward salt flux in g/m^2/s
C              Note: only used when salty sea-ice forms.
C              > 0 for increasing in SSS.
C              Southwest C-grid tracer point
C     dSPvolSurf2kLev :: downward volume frac from klev=1 associated w/ saltPlumeFlux
C     dSPvolBelow2kLev:: upward volume frac from grid below (RETIRED)
C     dSPvolkLev2Above:: upward volume frac to grid above
C     SPbrineVolFlux  :: brine Vol associated w/ SPbrineSconst & saltPlumeFlux
C     SPforcingS      :: 3D forcingS associated w/ saltPlumeFlux in g/m^2/s
C     SPforcingT      :: 3D forcingT associated w/ saltPlumeFlux in W/m^2
C     SPkBottom       :: bottom kLev associated with SaltPlumeDepth
C
      REAL*8 saltplumedepth(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 saltplumedepthb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 saltplumeflux(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 saltplumefluxb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      COMMON /dynvars_salt_plume/ saltplumedepth
      COMMON /dynvars_salt_plume_b/ saltplumedepthb
      COMMON /ffields_saltplumeflux/ saltplumeflux
      COMMON /ffields_saltplumeflux_b/ saltplumefluxb
C#ifndef 
C--   Since many common block here depend on Options, not safe to have this
C     header included without SALT_PLUME_OPTIONS.h. Safety-check below:
C     this line will fail to compile src code if Option file is not included
C     STOP 'need "SALT_PLUME_OPTIONS.h" to include "SALT_PLUME.h"'
C#endif
CBOP
C     !ROUTINE: CG2D.h
C     !INTERFACE:
C     include "CG2D.h"
C
C     !DESCRIPTION:
C     \bv
C     *==========================================================*
C     | CG2D.h
C     | o Two-dimensional conjugate gradient solver header.
C     *==========================================================*
C     | Internal (private) data structures.
C     *==========================================================*
C     \ev
CEOP
C
C--   COMMON /CG2D_I_L/ cg2dNormaliseRHS
C     cg2dNormaliseRHS :: flag set to TRUE if normalise RHS in the Solver
      COMMON /cg2d_i_l/ cg2dnormaliserhs
      LOGICAL cg2dnormaliserhs
C
C--   COMMON /CG2D_I_R/ DEL**2 Laplacian operators
C     aW2d    :: East-west operator.
C     aS2d    :: North-south operator.
C     aC2d    :: 2D operator main diagonal term.
C     pW      :: East-west off-diagonal term of preconditioner.
C     pS      :: North-south off-diagonal term of preconditioner.
C     pC      :: Main diagonal term of preconditioner.
C     cg2dNorm :: A matrix normalisation factor.
C     cg2dTolerance_sq :: square of cg2d solver Tolerance (units depends
C                 on cg2dNormaliseRHS, solver-unit ^2 = (m2/s2)^2 or no unit)
      COMMON /cg2d_i_rs/ aw2d, as2d, ac2d, pw, ps, pc
      COMMON /cg2d_i_rl/ cg2dnorm, cg2dtolerance_sq
      REAL*8 aw2d(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 as2d(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 ac2d(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 pw(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 ps(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 pc(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 cg2dnorm, cg2dtolerance_sq
C
C---+----1----+----2----+----3----+----4----+----5----+----6----+----7-|--+----|
C
C-- keep tamc.h here without ALLOW_AUTODIFF_TAMC for ALLOW_TAMC_CHECKPOINTING
CBOP
C     !ROUTINE: tamc.h
C     !INTERFACE:
C     #include "tamc.h"
C
C     !DESCRIPTION:
C     *================================================================*
C     | tamc.h
C     | o Header file defining parameters and variables for the use of
C     |   the Tangent Linear and Adjoint Model Compiler (TAMC)
C     |   or the Transformations in Fortran tool (TAF).
C     |
C     | started: Christian Eckert eckert@mit.edu  04-Feb-1999
C     | changed: Patrick Heimbach heimbach@mit.edu 06-Jun-2000
C     | cleanup: Martin Losch Martin.Losch@awi.de Nov-2022
C     *================================================================*
CEOP
C     ================================================================
C     END OF HEADER TAMC
C     ================================================================
C
C     it is important that this file is included after SEAICE_SIZE.h
C---  Fields need in autodiff_store.F and autodiff_restore.F
C
C
C
C     ==================================================================
C     CTRL_SIZE.h
C     ==================================================================
C
C
C     Generic control variable array dimension
C     ----------------------------------------
C
C     maxCtrlArr2D :: number of 2-d generic init. ctrl variables
C     maxCtrlArr3D :: number of 3-d generic init. ctrl variables
C     maxCtrlTim2D :: number of 2-d generic tim-varying ctrl variables
C     maxCtrlProc  :: number of pre-processing options per ctrl variable
C
      INTEGER maxctrlarr2d
      PARAMETER (maxctrlarr2d=1)
C
      INTEGER maxctrlarr3d
      PARAMETER (maxctrlarr3d=2)
C
      INTEGER maxctrltim2d
      PARAMETER (maxctrltim2d=4)
C
      INTEGER maxctrlproc
      PARAMETER (maxctrlproc=1)
C
C
CEH3 ;;; Local Variables: ***
CEH3 ;;; mode:fortran ***
CEH3 ;;; End: ***
CBOP
C     !ROUTINE: CTRL.h
C     !INTERFACE:
C     #include "CTRL.h"
C
C     !DESCRIPTION:
C     *================================================================*
C     | CTRL.h
C     | o Header file defining control variables of the ECCO state
C     |   estimation tool.
C     | o Depending on the specific problem to be studied users may
C     |   have to modify this header file.
C     | o started: Christian Eckert eckert@mit.edu  30-Jun-1999
C     *================================================================*
CEOP
C
C--   set maximum number of control variables:
      INTEGER maxcvars
      PARAMETER (maxcvars=0+maxctrlarr2d+maxctrlarr3d+maxctrltim2d)
C
C
C-  ctrlprec will be set to 32 for ECCO to reduce I/O but this jeopardizes
C   gradient checks accuracy, so should be set to 64 by default.
      INTEGER ctrlprec
      COMMON /controlparams_i/ ctrlprec
C
C
      COMMON /controlparams_r/ delzexp, forcingprecond
C
      REAL*8 delzexp
      REAL*8 forcingprecond
C
      COMMON /controlparams_c/ ctrldir
C
      CHARACTER*(max_len_fnam) ctrldir
C
C     doInitXX            :: at iter 0 only, set ctrls to 0 and write
C                            to xx*000.data
C     doMainPack          :: pack adxx*data files into ecco_cost_* file
C                            (usually for optim.x)
C     doMainUnpack        :: unpack ecco_ctrl_* file (usually from optim.x)
C                            into xx_*data files
C     doPackDiag          :: output diag_pack*/diag_unpack* files during
C                            ctrl_pack/ctrl_unpack
C     doSinglePrecTapelev :: reduce precision of ad tape files to float32
C                            (only used in pkg/autodiff ...)
C
      COMMON /controlparams_l/ doinitxx, doadmtlm, dopackdiag, 
     +dozscaleunpack, dozscalepack, domainunpack, domainpack, 
     +dosingleprectapelev, doadmtlmbypassad
C
      LOGICAL doinitxx
      LOGICAL doadmtlm
      LOGICAL dopackdiag
      LOGICAL dozscaleunpack
      LOGICAL dozscalepack
      LOGICAL domainunpack
      LOGICAL domainpack
      LOGICAL dosingleprectapelev
      LOGICAL doadmtlmbypassad
C
C--   parameters vectors, set in S/R CTRL_INIT_CTRLVAR, that describe
C     the contorl variables, also used for identification across
C     different parts of the code:
C     ncvarfname    :: unique (and predefined) name of control variable
C     ncvarindex    :: number to identify variable, depends specified ctrl-vars
C     ncvarrecs     :: number of records for time dependent ctrl-variables;
C     ncvarrecstart :: first and last record of time dependent ctrl-variables;
C     ncvarrecsend  :: for constant-in-time variables all three are 1
C     ncvargrd      :: type or/and position on the grid, possible values:
C                      'c' (cell Center), 'w' (West face) ,'s' (South face),
C                      'i' (shelfice), 'm' (obcs)
C     ncvartype     :: shape of the grid: Arr3D, Arr2D, Tim2D, SecXZ, SecYZ
C     ncvarx/y/nrmax:: i,j,k-dimensions of ctrl-variable (on tile)
C
C--   holds control-variable setting and params as maxcvars long vector
C     in following "controlvar_*" common blocks:
      COMMON /controlvars_i/ nvartype, nvarlength, ncvarindex, ncvarrecs
     +, ncvarrecstart, ncvarrecsend, ncvarxmax, ncvarymax, ncvarnrmax, 
     +nwetctile, nwetstile, nwetwtile, nwetvtile, nwetcglobal, 
     +nwetsglobal, nwetwglobal, nwetvglobal, nbuffglobal
      INTEGER nvartype
      INTEGER nvarlength
      INTEGER ncvarindex(maxcvars)
      INTEGER ncvarrecs(maxcvars)
      INTEGER ncvarrecstart(maxcvars)
      INTEGER ncvarrecsend(maxcvars)
      INTEGER ncvarxmax(maxcvars)
      INTEGER ncvarymax(maxcvars)
      INTEGER ncvarnrmax(maxcvars)
      INTEGER nwetctile(nsx, nsy, nr)
      INTEGER nwetstile(nsx, nsy, nr)
      INTEGER nwetwtile(nsx, nsy, nr)
      INTEGER nwetvtile(nsx, nsy, nr)
      INTEGER nwetcglobal(nr)
      INTEGER nwetsglobal(nr)
      INTEGER nwetwglobal(nr)
      INTEGER nwetvglobal(nr)
      INTEGER nbuffglobal
C
C
      COMMON /controlvars_c/ ncvargrd, ncvartype, ncvarfname, yadprefix
      CHARACTER*1 ncvargrd(maxcvars)
      CHARACTER*5 ncvartype(maxcvars)
      CHARACTER*(max_len_fnam) ncvarfname(maxcvars)
      CHARACTER*2 yadprefix
C
C     Define unit weight as a placeholder
      COMMON /ctrl_weights_unit_r/ wunit
      REAL*8 wunit(nr, nsx, nsy)
C
      COMMON /packnames_c/ yadmark, ctrlname, costname, scalname, 
     +maskname, metaname, yctrlid, yctrlposunpack, yctrlpospack
      CHARACTER*2 yadmark
      CHARACTER*9 ctrlname
      CHARACTER*9 costname
      CHARACTER*9 scalname
      CHARACTER*9 maskname
      CHARACTER*9 metaname
      CHARACTER*10 yctrlid
      CHARACTER*4 yctrlposunpack
      CHARACTER*4 yctrlpospack
C
C
C     Control variables:
C     ==================
C
C
C---+----1----+----2----+----3----+----4----+----5----+----6----+----7-|--+----|
CBOP
C     !ROUTINE: CTRL_DUMMY.h
C     !INTERFACE:
C     #include "CTRL_DUMMY.h"
C
C     !DESCRIPTION:
C     *================================================================*
C     | CTRL_DUMMY.h
C     | o Control variables of the ECCO state estimation tool
C     *================================================================*
CEOP
C
C--   Parameters maxCtrlArr2D, maxCtrlArr3D, maxCtrlTim2D are set in CTRL_SIZE.h
      COMMON /ctrl_dummy_arr/ xx_genarr2d_dummy, xx_genarr3d_dummy, 
     +xx_gentim2d_dummy
      COMMON /ctrl_dummy_arr_b/ xx_genarr2d_dummyb, xx_genarr3d_dummyb, 
     +xx_gentim2d_dummyb
      REAL*8 xx_genarr2d_dummy(maxctrlarr2d)
      REAL*8 xx_genarr2d_dummyb(maxctrlarr2d)
      REAL*8 xx_genarr3d_dummy(maxctrlarr3d)
      REAL*8 xx_genarr3d_dummyb(maxctrlarr3d)
      REAL*8 xx_gentim2d_dummy(maxctrltim2d)
      REAL*8 xx_gentim2d_dummyb(maxctrltim2d)
C
C---+----1----+----2----+----3----+----4----+----5----+----6----+----7-|--+----|
C     ==================================================================
C     CTRL_GENARR.h
C     ==================================================================
C
C
      COMMON /controlfiles_carr/ xx_genarr2d_file, xx_genarr3d_file, 
     +xx_genarr2d_weight, xx_genarr3d_weight, xx_genarr2d_preproc, 
     +xx_genarr2d_preproc_c, xx_genarr3d_preproc, xx_genarr3d_preproc_c
      CHARACTER*(max_len_fnam) xx_genarr2d_file(maxctrlarr2d)
      CHARACTER*(max_len_fnam) xx_genarr3d_file(maxctrlarr3d)
      CHARACTER*(max_len_fnam) xx_genarr2d_weight(maxctrlarr2d)
      CHARACTER*(max_len_fnam) xx_genarr3d_weight(maxctrlarr3d)
      CHARACTER*(max_len_fnam) xx_genarr2d_preproc(maxctrlproc, 
     +                         maxctrlarr2d)
      CHARACTER*(max_len_fnam) xx_genarr3d_preproc(maxctrlproc, 
     +                         maxctrlarr3d)
      CHARACTER*(max_len_fnam) xx_genarr2d_preproc_c(maxctrlproc, 
     +                         maxctrlarr2d)
      CHARACTER*(max_len_fnam) xx_genarr3d_preproc_c(maxctrlproc, 
     +                         maxctrlarr3d)
C
      COMMON /controlfiles_rarr/ genarr2dprecond, genarr3dprecond, 
     +xx_genarr2d_bounds, xx_genarr3d_bounds, xx_genarr2d_preproc_r, 
     +xx_genarr3d_preproc_r
      REAL*8 genarr2dprecond(maxctrlarr2d)
      REAL*8 genarr3dprecond(maxctrlarr3d)
      REAL*8 xx_genarr2d_bounds(5, maxctrlarr2d)
      REAL*8 xx_genarr3d_bounds(5, maxctrlarr3d)
      REAL*8 xx_genarr2d_preproc_r(maxctrlproc, maxctrlarr2d)
      REAL*8 xx_genarr3d_preproc_r(maxctrlproc, maxctrlarr3d)
C
      COMMON /controlfiles_iarr/ xx_genarr2d_preproc_i, 
     +xx_genarr3d_preproc_i
      INTEGER xx_genarr2d_preproc_i(maxctrlproc, maxctrlarr2d)
      INTEGER xx_genarr3d_preproc_i(maxctrlproc, maxctrlarr3d)
C
      COMMON /controlfiles_ctim/ xx_gentim2d_file, xx_gentim2d_weight, 
     +xx_gentim2d_preproc, xx_gentim2d_preproc_c
      CHARACTER*(max_len_fnam) xx_gentim2d_file(maxctrltim2d)
      CHARACTER*(max_len_fnam) xx_gentim2d_weight(maxctrltim2d)
      CHARACTER*(max_len_fnam) xx_gentim2d_preproc(maxctrlproc, 
     +                         maxctrltim2d)
      CHARACTER*(max_len_fnam) xx_gentim2d_preproc_c(maxctrlproc, 
     +                         maxctrltim2d)
C
      COMMON /controlfiles_itim/ xx_gentim2d_startdate1, 
     +xx_gentim2d_startdate2, xx_gentim2d_startdate, 
     +xx_gentim2d_preproc_i
      INTEGER xx_gentim2d_startdate1(maxctrltim2d)
      INTEGER xx_gentim2d_startdate2(maxctrltim2d)
      INTEGER xx_gentim2d_startdate(4, maxctrltim2d)
      INTEGER xx_gentim2d_preproc_i(maxctrlproc, maxctrltim2d)
C
      COMMON /controlfiles_rtim/ xx_gentim2d_period, gentim2dprecond, 
     +xx_gentim2d_preproc_r, xx_gentim2d_bounds
      REAL*8 xx_gentim2d_period(maxctrltim2d)
      REAL*8 gentim2dprecond(maxctrltim2d)
      REAL*8 xx_gentim2d_preproc_r(maxctrlproc, maxctrltim2d)
      REAL*8 xx_gentim2d_bounds(5, maxctrltim2d)
C
      COMMON /controlfiles_ltim/ xx_gentim2d_cumsum, xx_gentim2d_glosum
      LOGICAL xx_gentim2d_cumsum(maxctrltim2d)
      LOGICAL xx_gentim2d_glosum(maxctrltim2d)
C
      COMMON /controlaux_gencost_r/ objf_gentim2d, num_gentim2d, 
     +mult_gentim2d, objf_genarr2d, num_genarr2d, mult_genarr2d, 
     +objf_genarr3d, num_genarr3d, mult_genarr3d
C
      REAL*8 objf_gentim2d(nsx, nsy, maxctrltim2d)
      REAL*8 num_gentim2d(nsx, nsy, maxctrltim2d)
      REAL*8 mult_gentim2d(maxctrltim2d)
      REAL*8 objf_genarr2d(nsx, nsy, maxctrlarr2d)
      REAL*8 num_genarr2d(nsx, nsy, maxctrlarr2d)
      REAL*8 mult_genarr2d(maxctrlarr2d)
      REAL*8 objf_genarr3d(nsx, nsy, maxctrlarr3d)
      REAL*8 num_genarr3d(nsx, nsy, maxctrlarr3d)
      REAL*8 mult_genarr3d(maxctrlarr3d)
C
C
      COMMON /controlaux_genarr2d_r/ wgenarr2d
      REAL*8 wgenarr2d(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy, 
     +       maxctrlarr2d)
C
      COMMON /controlaux_genarr3d_r/ wgenarr3d
      REAL*8 wgenarr3d(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy, 
     +       maxctrlarr3d)
C
      COMMON /controlaux_gentim2d_r/ xx_gentim2d0, xx_gentim2d1, 
     +xx_gentim2d, wgentim2d
      COMMON /controlaux_gentim2d_r_b/ xx_gentim2d0b, xx_gentim2d1b, 
     +xx_gentim2db
      REAL*8 xx_gentim2d0(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy, 
     +       maxctrltim2d)
      REAL*8 xx_gentim2d0b(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy, 
     +       maxctrltim2d)
      REAL*8 xx_gentim2d1(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy, 
     +       maxctrltim2d)
      REAL*8 xx_gentim2d1b(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy, 
     +       maxctrltim2d)
      REAL*8 xx_gentim2d(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy, 
     +       maxctrltim2d)
      REAL*8 xx_gentim2db(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy, 
     +       maxctrltim2d)
      REAL*8 wgentim2d(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy, 
     +       maxctrltim2d)
C
CEH3 ;;; Local Variables: ***
CEH3 ;;; mode:fortran ***
CEH3 ;;; End: ***
CBOP
C     !ROUTINE: CTRL_OBCS.h
C     !INTERFACE:
C     #include "CTRL_OBCS.h"
C
C     !DESCRIPTION:
C     *================================================================*
C     | CTRL_OBCS.h
C     | o Header file for OBCS Control and related weights
C     *================================================================*
CEOP
C
C-- IMPORTANT NOTE: The declaration of parameter "nobcs" has been moved
C   from SIZE.h. If you encounter compile time errors related to "nobcs",
C   make sure that your SIZE.h does not contain any declaration of this
C   parameter.
C--
      INTEGER nobcs
      PARAMETER (nobcs=4)
C
      REAL*8 objf_obcsn(nsx, nsy), objf_obcss(nsx, nsy)
      REAL*8 objf_obcsw(nsx, nsy), objf_obcse(nsx, nsy)
      REAL*8 objf_obcsvol, objf_ageos(nsx, nsy)
      REAL*8 mult_obcsn, mult_obcss
      REAL*8 mult_obcsw, mult_obcse
      REAL*8 mult_obcsvol, mult_ageos
      REAL*8 num_obcsn(nsx, nsy), num_obcss(nsx, nsy)
      REAL*8 num_obcsw(nsx, nsy), num_obcse(nsx, nsy)
      REAL*8 num_obcsvol, num_ageos(nsx, nsy)
      COMMON /ecco_cost_weights_obcs/ objf_obcsn, objf_obcss, objf_obcsw
     +, objf_obcse, objf_obcsvol, objf_ageos, mult_obcsn, mult_obcss, 
     +mult_obcsw, mult_obcse, mult_obcsvol, mult_ageos, num_obcsn, 
     +num_obcss, num_obcsw, num_obcse, num_obcsvol, num_ageos
C
      COMMON /ih_modes/ modesv
      REAL*8 modesv(nr, nr, nr)
      COMMON /ctrl_dummy_obcs/ xx_obcsn_dummy, xx_obcss_dummy, 
     +xx_obcsw_dummy, xx_obcse_dummy
      REAL*8 xx_obcsn_dummy
      REAL*8 xx_obcss_dummy
      REAL*8 xx_obcsw_dummy
      REAL*8 xx_obcse_dummy
      COMMON /controlfiles_c_obcs/ xx_obcsn_file, xx_obcss_file, 
     +xx_obcsw_file, xx_obcse_file
      CHARACTER*(max_len_fnam) xx_obcsn_file
      CHARACTER*(max_len_fnam) xx_obcss_file
      CHARACTER*(max_len_fnam) xx_obcsw_file
      CHARACTER*(max_len_fnam) xx_obcse_file
      COMMON /controltimes_r_obcs/ xx_obcsnperiod, xx_obcssperiod, 
     +xx_obcswperiod, xx_obcseperiod
      REAL*8 xx_obcsnperiod
      REAL*8 xx_obcssperiod
      REAL*8 xx_obcswperiod
      REAL*8 xx_obcseperiod
      COMMON /controltimes_i_obcs/ xx_obcsnstartdate1, 
     +xx_obcsnstartdate2, xx_obcssstartdate1, xx_obcssstartdate2, 
     +xx_obcswstartdate1, xx_obcswstartdate2, xx_obcsestartdate1, 
     +xx_obcsestartdate2, xx_obcsnstartdate, xx_obcssstartdate, 
     +xx_obcswstartdate, xx_obcsestartdate
      INTEGER xx_obcsnstartdate1
      INTEGER xx_obcsnstartdate2
      INTEGER xx_obcssstartdate1
      INTEGER xx_obcssstartdate2
      INTEGER xx_obcswstartdate1
      INTEGER xx_obcswstartdate2
      INTEGER xx_obcsestartdate1
      INTEGER xx_obcsestartdate2
      INTEGER xx_obcsnstartdate(4)
      INTEGER xx_obcssstartdate(4)
      INTEGER xx_obcswstartdate(4)
      INTEGER xx_obcsestartdate(4)
      COMMON /controlvars_i_obcsn/ nwetobcsn, nwetobcsnglo
      INTEGER nwetobcsn(nsx, nsy, nr, nobcs)
      INTEGER nwetobcsnglo(nr, nobcs)
      COMMON /controlvars_i_obcss/ nwetobcss, nwetobcssglo
      INTEGER nwetobcss(nsx, nsy, nr, nobcs)
      INTEGER nwetobcssglo(nr, nobcs)
      COMMON /controlvars_i_obcsw/ nwetobcsw, nwetobcswglo
      INTEGER nwetobcsw(nsx, nsy, nr, nobcs)
      INTEGER nwetobcswglo(nr, nobcs)
      COMMON /controlvars_i_obcse/ nwetobcse, nwetobcseglo
      INTEGER nwetobcse(nsx, nsy, nr, nobcs)
      INTEGER nwetobcseglo(nr, nobcs)
C
C     This is moved from ecco_local_params.h, because it is the only
C     parameter used (by obcs ctrl parameters)
      COMMON /ecco_data_errfile/ data_errfile
      CHARACTER*(max_len_fnam) data_errfile
C
C
C
C
C
C     ==================================================================
C     HEADER COST
C     ==================================================================
C
C     o Header for model-data comparison.
C
C     The individual cost function contributions are multiplied by
C     factors mult_"var" which allow to switch off these contributions
C     without removing them in the adjoint code. This is useful for
C     doing tests with the adjoint and perhaps useful in assimilation
C     experiments where individual contributions are successively
C     switched on. For future applications it would be better to place
C     the initialisation of the multipliers somewhere else, for example
C     in a namelist, which is read in at the start of the model.
C
C     started: Christian Eckert eckert@mit.edu  24-Feb-1999
C     changed: Christian Eckert eckert@mit.edu
C     heimbach@mit.edu 05-Nov-2003 Modularize cost package
C
C     ==================================================================
C     HEADER COST
C     ==================================================================
C
C     The cost function, its contributions, and multipliers:
C     ======================================================
C
C     fc         - Final cost function.
C     glofc      - contributions from global mean constraints
C     mult_"var" - multipliers for the individual cost
C                  function contributions.
C
      COMMON /cost_r/ fc, glofc
      COMMON /cost_r_b/ fcb
      REAL*8 fc
      REAL*8 fcb
      REAL*8 glofc
C
C     tile_fc   :: Final cost function contribution from this tile
      COMMON /cost_final_r/ tile_fc
      REAL*8 tile_fc(nsx, nsy)
      REAL*8 tile_fcb(nsx, nsy)
C
      COMMON /cost_objf/ objf_atl, objf_test, objf_tracer, objf_entropy
     +, objf_t_misfit, objf_eflux
      COMMON /cost_objf_b/ objf_atlb
C
      REAL*8 objf_atl(nsx, nsy)
      REAL*8 objf_atlb(nsx, nsy)
      REAL*8 objf_test(nsx, nsy)
      REAL*8 objf_tracer(nsx, nsy)
      REAL*8 objf_entropy(nsx, nsy)
      REAL*8 objf_t_misfit(nsx, nsy)
      REAL*8 objf_eflux(nsx, nsy)
C
      COMMON /cost_param_r/ lastinterval
      REAL*8 lastinterval
C
C
C
      COMMON /cost_fname_c/ cost_mask_file
      CHARACTER*(max_len_fnam) cost_mask_file
C
      COMMON /cost_aux_r/ mult_atl, mult_test, mult_tracer, mult_entropy
     +, mult_t_misfit, mult_eflux, multtheta, multsalt, multuvel, 
     +multvvel, multetan
C
      REAL*8 mult_atl
      REAL*8 mult_test
      REAL*8 mult_tracer
      REAL*8 mult_entropy
      REAL*8 mult_t_misfit
      REAL*8 mult_eflux
      REAL*8 multtheta
      REAL*8 multsalt
      REAL*8 multuvel
      REAL*8 multvvel
      REAL*8 multetan
C
C
      COMMON /cost_mean_r/ cmeantheta, cmeanuvel, cmeanvvel, 
     +cmeanthetauvel, cmeanthetavvel
      COMMON /cost_mean_r_b/ cmeanvvelb
      REAL*8 cmeantheta(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 cmeanuvel(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 cmeanvvel(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 cmeanvvelb(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 cmeanthetauvel(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 cmeanthetavvel(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
C
C     ==================================================================
C     END OF HEADER COST
C     ==================================================================
C
C
CBOP
C     !ROUTINE: GMREDI.h
C     !INTERFACE:
C     #include "GMREDI.h"
C
C     !DESCRIPTION:
C     *================================================================*
C     | GMREDI.h
C     | o Header file defining GM/Redi parameters and variables
C     *================================================================*
CEOP
C
C--   Numerical Constant
      REAL*8 op5
      REAL*8 op25
      PARAMETER (op5=0.5d0)
      PARAMETER (op25=0.25d0)
C
C--   COMMON /GM_PARAMS_L/ GM/Redi Logical-type parameters
C     GM_AdvForm       :: use Advective Form (instead of Skew-Flux form)
C     GM_AdvSeparate   :: do separately advection by Eulerian and Bolus velocity
C     GM_useBVP        :: use Boundary-Value-Problem method for Bolus transport
C     GM_useSubMeso    :: use parameterization of mixed layer (Sub-Mesoscale)
C                         eddies
C     GM_ExtraDiag     :: use Extra Off-Diagonal tensor elements (Kuz,Kvz)
C     GM_InMomAsStress :: apply GM as a stress in momentum Eq.
C     GM_MNC           ::
C     GM_MDSIO         ::
C     GM_useBatesK3d     :: use Bates etal (2014) calculation for 3-d K
C     GM_Bates_beta_eq_0 :: Ignores the beta term when calculating grad(q)
C     GM_Bates_ThickSheet:: Use a thick PV sheet
C     GM_Bates_surfK     :: Imposes a constant K in the surface layer
C     GM_Bates_constRedi :: Imposes a constant K for the Redi diffusivity
C     GM_Bates_use_constK:: Imposes a constant K for the eddy transport
C     GM_Bates_smooth    :: Expand PV closure in terms of baroclinic modes
C                           (=.FALSE. for debugging only!)
C     GM_useLeithQG    :: add Leith QG viscosity to GMRedi tensor
C     GM_useGEOM       :: use the GEOME formulation to calculate kgm
C     GEOM_vert_struc  :: allow for N2 structure function
C
      LOGICAL gm_advform
      LOGICAL gm_advseparate
      LOGICAL gm_usebvp
      LOGICAL gm_usesubmeso
      LOGICAL gm_extradiag
      LOGICAL gm_inmomasstress
      LOGICAL gm_mnc
      LOGICAL gm_mdsio
      LOGICAL gm_usebatesk3d
      LOGICAL gm_bates_thicksheet
      LOGICAL gm_bates_surfk
      LOGICAL gm_bates_constredi
      LOGICAL gm_bates_use_constk
      LOGICAL gm_bates_beta_eq_0
      LOGICAL gm_bates_smooth
      LOGICAL gm_useleithqg
      LOGICAL gm_usegeom
      LOGICAL geom_vert_struc
      COMMON /gm_params_l/ gm_advform, gm_advseparate, gm_usebvp, 
     +gm_usesubmeso, gm_extradiag, gm_mnc, gm_mdsio, gm_inmomasstress, 
     +gm_usebatesk3d, gm_bates_smooth, gm_bates_use_constk, 
     +gm_bates_beta_eq_0, gm_bates_thicksheet, gm_bates_surfk, 
     +gm_bates_constredi, gm_useleithqg, gm_usegeom, geom_vert_struc
C
C--   GM/Redi Integer-type parameters
C     GM_BVP_modeNumber :: vertical mode number used for speed "c" in BVP transport
C     GM_Bates_NModes :: number of vertical modes used for calculating Xi in GM_BatesK3d
      INTEGER gm_bvp_modenumber
      INTEGER gm_bates_nmodes
      PARAMETER (gm_bates_nmodes=6)
      COMMON /gm_params_i/ gm_bvp_modenumber
C
C--   COMMON /GM_PARAMS_C/ GM/Redi Character-type parameters
C     GM_taper_scheme :: select which tapering/clipping scheme to use
C     GM_iso2dFile :: input file for 2.D horiz scaling of Isopycnal diffusivity
C     GM_iso1dFile :: input file for 1.D vert. scaling of Isopycnal diffusivity
C     GM_bol2dFile :: input file for 2.D horiz scaling of Thickness diffusivity
C     GM_bol1dFile :: input file for 1.D vert. scaling of Thickness diffusivity
C     GM_K3dRediFile :: input file for background 3.D Isopycal(Redi) diffusivity
C     GM_K3dGMFile   :: input file for background 3.D Thickness (GM) diffusivity
C
      CHARACTER*40 gm_taper_scheme
      CHARACTER*(max_len_fnam) gm_iso2dfile
      CHARACTER*(max_len_fnam) gm_iso1dfile
      CHARACTER*(max_len_fnam) gm_bol2dfile
      CHARACTER*(max_len_fnam) gm_bol1dfile
      CHARACTER*(max_len_fnam) gm_k3dredifile
      CHARACTER*(max_len_fnam) gm_k3dgmfile
      COMMON /gm_params_c/ gm_taper_scheme, gm_iso2dfile, gm_iso1dfile, 
     +gm_bol2dfile, gm_bol1dfile, gm_k3dredifile, gm_k3dgmfile
C
C--   COMMON /GM_PARAMS_R/ GM/Redi real-type parameters
C     GM_isopycK       :: Isopycnal diffusivity [m^2/s] (Redi-tensor)
C     GM_background_K  :: Thickness diffusivity [m^2/s] (GM bolus transport)
C     GM_maxSlope      :: maximum slope (tapering/clipping) [-]
C     GM_Kmin_horiz    :: minimum horizontal diffusivity [m^2/s]
C     GM_Small_Number  :: epsilon used in computing the slope
C     GM_slopeSqCutoff :: slope^2 cut-off value
C     GM_Scrit, GM_Sd  :: parameter for 'dm95' & 'ldd97' tapering fct
C     GM_isoFac_calcK  :: add fraction of  dynamically computed variable K,
C                         e.g. Visbeck, also to Redi tensor (default = 1.)
C-    Transition layer thickness definition:
C     GM_facTrL2dz   :: minimum Trans. Layer Thick. as a factor of local dz
C     GM_facTrL2ML   :: maximum Trans. Layer Thick. as a factor of Mix-Layer Depth
C     GM_maxTransLay :: maximum Trans. Layer Thick. [m]
C-    Boundary-Value-Problem method parameters:
C     GM_BVP_cMin    :: minimum value for wave speed parameter "c" in BVP [m/s]
C-    mixed layer (Sub-Mesoscale) eddies parameterization:
C     subMeso_Ceff   :: efficiency coefficient of Mixed-Layer Eddies [-]
C     subMeso_invTau :: inverse of mixing time-scale in sub-meso parameteriz. [s^-1]
C     subMeso_LfMin  :: minimum value for length-scale "Lf" [m]
C     subMeso_Lmax   :: maximum horizontal grid-scale length [m]
C-    Variable K parameters for Visbeck etal (1997) scheme:
C-    Variable K parameters for Marshall etal (2012) GEOM scheme:
C     GEOM_alpha       :: non-dim eddy efficiency param (=<1 in QG)
C     GEOM_lmbda       :: lin eddy energy dissipation rate
C     GEOM_ini_EKE     :: initial value for depth-int eddy kinetic energy
C     GEOM_diffKh_EKE  :: depth-int param eddy energy diffusion coeff
C     GEOM_minval_K    :: lower bound on diffusivity
C     GEOM_maxval_K    :: upper bound on diffusivity
C     GEOM_vert_struc_min   :: lower bound on N2/Nref vertical structure func
C     GEOM_vert_struc_max   :: upper bound on N2/Nref vertical structure func
C-    Variable K parameters for PV diffusion based, Bates etal (2014) scheme:
C     GM_Bates_gamma   :: mixing efficiency for 3D eddy diffusivity [-]
C     GM_Bates_b1      :: an empirically determined constant of O(1)
C     GM_Bates_EadyMinDepth :: upper depth for Eady calculation
C     GM_Bates_EadyMaxDepth :: lower depth for Eady calculation
C     GM_Bates_Lambda  ::
C     GM_Bates_smallK  ::
C     GM_Bates_maxK    :: Upper bound on the diffusivity
C     GM_Bates_constK  :: Constant diffusivity to use when GM_useBatesK3d=T and
C                         GM_Bates_use_constK=T and/or GM_Bates_constRedi=T
C     GM_Bates_maxC    ::
C     GM_Bates_Rmax    :: Length scale upper bound used for calculating urms
C     GM_Bates_Rmin    :: Length scale lower bound for calc. the eddy radius
C     GM_Bates_minCori :: minimum value for f (prevents Pb near the equator)
C     GM_Bates_minN2   :: minimum value for the square of the buoyancy frequency
C     GM_Bates_surfMinDepth :: minimum value for the depth of the surface layer
C     GM_Bates_vecFreq :: Frequency at which to update the baroclinic modes
C     GM_Bates_minRenorm :: minimum value for the renormalisation factor
C     GM_Bates_maxRenorm :: maximum value for the renormalisation factor
      REAL*8 gm_isopyck
      REAL*8 gm_background_k
      REAL*8 gm_maxslope
      REAL*8 gm_kmin_horiz
      REAL*8 gm_small_number
      REAL*8 gm_slopesqcutoff
      REAL*8 gm_scrit, gm_sd
      REAL*8 gm_isofac_calck
      REAL*8 gm_factrl2dz
      REAL*8 gm_factrl2ml
      REAL*8 gm_maxtranslay
      REAL*8 gm_bvp_cmin
      REAL*8 submeso_ceff
      REAL*8 submeso_invtau
      REAL*8 submeso_lfmin
      REAL*8 submeso_lmax
      REAL*8 gm_visbeck_alpha
      REAL*8 gm_visbeck_length
      REAL*8 gm_visbeck_depth
      REAL*8 gm_visbeck_mindepth
      REAL*8 gm_visbeck_maxslope
      REAL*8 gm_visbeck_minval_k
      REAL*8 gm_visbeck_maxval_k
      REAL*8 geom_alpha
      REAL*8 geom_lmbda
      REAL*8 geom_ini_eke
      REAL*8 geom_diffkh_eke
      REAL*8 geom_minval_k
      REAL*8 geom_maxval_k
      REAL*8 geom_vert_struc_min
      REAL*8 geom_vert_struc_max
      REAL*8 gm_bates_gamma
      REAL*8 gm_bates_b1
      REAL*8 gm_bates_eadymindepth
      REAL*8 gm_bates_eadymaxdepth
      REAL*8 gm_bates_lambda
      REAL*8 gm_bates_smallk
      REAL*8 gm_bates_maxk
      REAL*8 gm_bates_constk
      REAL*8 gm_bates_maxc
      REAL*8 gm_bates_rmax
      REAL*8 gm_bates_rmin
      REAL*8 gm_bates_mincori
      REAL*8 gm_bates_minn2
      REAL*8 gm_bates_surfmindepth
      REAL*8 gm_bates_vecfreq
      REAL*8 gm_bates_minrenorm
      REAL*8 gm_bates_maxrenorm
      COMMON /gm_params_rl/ gm_isopyck, gm_background_k, gm_maxslope, 
     +gm_kmin_horiz, gm_small_number, gm_slopesqcutoff, gm_scrit, gm_sd
     +, gm_isofac_calck, gm_factrl2dz, gm_factrl2ml, gm_maxtranslay, 
     +gm_bvp_cmin, submeso_ceff, submeso_invtau, submeso_lfmin, 
     +gm_visbeck_alpha, gm_visbeck_length, gm_visbeck_depth, 
     +gm_visbeck_mindepth, gm_visbeck_maxslope, gm_visbeck_minval_k, 
     +gm_visbeck_maxval_k, geom_alpha, geom_lmbda, geom_ini_eke, 
     +geom_diffkh_eke, geom_minval_k, geom_maxval_k, geom_vert_struc_min
     +, geom_vert_struc_max, gm_bates_gamma, gm_bates_b1, 
     +gm_bates_eadymindepth, gm_bates_eadymaxdepth, gm_bates_lambda, 
     +gm_bates_smallk, gm_bates_maxk, gm_bates_constk, gm_bates_maxc, 
     +gm_bates_rmax, gm_bates_rmin, gm_bates_mincori, gm_bates_minn2, 
     +gm_bates_surfmindepth, gm_bates_vecfreq, gm_bates_minrenorm, 
     +gm_bates_maxrenorm
C
      COMMON /gm_params_rs/ submeso_lmax
C
C--   COMMON /GM_DERIVED_PAR/ other GM/Redi parameters
C     (derived from previous block and not directly user configured)
      REAL*8 gm_rmaxslope
      REAL*8 gm_skewflx
      REAL*8 gm_bvp_rmodenumber
      REAL*8 gm_bvp_chat2min
      COMMON /gm_derived_par/ gm_rmaxslope, gm_skewflx, 
     +gm_bvp_rmodenumber, gm_bvp_chat2min
C
C--   COMMON /GM_COEFFICIENTS/ GM/Redi scaling coefficients
C     defined at grid-cell center (tracer location)
C     GM_isoFac2d  :: 2.D horiz scaling factor [-] of Isopycnal diffusivity
C     GM_bolFac2d  :: 2.D horiz scaling factor [-] of Thickness diffusivity
C     GM_isoFac1d  :: 1.D vert. scaling factor [-] of Isopycnal diffusivity
C     GM_bolFac1d  :: 1.D vert. scaling factor [-] of Thickness diffusivity
      REAL*8 gm_isofac2d(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 gm_bolfac2d(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 gm_isofac1d(nr)
      REAL*8 gm_bolfac1d(nr)
      COMMON /gm_coefficients/ gm_isofac2d, gm_bolfac2d, gm_isofac1d, 
     +gm_bolfac1d
C
C
C---+----1----+----2----+----3----+----4----+----5----+----6----+----7-|--+----|
C---  GM/Redi tensor elements
C
C     Bottom row of tensor corresponds to W points
C     Kwx :: K_31 element of GM/Redi tensor, X direction at W point
C     Kwy :: K_32 element of GM/Redi tensor, Y direction at W point
C     Kwz :: K_33 element of GM/Redi tensor, Z direction at W point
      REAL*8 kwx(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 kwxb(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 kwy(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 kwyb(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 kwz(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 kwzb(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      COMMON /gm_wtensor/ kwx, kwy, kwz
      COMMON /gm_wtensor_b/ kwxb, kwyb, kwzb
C
C     Horizontal part of the tensor
C     Kux :: K_11 element of GM/Redi tensor, X direction at U point
C     Kvy :: K_22 element of GM/Redi tensor, Y direction at V point
      REAL*8 kux(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 kuxb(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 kvy(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 kvyb(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      COMMON /gm_hortensor/ kux, kvy
      COMMON /gm_hortensor_b/ kuxb, kvyb
C
C     First/second rows of tensor corresponds to U/V points
C     Kuz :: K_13 element of GM/Redi tensor, Z direction at U point
C     Kvz :: K_23 element of GM/Redi tensor, Z direction at V point
      REAL*8 kuz(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 kuzb(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 kvz(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 kvzb(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      COMMON /gm_uvtensor/ kuz, kvz
      COMMON /gm_uvtensor_b/ kuzb, kvzb
C
C     GM advection formulation: bolus velocities are derived from 2
C        streamfunctions PsiX and PsiY :
      REAL*8 gm_psix(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 gm_psixb(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 gm_psiy(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 gm_psiyb(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      COMMON /gm_bolus/ gm_psix, gm_psiy
      COMMON /gm_bolus_b/ gm_psixb, gm_psiyb
C
C
C
C
C
C
C     *==========================================================*
C     | GMREDI_TAVE.h
C     | o Header for GM-Redi time-average output
C     *==========================================================*
C
C
C
C     Storage arrays for time-averages
      REAL*8 gm_timeave(nsx, nsy)
      REAL*8 gm_kwx_t(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 gm_kwy_t(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 gm_kwz_t(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      COMMON /gm_tave_vars/ gm_timeave, gm_kwx_t, gm_kwy_t, gm_kwz_t
C
C
      REAL*8 gm_psixtave(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 gm_psiytave(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      COMMON /gm_tave_psi_b/ gm_psixtave, gm_psiytave
C
C
C
CEH3 ;;; Local Variables: ***
CEH3 ;;; mode:fortran ***
CEH3 ;;; End: ***
C
CBOP
C !ROUTINE: KPP.h
C
C !DESCRIPTION: \bv
C     /==========================================================C     | KPP.h                                                   
C |
C     | o Basic header for KPP vertical mixing parameterization. |
C     |   Contains all KPP field declarations.                   |
C     \==========================================================/
C
C-----------------------------------------------------------------------
C
C Time varying parameters computed by subroutine kpp_calc
C     KPPviscAz  - Vertical eddy viscosity coefficient                (m^2/s)
C     KPPdiffKzS - Vertical diffusion coefficient for salt and tracers(m^2/s)
C     KPPdiffKzT - Vertical diffusion coefficient for heat            (m^2/s)
C     KPPghat    - Nonlocal transport coefficient                     (s/m^2)
C     KPPhbl     - Mixing layer depth                                     (m)
C     KPPfrac    - Fraction of short-wave flux heating the mixing layer
C     KPPplumefrac - Fraction of saltplume penetrating mixing layer
C
C-----------------------------------------------------------------------
C \ev
CEOP
C
      REAL*8 kppviscaz(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 kppviscazb(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 kppdiffkzs(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 kppdiffkzsb(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 kppdiffkzt(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 kppdiffkztb(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 kppghat(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 kppghatb(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 kpphbl(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 kpphblb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 kppfrac(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 kppfracb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      COMMON /kpp/ kppviscaz, kppdiffkzt, kppdiffkzs, kppghat, kpphbl
      COMMON /kpp_b/ kppviscazb, kppdiffkztb, kppdiffkzsb, kppghatb, 
     +kpphblb
      REAL*8 kppplumefrac(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 kppplumefracb(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      COMMON /kpp_short1/ kppplumefrac
      COMMON /kpp_short1_b/ kppplumefracb
      COMMON /kpp_short/ kppfrac
      COMMON /kpp_short_b/ kppfracb
C
C
CEH3 ;;; Local Variables: ***
CEH3 ;;; mode:fortran ***
CEH3 ;;; End: ***
C#  include "KPP_PARAMS.h"
C
C     Package-specific Options & Macros go here
C
C
C
CBOP
C     !ROUTINE: TIMEAVE_STATV.h
C     !INTERFACE:
C     include "TIMEAVE_STATV.h"
C     !DESCRIPTION: \bw
C     *================================================================*
C     | TIMEAVE_STATV.h
C     | o Time averages of model state-variables
C     |   (common block TAVE_STATEVARS)
C     *================================================================*
C     | Time average of state variables is (generally) centered on the
C     |  middle of the time step (time average interval = timeAve_half)
C     | Time average of intermediate and tendency variables is centered
C     |  on the time step (time average interval=timeAve_full)
C     *================================================================*
C     \ev
CEOP
C
C     TimeAve_*    :: time of temporal integration (s) *** for each thread ***
C     timeAve_half :: half time_step multiple (used for state variables)
C     timeAve_full :: full time_step multiple (used for for intermediate var.)
C     uFluxtave    :: zonal surface wind stress (N/m^2,
C                     >0 for increase in uVel, i=1 held at western face)
C     vFluxtave    :: meridional surface wind stress (N/m^2,
C                     >0 for increase in vVel, j=1 held at southern face)
C     tFluxtave    :: net surface heat flux (W/m^2, >0 for increase in theta)
C     sFluxtave    :: net surface salt flux (g/m^2/s, >0 for increase in salt)
C     etatave      :: surface displacement (r unit, i.e. ocean:z, atmos:p)
C     uVeltave     :: zonal velocity (m/s, i=1 held at western face)
C     vVeltave     :: meridional velocity (m/s, j=1 held at southern face)
C     wVeltave     :: vertical velocity ([r]/s, i.e.: ocean:m/s atmos:Pa/s)
C     thetatave    :: potential temperature (oC, held at pressure/tracer point)
C     salttave     :: salinity (g/kg, held at pressure/tracer point)
C     Eta2tave     :: eta * eta
C     TTtave       :: theta * theta
C     UUtave       :: uVel * uVel (used to compute the averaged KE)
C     VVtave       :: vVel * vVel (used to compute the averaged KE)
C     UVtave       :: uVel * vVel (at vorticity point, i.e. grid-corner)
C     KEtave       :: Kinetic Energy
C     UTtave       :: uVel * theta (* hFacW)
C     VTtave       :: vVel * theta (* hFacS)
C     WTtave       :: wVel * theta
C     UStave       :: uVel * salt (* hFacW)
C     VStave       :: vVel * salt (* hFacS)
C     WStave       :: wVel * salt
C     tDiffRtave   :: vertical diffusion flux of Temperature (theta)
C     uZetatave    :: uVel*Relativ_Vorticity_3 (computed at v point)
C     vZetatave    :: vVel*Relativ_Vorticity_3 (computed at u point)
C     phiHydtave   :: Hydrostatic (ocean) pressure / (atmos) geo- Potential
C     phiHydLowtave:: Hydrostatic (ocean) pressure / (atmos) geo- Potential
C                     at the fixed boundary: (ocean) bottom pressure
C                     (atmos) geo- Potential
C     ConvectCountTave :: Average number of convective adjustment event
C
      COMMON /tave_time/ timeave_half, timeave_full
      REAL*8 timeave_half(nsx, nsy)
      REAL*8 timeave_full(nsx, nsy)
C
      COMMON /tave_statevars/ ufluxtave, vfluxtave, tfluxtave, sfluxtave
     +, etatave, uveltave, vveltave, wveltave, thetatave, salttave, 
     +phihydlowtave, uttave, vttave, wttave, ustave, vstave, wstave, 
     +eta2tave, tttave, uutave, vvtave, uvtave, tdiffrtave, uzetatave, 
     +vzetatave, phihydtave, phihydlow2tave, convectcounttave
      REAL*8 ufluxtave(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 vfluxtave(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 tfluxtave(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 sfluxtave(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 etatave(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 uveltave(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 vveltave(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 wveltave(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 thetatave(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 salttave(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 phihydlowtave(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 uttave(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 vttave(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 wttave(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 ustave(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 vstave(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 wstave(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 eta2tave(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 tttave(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 uutave(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 vvtave(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 uvtave(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 tdiffrtave(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 uzetatave(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 vzetatave(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 phihydtave(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 phihydlow2tave(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 convectcounttave(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy
     +       )
C
C     hUtave       :: average zonal flow (=hFacW*uVel) (still in m/s !)
C     hVtave       :: average merid.flow (=hFacS*vVel) (still in m/s !)
C     hFacCtave    :: average thickness fraction of open water, Center
C     hFacWtave    :: average thickness fraction of open water, West side
C     hFacStave    :: average thickness fraction of open water, South side
C
      COMMON /tave_thickness/ hutave, hvtave
C    &            , hFacCtave, hFacWtave, hFacStave
      REAL*8 hutave(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 hvtave(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
C     Real*8  hFacCtave(1-OLx:sNx+OLx,1-OLy:sNy+OLy,Nr,nSx,nSy)
C     Real*8  hFacWtave(1-OLx:sNx+OLx,1-OLy:sNy+OLy,Nr,nSx,nSy)
C     Real*8  hFacStave(1-OLx:sNx+OLx,1-OLy:sNy+OLy,Nr,nSx,nSy)
C
C
C     ==================================================================
C     HEADER EXF_PARAM.h
C     ==================================================================
C
C     o Header file for the surface flux data. Used by the external
C       forcing package.
C
C     started: Christian Eckert eckert@mit.edu  30-Jun-1999
C
C     changed: Christian Eckert eckert@mit.edu  14-Jan-2000
C              - Restructured the original version in order to have a
C                better interface to the MITgcmUV.
C
C              Christian Eckert eckert@mit.edu  12-Feb-2000
C              - Changed some variables names (package prefix: exf_)
C
C              Patrick Heimbach, heimbach@mit.edu  04-May-2000
C              - included exf_iprec to enable easy
C                switch between 32bit/64 bit data format
C
C              Patrick Heimbach, heimbach@mit.edu  01-May-2001
C              - added obcs parameters
C
C     mods for pkg/seaice: menemenlis@jpl.nasa.gov 20-Dec-2002
C
C     ==================================================================
C     HEADER EXF_PARAM.h
C     ==================================================================
C
C     Repeat period for forcing fields (s)
C     For example, for yearly repeat period: repeatPeriod=31556925.
C     Note: this option is not yet coded for sub-daily
C           forcing and for leap years but this limitation can be
C           circumvented by using a 4-year (1461-day) repeatPeriod
      REAL*8 repeatperiod
C
C     useExfCheckRange   :: check range of input/output field values
C     useExfYearlyFields :: when set, automatically add extension
C                           _YEAR to input file names; the yearly files need
C                           to contain all the records that pertain to
C                           a particular year, including day 1, hour zero
C     twoDigitYear       :: when set, use 2-digit year extension YR
C                           instead of _YEAR for useExfYearlyFields
C    useOBCSYearlyFields :: when reading Open-Boundary values, assume yearly
C                           climatology (def=false)
C     readStressOnAgrid  :: read wind-streess located on model-grid,
C                            A-grid position
C     rotateStressOnAgrid:: rotate from zonal/meridional components to
C                           U/V components
C     readStressOnCgrid  :: read wind-streess located on model-grid, C-grid
C                           position
C     stressIsOnCgrid    :: ustress & vstress are positioned on Arakawa C-grid
C     useAtmWind         :: use wind vector (uwind/vwind) to compute
C                           the wind stress (ustress/vstress)
C     useRelativeWind    :: Subtract U/VVEL or U/VICE from U/VWIND before
C                           computing U/VSTRESS
C     noNegativeEvap     :: prevent negative evap (= sea-surface condensation)
C     useStabilityFct_overIce :: over sea-ice, compute turbulent transfert
C                           coeff. function of stability (like over
C                           open ocean) rather than using fixed Coeff.
C     diags_opOceWeighted:: weight surface flux diagnostics with open-ocean
C                           fraction
C     useExfZenAlbedo    :: ocean albedo (direct part) may vary
C                           with zenith angle (see select_ZenAlbedo)
C     select_ZenAlbedo   :: switch to different methods to compute albedo
C                           (direct part)
C                        :: 0 just use exf_albedo
C                        :: 1 use daily mean albedo from exf_zenithangle_table.F
C                        :: 2 use daily mean albedo computed as in pkg/aim_v23
C                        :: 3 use daily variable albedo
C     useExfZenIncoming  :: compute incoming solar radiation along with
C                           zenith angle
C     exf_debugLev       :: select message printing to STDOUT (e.g., when
C                           read rec)
C     exf_monFreq        :: Monitor Frequency (s) for EXF
C     exf_adjMonFreq     :: Monitor Frequency (s) for AD exf variables
C     exf_adjMonSelect   :: select group of exf AD-variables to monitor
C                           =0 : none
C                           =1 : ocean forcing fu, fv, qnet, empmr (default)
C                           =2 : + atmospheric forcing fields (u/vwind,
C                                  atemp, lwdown, precip, etc.)
C                           =3 : + derived forcing fields (u/vstress,
C                                  h/sflux, wspeed)
C
      LOGICAL useexfcheckrange
      LOGICAL useexfyearlyfields, twodigityear
      LOGICAL useobcsyearlyfields
      LOGICAL readstressonagrid
      LOGICAL rotatestressonagrid
      LOGICAL readstressoncgrid
      LOGICAL stressisoncgrid
      LOGICAL useatmwind
      LOGICAL userelativewind
      LOGICAL nonegativeevap
      LOGICAL usestabilityfct_overice
      LOGICAL diags_opoceweighted
C
      LOGICAL useexfzenalbedo
      INTEGER select_zenalbedo
      LOGICAL useexfzenincoming
C
      INTEGER exf_debuglev
      REAL*8 exf_monfreq
      REAL*8 exf_adjmonfreq
      INTEGER exf_adjmonselect
C
C     Drag coefficient scaling factor
      REAL*8 exf_scal_bulkcdn
C
C     Maximum absolute windstress, used to reset unreastically high
C     data values
      REAL*8 windstressmax
C
C     freezing temperature is the minimum temperature allowed, used
C     to reset climatological temperatures fields where they have
C     values below climtempfreeze
      REAL*8 climtempfreeze
C
C---+----1----+----2----+----3----+----4----+----5----+----6----+----7-|--+----|
C
C     Description of contents of surface boundary condition files
C     Note: fieldperiod=0 means input file is one time-constant field
C           fieldperiod=-12 means input file contains 12 monthly means
C-    for each field:
C     {fld}file       :: file-name for this field
C     {fld}startdate1 :: field starting date (YYYYMMDD)
C     {fld}startdate1 :: field starting date (YYYYMMDD)
C     {fld}startdate2 :: field starting date (HHMMSS)
C     {fld}StartTime  :: corresponding starting time (in sec) for this field
C     {fld}period     :: time period (in sec) between 2 reccords
C     {fld}RepCycle   :: time duration of a repeating cycle
C     {fld}const      :: uniform default field value
C
      INTEGER hfluxstartdate1
      INTEGER hfluxstartdate2
      REAL*8 hfluxstarttime
      REAL*8 hfluxperiod
      REAL*8 hfluxrepcycle
      REAL*8 hfluxconst
      REAL*8 hflux_exfremo_intercept
      REAL*8 hflux_exfremo_slope
      CHARACTER*1 hfluxmask
C
      INTEGER atempstartdate1
      INTEGER atempstartdate2
      REAL*8 atempstarttime
      REAL*8 atempperiod
      REAL*8 atemprepcycle
      REAL*8 atempconst
      REAL*8 atemp_exfremo_intercept
      REAL*8 atemp_exfremo_slope
      CHARACTER*1 atempmask
C
      INTEGER aqhstartdate1
      INTEGER aqhstartdate2
      REAL*8 aqhstarttime
      REAL*8 aqhperiod
      REAL*8 aqhrepcycle
      REAL*8 aqhconst
      REAL*8 aqh_exfremo_intercept
      REAL*8 aqh_exfremo_slope
      CHARACTER*1 aqhmask
C
      INTEGER hs_startdate1
      INTEGER hs_startdate2
      REAL*8 hs_starttime
      REAL*8 hs_period
      REAL*8 hs_repcycle
      REAL*8 hs_const
      REAL*8 hs_exfremo_intercept
      REAL*8 hs_exfremo_slope
      CHARACTER*1 hs_mask
C
      INTEGER hl_startdate1
      INTEGER hl_startdate2
      REAL*8 hl_starttime
      REAL*8 hl_period
      REAL*8 hl_repcycle
      REAL*8 hl_const
      REAL*8 hl_exfremo_intercept
      REAL*8 hl_exfremo_slope
      CHARACTER*1 hl_mask
C
      INTEGER sfluxstartdate1
      INTEGER sfluxstartdate2
      REAL*8 sfluxstarttime
      REAL*8 sfluxperiod
      REAL*8 sfluxrepcycle
      REAL*8 sfluxconst
      REAL*8 sflux_exfremo_intercept
      REAL*8 sflux_exfremo_slope
      CHARACTER*1 sfluxmask
C
      INTEGER evapstartdate1
      INTEGER evapstartdate2
      REAL*8 evapstarttime
      REAL*8 evapperiod
      REAL*8 evaprepcycle
      REAL*8 evapconst
      REAL*8 evap_exfremo_intercept
      REAL*8 evap_exfremo_slope
      CHARACTER*1 evapmask
C
      INTEGER precipstartdate1
      INTEGER precipstartdate2
      REAL*8 precipstarttime
      REAL*8 precipperiod
      REAL*8 preciprepcycle
      REAL*8 precipconst
      REAL*8 precip_exfremo_intercept
      REAL*8 precip_exfremo_slope
      CHARACTER*1 precipmask
C
      INTEGER snowprecipstartdate1
      INTEGER snowprecipstartdate2
      REAL*8 snowprecipstarttime
      REAL*8 snowprecipperiod
      REAL*8 snowpreciprepcycle
      REAL*8 snowprecipconst
      REAL*8 snowprecip_exfremo_intercept
      REAL*8 snowprecip_exfremo_slope
      CHARACTER*1 snowprecipmask
C
      INTEGER runoffstartdate1
      INTEGER runoffstartdate2
      REAL*8 runoffstarttime
      REAL*8 runoffperiod
      REAL*8 runoffrepcycle
      REAL*8 runoffconst
      REAL*8 runoff_exfremo_intercept
      REAL*8 runoff_exfremo_slope
      CHARACTER*1 runoffmask
C
      REAL*8 runoftempconst
      REAL*8 runoftemp_exfremo_intercept
      REAL*8 runoftemp_exfremo_slope
C
      INTEGER saltflxstartdate1
      INTEGER saltflxstartdate2
      REAL*8 saltflxstarttime
      REAL*8 saltflxperiod
      REAL*8 saltflxrepcycle
      REAL*8 saltflxconst
      REAL*8 saltflx_exfremo_intercept
      REAL*8 saltflx_exfremo_slope
      CHARACTER*1 saltflxmask
C
      INTEGER ustressstartdate1
      INTEGER ustressstartdate2
      REAL*8 ustressstarttime
      REAL*8 ustressperiod
      REAL*8 ustressrepcycle
      REAL*8 ustressconst
      REAL*8 ustress_exfremo_intercept
      REAL*8 ustress_exfremo_slope
      CHARACTER*1 ustressmask
C
      INTEGER vstressstartdate1
      INTEGER vstressstartdate2
      REAL*8 vstressstarttime
      REAL*8 vstressperiod
      REAL*8 vstressrepcycle
      REAL*8 vstressconst
      REAL*8 vstress_exfremo_intercept
      REAL*8 vstress_exfremo_slope
      CHARACTER*1 vstressmask
C
      INTEGER uwindstartdate1
      INTEGER uwindstartdate2
      REAL*8 uwindstarttime
      REAL*8 uwindperiod
      REAL*8 uwindrepcycle
      REAL*8 uwindconst
      REAL*8 uwind_exfremo_intercept
      REAL*8 uwind_exfremo_slope
      CHARACTER*1 uwindmask
C
      INTEGER vwindstartdate1
      INTEGER vwindstartdate2
      REAL*8 vwindstarttime
      REAL*8 vwindperiod
      REAL*8 vwindrepcycle
      REAL*8 vwindconst
      REAL*8 vwind_exfremo_intercept
      REAL*8 vwind_exfremo_slope
      CHARACTER*1 vwindmask
C
      INTEGER wspeedstartdate1
      INTEGER wspeedstartdate2
      REAL*8 wspeedstarttime
      REAL*8 wspeedperiod
      REAL*8 wspeedrepcycle
      REAL*8 wspeedconst
      REAL*8 wspeed_exfremo_intercept
      REAL*8 wspeed_exfremo_slope
      CHARACTER*1 wspeedmask
C
      INTEGER swfluxstartdate1
      INTEGER swfluxstartdate2
      REAL*8 swfluxstarttime
      REAL*8 swfluxperiod
      REAL*8 swfluxrepcycle
      REAL*8 swfluxconst
      REAL*8 swflux_exfremo_intercept
      REAL*8 swflux_exfremo_slope
      CHARACTER*1 swfluxmask
C
      INTEGER lwfluxstartdate1
      INTEGER lwfluxstartdate2
      REAL*8 lwfluxstarttime
      REAL*8 lwfluxperiod
      REAL*8 lwfluxrepcycle
      REAL*8 lwfluxconst
      REAL*8 lwflux_exfremo_intercept
      REAL*8 lwflux_exfremo_slope
      CHARACTER*1 lwfluxmask
C
      INTEGER swdownstartdate1
      INTEGER swdownstartdate2
      REAL*8 swdownstarttime
      REAL*8 swdownperiod
      REAL*8 swdownrepcycle
      REAL*8 swdownconst
      REAL*8 swdown_exfremo_intercept
      REAL*8 swdown_exfremo_slope
      CHARACTER*1 swdownmask
C
      INTEGER lwdownstartdate1
      INTEGER lwdownstartdate2
      REAL*8 lwdownstarttime
      REAL*8 lwdownperiod
      REAL*8 lwdownrepcycle
      REAL*8 lwdownconst
      REAL*8 lwdown_exfremo_intercept
      REAL*8 lwdown_exfremo_slope
      CHARACTER*1 lwdownmask
C
      INTEGER apressurestartdate1
      INTEGER apressurestartdate2
      REAL*8 apressurestarttime
      REAL*8 apressureperiod
      REAL*8 apressurerepcycle
      REAL*8 apressureconst
      REAL*8 apressure_exfremo_intercept
      REAL*8 apressure_exfremo_slope
      CHARACTER*1 apressuremask
C
      INTEGER tidepotstartdate1
      INTEGER tidepotstartdate2
      REAL*8 tidepotstarttime
      REAL*8 tidepotperiod
      REAL*8 tidepotrepcycle
      REAL*8 tidepotconst
      REAL*8 tidepot_exfremo_intercept
      REAL*8 tidepot_exfremo_slope
      CHARACTER*1 tidepotmask
C
      INTEGER areamaskstartdate1
      INTEGER areamaskstartdate2
      REAL*8 areamaskstarttime
      REAL*8 areamaskperiod
      REAL*8 areamaskrepcycle
      REAL*8 areamasktaurelax
      REAL*8 areamaskconst
      REAL*8 areamask_exfremo_intercept
      REAL*8 areamask_exfremo_slope
      CHARACTER*1 areamaskmask
C
C     Calendar data.
      INTEGER climsststartdate1
      INTEGER climsststartdate2
      REAL*8 climsststarttime
      REAL*8 climsstperiod
      REAL*8 climsstrepcycle
      REAL*8 climssttaurelax
      REAL*8 climsstconst
      REAL*8 climsst_exfremo_intercept
      REAL*8 climsst_exfremo_slope
      CHARACTER*1 climsstmask
C
      INTEGER climsssstartdate1
      INTEGER climsssstartdate2
      REAL*8 climsssstarttime
      REAL*8 climsssperiod
      REAL*8 climsssrepcycle
      REAL*8 climssstaurelax
      REAL*8 climsssconst
      REAL*8 climsss_exfremo_intercept
      REAL*8 climsss_exfremo_slope
      CHARACTER*1 climsssmask
C
      INTEGER climustrstartdate1
      INTEGER climustrstartdate2
      REAL*8 climustrstarttime
      REAL*8 climustrperiod
      REAL*8 climustrrepcycle
      REAL*8 climustrtaurelax
      REAL*8 climustrconst
      REAL*8 climustr_exfremo_intercept
      REAL*8 climustr_exfremo_slope
      CHARACTER*1 climustrmask
C
      INTEGER climvstrstartdate1
      INTEGER climvstrstartdate2
      REAL*8 climvstrstarttime
      REAL*8 climvstrperiod
      REAL*8 climvstrrepcycle
      REAL*8 climvstrtaurelax
      REAL*8 climvstrconst
      REAL*8 climvstr_exfremo_intercept
      REAL*8 climvstr_exfremo_slope
      CHARACTER*1 climvstrmask
C
C-    The following variables are used in conjunction with pkg/obcs
C     to describe S/T/U/V open boundary condition files
      INTEGER obcsnstartdate1
      INTEGER obcsnstartdate2
      INTEGER obcssstartdate1
      INTEGER obcssstartdate2
      INTEGER obcsestartdate1
      INTEGER obcsestartdate2
      INTEGER obcswstartdate1
      INTEGER obcswstartdate2
      REAL*8 obcsnstarttime
      REAL*8 obcsnperiod
      REAL*8 obcsnrepcycle
      REAL*8 obcssstarttime
      REAL*8 obcssperiod
      REAL*8 obcssrepcycle
      REAL*8 obcsestarttime
      REAL*8 obcseperiod
      REAL*8 obcserepcycle
      REAL*8 obcswstarttime
      REAL*8 obcswperiod
      REAL*8 obcswrepcycle
C
C-    The following variables are used in conjunction with pkg/obcs
C     and pkg/seaice to describe area, heff, hsnow, hsalt, uice,
C     and vice open boundary condition files
      INTEGER siobnstartdate1
      INTEGER siobnstartdate2
      INTEGER siobsstartdate1
      INTEGER siobsstartdate2
      INTEGER siobestartdate1
      INTEGER siobestartdate2
      INTEGER siobwstartdate1
      INTEGER siobwstartdate2
      REAL*8 siobnstarttime
      REAL*8 siobnperiod
      REAL*8 siobnrepcycle
      REAL*8 siobsstarttime
      REAL*8 siobsperiod
      REAL*8 siobsrepcycle
      REAL*8 siobestarttime
      REAL*8 siobeperiod
      REAL*8 sioberepcycle
      REAL*8 siobwstarttime
      REAL*8 siobwperiod
      REAL*8 siobwrepcycle
C
C-    File names.
      CHARACTER*128 hfluxfile
      CHARACTER*128 atempfile
      CHARACTER*128 aqhfile
      CHARACTER*128 hs_file
      CHARACTER*128 hl_file
      CHARACTER*128 evapfile
      CHARACTER*128 precipfile
      CHARACTER*128 snowprecipfile
      CHARACTER*128 sfluxfile
      CHARACTER*128 runofffile
      CHARACTER*128 runoftempfile
      CHARACTER*128 saltflxfile
      CHARACTER*128 ustressfile
      CHARACTER*128 vstressfile
      CHARACTER*128 uwindfile
      CHARACTER*128 vwindfile
      CHARACTER*128 wspeedfile
      CHARACTER*128 swfluxfile
      CHARACTER*128 lwfluxfile
      CHARACTER*128 swdownfile
      CHARACTER*128 lwdownfile
      CHARACTER*128 apressurefile
      CHARACTER*128 tidepotfile
      CHARACTER*128 areamaskfile
      CHARACTER*128 climsstfile
      CHARACTER*128 climsssfile
      CHARACTER*128 climustrfile
      CHARACTER*128 climvstrfile
C
      COMMON /exf_param_l/ useexfcheckrange, useexfyearlyfields, 
     +twodigityear, useobcsyearlyfields, useexfzenalbedo, 
     +useexfzenincoming, readstressonagrid, readstressoncgrid, 
     +stressisoncgrid, rotatestressonagrid, useatmwind, userelativewind
     +, nonegativeevap, usestabilityfct_overice, diags_opoceweighted
C
      COMMON /exf_param_i/ select_zenalbedo, exf_debuglev, 
     +exf_adjmonselect, hfluxstartdate1, hfluxstartdate2, 
     +atempstartdate1, atempstartdate2, aqhstartdate1, aqhstartdate2, 
     +hs_startdate1, hs_startdate2, hl_startdate1, hl_startdate2, 
     +sfluxstartdate1, sfluxstartdate2, evapstartdate1, evapstartdate2, 
     +runoffstartdate1, runoffstartdate2, saltflxstartdate1, 
     +saltflxstartdate2, precipstartdate1, precipstartdate2, 
     +snowprecipstartdate1, snowprecipstartdate2, ustressstartdate1, 
     +ustressstartdate2, vstressstartdate1, vstressstartdate2, 
     +uwindstartdate1, uwindstartdate2, vwindstartdate1, vwindstartdate2
     +, wspeedstartdate1, wspeedstartdate2, swfluxstartdate1, 
     +swfluxstartdate2, lwfluxstartdate1, lwfluxstartdate2, 
     +swdownstartdate1, swdownstartdate2, lwdownstartdate1, 
     +lwdownstartdate2, apressurestartdate1, apressurestartdate2, 
     +tidepotstartdate1, tidepotstartdate2, areamaskstartdate1, 
     +areamaskstartdate2, obcsnstartdate1, obcsnstartdate2, 
     +obcssstartdate1, obcssstartdate2, obcsestartdate1, obcsestartdate2
     +, obcswstartdate1, obcswstartdate2, siobnstartdate1, 
     +siobnstartdate2, siobsstartdate1, siobsstartdate2, siobestartdate1
     +, siobestartdate2, siobwstartdate1, siobwstartdate2
C
      COMMON /exf_param_r/ repeatperiod, exf_monfreq, exf_adjmonfreq, 
     +exf_scal_bulkcdn, windstressmax, hfluxconst, hfluxrepcycle, 
     +hfluxperiod, hfluxstarttime, atempconst, atemprepcycle, 
     +atempperiod, atempstarttime, aqhconst, aqhrepcycle, aqhperiod, 
     +aqhstarttime, hs_const, hs_repcycle, hs_period, hs_starttime, 
     +hl_const, hl_repcycle, hl_period, hl_starttime, sfluxconst, 
     +sfluxrepcycle, sfluxperiod, sfluxstarttime, evapconst, 
     +evaprepcycle, evapperiod, evapstarttime, precipconst, 
     +preciprepcycle, precipperiod, precipstarttime, snowprecipconst, 
     +snowpreciprepcycle, snowprecipperiod, snowprecipstarttime, 
     +runoffconst, runoffrepcycle, runoffperiod, runoffstarttime, 
     +runoftempconst, saltflxconst, saltflxrepcycle, saltflxperiod, 
     +saltflxstarttime, ustressconst, ustressrepcycle, ustressperiod, 
     +ustressstarttime, vstressconst, vstressrepcycle, vstressperiod, 
     +vstressstarttime, uwindconst, uwindrepcycle, uwindperiod, 
     +uwindstarttime, vwindconst, vwindrepcycle, vwindperiod, 
     +vwindstarttime, wspeedconst, wspeedrepcycle, wspeedperiod, 
     +wspeedstarttime, swfluxconst, swfluxrepcycle, swfluxperiod, 
     +swfluxstarttime, lwfluxconst, lwfluxrepcycle, lwfluxperiod, 
     +lwfluxstarttime, swdownconst, swdownrepcycle, swdownperiod, 
     +swdownstarttime, lwdownconst, lwdownrepcycle, lwdownperiod, 
     +lwdownstarttime, apressureconst, apressurerepcycle, 
     +apressureperiod, apressurestarttime, tidepotconst, tidepotrepcycle
     +, tidepotperiod, tidepotstarttime, areamaskconst, areamaskrepcycle
     +, areamaskperiod, areamaskstarttime, obcsnrepcycle, obcsnperiod, 
     +obcsnstarttime, obcssrepcycle, obcssperiod, obcssstarttime, 
     +obcserepcycle, obcseperiod, obcsestarttime, obcswrepcycle, 
     +obcswperiod, obcswstarttime, siobnrepcycle, siobnperiod, 
     +siobnstarttime, siobsrepcycle, siobsperiod, siobsstarttime, 
     +sioberepcycle, siobeperiod, siobestarttime, siobwrepcycle, 
     +siobwperiod, siobwstarttime
C
      COMMON /exf_param_trend_removal/ hflux_exfremo_intercept, 
     +atemp_exfremo_intercept, aqh_exfremo_intercept, 
     +hs_exfremo_intercept, hl_exfremo_intercept, 
     +sflux_exfremo_intercept, evap_exfremo_intercept, 
     +precip_exfremo_intercept, snowprecip_exfremo_intercept, 
     +runoff_exfremo_intercept, runoftemp_exfremo_intercept, 
     +saltflx_exfremo_intercept, ustress_exfremo_intercept, 
     +vstress_exfremo_intercept, uwind_exfremo_intercept, 
     +vwind_exfremo_intercept, wspeed_exfremo_intercept, 
     +swflux_exfremo_intercept, lwflux_exfremo_intercept, 
     +swdown_exfremo_intercept, lwdown_exfremo_intercept, 
     +apressure_exfremo_intercept, tidepot_exfremo_intercept, 
     +areamask_exfremo_intercept, hflux_exfremo_slope, 
     +atemp_exfremo_slope, aqh_exfremo_slope, hs_exfremo_slope, 
     +hl_exfremo_slope, sflux_exfremo_slope, evap_exfremo_slope, 
     +precip_exfremo_slope, snowprecip_exfremo_slope, 
     +runoff_exfremo_slope, runoftemp_exfremo_slope, 
     +saltflx_exfremo_slope, ustress_exfremo_slope, 
     +vstress_exfremo_slope, uwind_exfremo_slope, vwind_exfremo_slope, 
     +wspeed_exfremo_slope, swflux_exfremo_slope, lwflux_exfremo_slope, 
     +swdown_exfremo_slope, lwdown_exfremo_slope, 
     +apressure_exfremo_slope, tidepot_exfremo_slope, 
     +areamask_exfremo_slope
C
      COMMON /exf_param_c/ hfluxfile, hfluxmask, atempfile, atempmask, 
     +aqhfile, aqhmask, hs_file, hs_mask, hl_file, hl_mask, sfluxfile, 
     +sfluxmask, evapfile, evapmask, precipfile, precipmask, 
     +snowprecipfile, snowprecipmask, runofffile, runoffmask, 
     +runoftempfile, saltflxfile, saltflxmask, ustressfile, ustressmask
     +, vstressfile, vstressmask, uwindfile, uwindmask, vwindfile, 
     +vwindmask, wspeedfile, wspeedmask, swfluxfile, swfluxmask, 
     +lwfluxfile, lwfluxmask, swdownfile, swdownmask, lwdownfile, 
     +lwdownmask, apressurefile, apressuremask, tidepotfile, tidepotmask
     +, areamaskfile, areamaskmask
C
      COMMON /exf_clim_i/ climsststartdate1, climsststartdate2, 
     +climsssstartdate1, climsssstartdate2, climustrstartdate1, 
     +climustrstartdate2, climvstrstartdate1, climvstrstartdate2
C
      COMMON /exf_clim_c/ climsstfile, climsstmask, climsssfile, 
     +climsssmask, climustrfile, climustrmask, climvstrfile, 
     +climvstrmask
C
      COMMON /exf_clim_r/ climtempfreeze, climsstconst, climsstrepcycle
     +, climsstperiod, climsststarttime, climsssconst, climsssrepcycle, 
     +climsssperiod, climsssstarttime, climustrconst, climustrrepcycle, 
     +climustrperiod, climustrstarttime, climvstrconst, climvstrrepcycle
     +, climvstrperiod, climvstrstarttime, climssttaurelax, 
     +climssstaurelax, climustrtaurelax, climvstrtaurelax, 
     +areamasktaurelax, climsst_exfremo_intercept, climsst_exfremo_slope
     +, climsss_exfremo_intercept, climsss_exfremo_slope, 
     +climustr_exfremo_intercept, climustr_exfremo_slope, 
     +climvstr_exfremo_intercept, climvstr_exfremo_slope, 
     +exf_inscal_climsst, exf_inscal_climsss, exf_inscal_climustr, 
     +exf_inscal_climvstr
C
C     file precision and field type
C
      COMMON /exf_param_type/ exf_iprec, exf_iprec_obcs
C
      INTEGER exf_iprec
      INTEGER exf_iprec_obcs
C
C-    Scaling factors:
C     exf_inscal_{fld}   :: input scaling factors
C     exf_offset_atemp   :: input air temperature offset
C                        :: (for conversion from C to K, if needed)
C     exf_outscale_{fld} :: output scaling factors
C
      REAL*8 exf_inscal_hflux
      REAL*8 exf_inscal_sflux
      REAL*8 exf_inscal_ustress
      REAL*8 exf_inscal_vstress
      REAL*8 exf_inscal_uwind
      REAL*8 exf_inscal_vwind
      REAL*8 exf_inscal_wspeed
      REAL*8 exf_inscal_swflux
      REAL*8 exf_inscal_lwflux
      REAL*8 exf_inscal_precip
      REAL*8 exf_inscal_snowprecip
C     Real*8     exf_inscal_sst
C     Real*8     exf_inscal_sss
      REAL*8 exf_inscal_atemp, exf_offset_atemp
      REAL*8 exf_inscal_aqh
      REAL*8 exf_inscal_hs
      REAL*8 exf_inscal_hl
      REAL*8 exf_inscal_evap
      REAL*8 exf_inscal_apressure
      REAL*8 exf_inscal_runoff
      REAL*8 exf_inscal_runoftemp
      REAL*8 exf_inscal_saltflx
      REAL*8 exf_inscal_swdown
      REAL*8 exf_inscal_lwdown
      REAL*8 exf_inscal_tidepot
      REAL*8 exf_inscal_areamask
      REAL*8 exf_inscal_climsst
      REAL*8 exf_inscal_climsss
      REAL*8 exf_inscal_climustr
      REAL*8 exf_inscal_climvstr
C
      REAL*8 exf_outscal_hflux
      REAL*8 exf_outscal_sflux
      REAL*8 exf_outscal_ustress
      REAL*8 exf_outscal_vstress
      REAL*8 exf_outscal_swflux
      REAL*8 exf_outscal_sst
      REAL*8 exf_outscal_sss
      REAL*8 exf_outscal_apressure
      REAL*8 exf_outscal_tidepot
      REAL*8 exf_outscal_areamask
C
C    &                      exf_inscal_sst,
      COMMON /exf_param_scal/ exf_inscal_hflux, exf_inscal_sflux, 
     +exf_inscal_ustress, exf_inscal_vstress, exf_inscal_uwind, 
     +exf_inscal_vwind, exf_inscal_wspeed, exf_inscal_swflux, 
     +exf_inscal_lwflux, exf_inscal_precip, exf_inscal_snowprecip, 
     +exf_inscal_atemp, exf_offset_atemp, exf_inscal_aqh, exf_inscal_hs
     +, exf_inscal_hl, exf_inscal_evap, exf_inscal_apressure, 
     +exf_inscal_runoff, exf_inscal_runoftemp, exf_inscal_saltflx, 
     +exf_inscal_swdown, exf_inscal_lwdown, exf_inscal_tidepot, 
     +exf_inscal_areamask, exf_outscal_hflux, exf_outscal_sflux, 
     +exf_outscal_ustress, exf_outscal_vstress, exf_outscal_swflux, 
     +exf_outscal_sst, exf_outscal_sss, exf_outscal_apressure, 
     +exf_outscal_tidepot, exf_outscal_areamask
C    &                      exf_inscal_sss,
C
C- note: pkg/exf Interpolation parameters (#ifdef USE_EXF_INTERPOLATION )
C   have been moved to specific header file: EXF_INTERP_PARAM.h
CBOP
C     !ROUTINE: EXF_INTERP_PARAM.h
C     !INTERFACE:
C     include "EXF_INTERP_PARAM.h"
C     !DESCRIPTION:
C     \bv
C     *==========================================================*
C     | EXF_INTERP_PARAM.h
C     | o Hold parameters used for interpolation of
C     |   EXF surface forcing fileds
C     *==========================================================*
C     *==========================================================*
C     \ev
CEOP
C
C
CBOP
C    !ROUTINE: PTRACERS_PARAMS.h
C    !INTERFACE:
C #include PTRACERS_PARAMS.h
C
C    !DESCRIPTION:
C Contains passive tracer parameters.
C
CEOP
C
C--   COMMON /PTRACERS_PARAMS_R/ PTRACERS real-type parameters:
C     PTRACERS_dTLev    :: Timestep for ptracers ( s ), function of level k
C     PTRACERS_taveFreq :: Frequency with which time-averaged PTRACERS
C                          are written to post-processing files.
C     PTRACERS_ref      :: vertical profile for passive tracers, in
C                          analogy to tRef and sRef, hence the name
C     PTRACERS_EvPrRn   :: tracer concentration in Rain, Evap & RunOff
C       notes: a) used if both NonLin_FrSurf & useRealFreshWater are set.
C              b) use pTracer surface (local) value if = UNSET_RL (default)
C     PTRACERS_startStepFwd :: time to start stepping forward this tracer
C     PTRACERS_resetFreq    :: Frequency (s) to reset ptracers to original val
C     PTRACERS_resetPhase   :: Phase (s) to reset ptracers
C
      REAL*8 ptracers_dtlev(nr)
      REAL*8 ptracers_dumpfreq
      REAL*8 ptracers_tavefreq
      REAL*8 ptracers_monitorfreq
      REAL*8 ptracers_diffkh(ptracers_num)
      REAL*8 ptracers_diffk4(ptracers_num)
      REAL*8 ptracers_diffkrnr(nr, ptracers_num)
      REAL*8 ptracers_ref(nr, ptracers_num)
      REAL*8 ptracers_evprrn(ptracers_num)
      REAL*8 ptracers_startstepfwd(ptracers_num)
      REAL*8 ptracers_resetfreq(ptracers_num)
      REAL*8 ptracers_resetphase(ptracers_num)
      COMMON /ptracers_params_r/ ptracers_dtlev, ptracers_dumpfreq, 
     +ptracers_tavefreq, ptracers_monitorfreq, ptracers_diffkh, 
     +ptracers_diffk4, ptracers_diffkrnr, ptracers_ref, ptracers_evprrn
     +, ptracers_startstepfwd, ptracers_resetfreq, ptracers_resetphase
C
C     COMMON /PTRACERS_OLD_R/ Old (real type) PTRACERS parameters
C        (to be removed 1 day ...)
      REAL*8 lambdatr1climrelax
      COMMON /ptracers_old_r/ lambdatr1climrelax
C
C--   COMMON /PTRACERS_PARAMS_I/ PTRACERS integer-type parameters:
C     PTRACERS_numInUse :: number of tracers to use
C     PTRACERS_Iter0    :: timestep number when tracers are initialized
      INTEGER ptracers_iter0
      INTEGER ptracers_numinuse
      INTEGER ptracers_advscheme(ptracers_num)
      COMMON /ptracers_params_i/ ptracers_iter0, ptracers_numinuse, 
     +ptracers_advscheme
C
C--   COMMON /PTRACERS_PARAMS_L/ PTRACERS logical-type parameters:
C     PTRACERS_ImplVertAdv   :: use Implicit Vertical Advection for this tracer
C     PTRACERS_MultiDimAdv   :: internal flag (depend on the advection scheme),
C                               true if this tracer uses Multi-Dim advection
C     PTRACERS_SOM_Advection :: internal flag (depend on the advection scheme),
C                               true if this tracer uses 2nd-order moment advection
C     PTRACERS_AdamsBashGtr  :: internal flag (depend on the advection scheme),
C                               true if applies Adams-Bashforth on tracer tendency
C     PTRACERS_AdamsBash_Tr  :: internal flag (depend on the advection scheme),
C                               true if applies Adams-Bashforth on passive Tracer
C     PTRACERS_useGMRedi(n)  :: true if GM-Redi applies to pTracer n
C     PTRACERS_useDWNSLP(n)  :: true if Down-Sloping flow applies to pTracer n
C     PTRACERS_useKPP(n)     :: true if KPP applies to pTracer n
C     PTRACERS_doAB_onGpTr   :: if Adams-Bashforth time stepping is used, apply
C                               AB on tracer tendencies (rather than on Tracers)
C     PTRACERS_addSrelax2EmP :: add Salt relaxation to EmP
C     PTRACERS_startAllTrc   :: internal flag, all tracers start at startTime
C     PTRACERS_calcSurfCor   :: calculate Linear Free-Surf source/sink of tracer
C                               (set internally)
C     PTRACERS_linFSConserve :: apply mean Free-Surf source/sink at surface
C     PTRACERS_stayPositive  :: use Smolarkiewicz Hack to ensure Tracer stays >0
C     PTRACERS_useRecords    :: snap-shot output: put all pTracers in one file
      LOGICAL ptracers_implvertadv(ptracers_num)
      LOGICAL ptracers_multidimadv(ptracers_num)
      LOGICAL ptracers_som_advection(ptracers_num)
      LOGICAL ptracers_adamsbashgtr(ptracers_num)
      LOGICAL ptracers_adamsbash_tr(ptracers_num)
      LOGICAL ptracers_usegmredi(ptracers_num)
      LOGICAL ptracers_usedwnslp(ptracers_num)
      LOGICAL ptracers_usekpp(ptracers_num)
      LOGICAL ptracers_linfsconserve(ptracers_num)
      LOGICAL ptracers_staypositive(ptracers_num)
      LOGICAL ptracers_doab_ongptr
      LOGICAL ptracers_addsrelax2emp
      LOGICAL ptracers_startalltrc
      LOGICAL ptracers_calcsurfcor
      LOGICAL ptracers_userecords
      LOGICAL ptracers_monitor_mnc, ptracers_monitor_stdio, 
     +        ptracers_timeave_mdsio, ptracers_snapshot_mdsio, 
     +        ptracers_pickup_write_mdsio, ptracers_pickup_read_mdsio, 
     +        ptracers_timeave_mnc, ptracers_snapshot_mnc, 
     +        ptracers_pickup_write_mnc, ptracers_pickup_read_mnc
      COMMON /ptracers_params_l/ ptracers_implvertadv, 
     +ptracers_multidimadv, ptracers_som_advection, 
     +ptracers_adamsbashgtr, ptracers_adamsbash_tr, ptracers_usegmredi, 
     +ptracers_usedwnslp, ptracers_usekpp, ptracers_linfsconserve, 
     +ptracers_staypositive, ptracers_doab_ongptr, 
     +ptracers_addsrelax2emp, ptracers_startalltrc, ptracers_calcsurfcor
     +, ptracers_userecords, ptracers_timeave_mdsio, 
     +ptracers_snapshot_mdsio, ptracers_pickup_write_mdsio, 
     +ptracers_pickup_read_mdsio, ptracers_monitor_stdio, 
     +ptracers_monitor_mnc, ptracers_timeave_mnc, ptracers_snapshot_mnc
     +, ptracers_pickup_write_mnc, ptracers_pickup_read_mnc
C
C--   COMMON /PTRACERS_PARAMS_C/ PTRACERS character-type parameters:
      CHARACTER*(max_len_fnam) ptracers_initialfile(ptracers_num)
      CHARACTER*(max_len_fnam) ptracers_names(ptracers_num)
      CHARACTER*(max_len_fnam) ptracers_long_names(ptracers_num)
      CHARACTER*(max_len_fnam) ptracers_units(ptracers_num)
      COMMON /ptracers_params_c/ ptracers_initialfile, ptracers_names, 
     +ptracers_long_names, ptracers_units
C
C     COMMON /PTRACERS_LABELS/ holds pTracers labels
C     PTRACERS_ioLabel  :: pTracer I/O & diagnostics label (2 charecters long)
      COMMON /ptracers_labels/ ptracers_iolabel
      CHARACTER*2 ptracers_iolabel(ptracers_num)
C
C
CEH3 ;;; Local Variables: ***
CEH3 ;;; mode:fortran ***
CEH3 ;;; End: ***
C
C**************************************
C
C     !INPUT/OUTPUT PARAMETERS:
C     == Routine arguments ==
C     note: under the multi-threaded model myIter and
C           myTime are local variables passed around as routine
C           arguments. Although this is fiddly it saves the need to
C           impose additional synchronisation points when they are
C           updated.
C     myTime :: time counter for this thread
C     myIter :: iteration counter for this thread
C     myThid :: thread number for this instance of the routine.
      REAL*8 mytime
      INTEGER myiter
      INTEGER mythid
C
C     !FUNCTIONS:
C     == Functions ==
C
C     !LOCAL VARIABLES:
C     == Local variables ==
      INTEGER iloop
      EXTERNAL DEBUG_ENTER
      INTRINSIC NINT
      EXTERNAL DEBUG_CALL
      EXTERNAL TIMER_START
      EXTERNAL TIMER_STOP
      EXTERNAL BARRIER
      EXTERNAL DEBUG_LEAVE
CEOP
C
      LOGICAL ADBINOMIAL_NEXT
      INTEGER ad_count
      INTEGER i
      INTEGER ii4
      INTEGER ii3
      INTEGER ii2
      INTEGER ii1
      INTEGER ii5
      INTEGER ii6
      INTEGER action
      INTEGER step
C--   Set initial conditions (variable arrays)
      CALL PUSHREAL8ARRAY(rstarexps, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(rstarexpw, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(rstarexpc, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(rstarfacnm1s, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(rstarfacnm1w, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(rstarfacnm1c, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(rstarfacs, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(rstarfacw, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(rstarfacc, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(rmin_surf, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(hfac_surfnm1s, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                   )
      CALL PUSHREAL8ARRAY(hfac_surfnm1w, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                   )
      CALL PUSHREAL8ARRAY(hfac_surfnm1c, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                   )
      CALL PUSHREAL8ARRAY(hfac_surfs, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(hfac_surfw, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(hfac_surfc, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(pmepr, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(detahdt, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(pload, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(lambdasaltclimrelax, (snx+2*olx)*(sny+2*oly)*
     +                    nsx*nsy)
      CALL PUSHREAL8ARRAY(lambdathetaclimrelax, (snx+2*olx)*(sny+2*oly)*
     +                    nsx*nsy)
      CALL PUSHREAL8ARRAY(sss, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(sst, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(saltflux, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(empmr, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(qsw, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(qnet, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(fv, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(fu, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(tices, (snx+2*olx)*(sny+2*oly)*nitd*nsx*nsy)
      CALL PUSHREAL8ARRAY(scalarproductmetric, nvec*nsx*nsy)
      CALL PUSHREAL8ARRAY(seaice_sigma12, (snx+2*olx)*(sny+2*oly)*nsx*
     +                    nsy)
      CALL PUSHREAL8ARRAY(seaice_sigma2, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                   )
      CALL PUSHREAL8ARRAY(seaice_sigma1, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                   )
      CALL PUSHREAL8ARRAY(vice, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(uice, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(hsnow, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(heff, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(area, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(seaicemaskv, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(seaicemasku, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(heffm, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(phihydlow, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(totphihyd, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL PUSHREAL8ARRAY(etah, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(gsnm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL PUSHREAL8ARRAY(gtnm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL PUSHREAL8ARRAY(gvnm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL PUSHREAL8ARRAY(gunm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL PUSHREAL8ARRAY(salt, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL PUSHREAL8ARRAY(theta, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL PUSHREAL8ARRAY(wvel, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL PUSHREAL8ARRAY(vvel, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL PUSHREAL8ARRAY(uvel, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL PUSHREAL8ARRAY(etan, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(hfacs, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL PUSHREAL8ARRAY(hfacw, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL PUSHREAL8ARRAY(hfacc, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL PUSHREAL8ARRAY(ras, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(raw, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(vnm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL PUSHREAL8ARRAY(unm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL PUSHREAL8ARRAY(etanm1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL PUSHREAL8ARRAY(vveld, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL PUSHREAL8ARRAY(uveld, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL PUSHREAL8ARRAY(gptrnm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy*
     +                    ptracers_num)
      CALL PUSHREAL8ARRAY(ptracer, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy*
     +                    ptracers_num)
      CALL PUSHREAL8ARRAY(wgentim2d, (snx+2*olx)*(sny+2*oly)*nsx*nsy*
     +                    maxctrltim2d)
      CALL PUSHREAL8ARRAY(wgenarr3d, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy*
     +                    maxctrlarr3d)
      CALL PUSHREAL8ARRAY(wgenarr2d, (snx+2*olx)*(sny+2*oly)*nsx*nsy*
     +                    maxctrlarr2d)
      CALL PUSHREAL8ARRAY(xx_gentim2d_dummy, maxctrltim2d)
      CALL PUSHINTEGER4(mythid)
      CALL INITIALISE_VARIA(mythid)
C
C
C--   Do the model integration.
      iloop = 1
      CALL ADBINOMIAL_INIT(nTimeSteps+1, 98, 1)
      DO 100 WHILE (ADBINOMIAL_NEXT(action, step))
        SELECT CASE (action) 
        CASE (1) 
C    Push Snapshot:
          CALL PUSHREAL8ARRAY(aw2d, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(as2d, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(ac2d, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(ufluxtave, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                       )
          CALL PUSHREAL8ARRAY(vfluxtave, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                       )
          CALL PUSHREAL8ARRAY(tfluxtave, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                       )
          CALL PUSHREAL8ARRAY(sfluxtave, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                       )
          CALL PUSHREAL8ARRAY(tdiffrtave, (snx+2*olx)*(sny+2*oly)*nr*nsx
     +                        *nsy)
          CALL PUSHREAL8ARRAY(uzetatave, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(vzetatave, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(convectcounttave, (snx+2*olx)*(sny+2*oly)*
     +                        nr*nsx*nsy)
          CALL PUSHREAL8ARRAY(dwtransc, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(dwtransu, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(dwtransv, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(saltplumedepth, (snx+2*olx)*(sny+2*oly)*
     +                        nsx*nsy)
          CALL PUSHREAL8ARRAY(saltplumeflux, (snx+2*olx)*(sny+2*oly)*nsx
     +                        *nsy)
          CALL PUSHREAL8ARRAY(gm_timeave, nsx*nsy)
          CALL PUSHREAL8ARRAY(gm_kwx_t, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(gm_kwy_t, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(gm_kwz_t, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(gm_psixtave, (snx+2*olx)*(sny+2*oly)*nr*
     +                        nsx*nsy)
          CALL PUSHREAL8ARRAY(gm_psiytave, (snx+2*olx)*(sny+2*oly)*nr*
     +                        nsx*nsy)
          CALL PUSHREAL8ARRAY(kppviscaz, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(kppdiffkzt, (snx+2*olx)*(sny+2*oly)*nr*nsx
     +                        *nsy)
          CALL PUSHREAL8ARRAY(kppdiffkzs, (snx+2*olx)*(sny+2*oly)*nr*nsx
     +                        *nsy)
          CALL PUSHREAL8ARRAY(kppghat, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(kpphbl, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(kppplumefrac, (snx+2*olx)*(sny+2*oly)*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(kppfrac, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(kwx, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL PUSHREAL8ARRAY(kwy, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL PUSHREAL8ARRAY(kwz, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL PUSHREAL8ARRAY(kux, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL PUSHREAL8ARRAY(kvy, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL PUSHREAL8ARRAY(kuz, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL PUSHREAL8ARRAY(kvz, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL PUSHREAL8ARRAY(gm_psix, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(gm_psiy, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(xx_gentim2d0, (snx+2*olx)*(sny+2*oly)*nsx*
     +                        nsy*maxctrltim2d)
          CALL PUSHREAL8ARRAY(xx_gentim2d1, (snx+2*olx)*(sny+2*oly)*nsx*
     +                        nsy*maxctrltim2d)
          CALL PUSHREAL8ARRAY(xx_gentim2d, (snx+2*olx)*(sny+2*oly)*nsx*
     +                        nsy*maxctrltim2d)
          CALL PUSHREAL8ARRAY(ptracer, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                        nsy*ptracers_num)
          CALL PUSHREAL8ARRAY(surfaceforcingptr, (snx+2*olx)*(sny+2*oly)
     +                        *nsx*nsy*ptracers_num)
          CALL PUSHREAL8ARRAY(cmeantheta, (snx+2*olx)*(sny+2*oly)*nr*nsx
     +                        *nsy)
          CALL PUSHREAL8ARRAY(cmeanuvel, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(cmeanvvel, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(cmeanthetauvel, (snx+2*olx)*(sny+2*oly)*nr
     +                        *nsx*nsy)
          CALL PUSHREAL8ARRAY(cmeanthetavvel, (snx+2*olx)*(sny+2*oly)*nr
     +                        *nsx*nsy)
          CALL PUSHREAL8ARRAY(uveld, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL PUSHREAL8ARRAY(vveld, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL PUSHREAL8ARRAY(etanm1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(unm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL PUSHREAL8ARRAY(vnm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL PUSHREAL8ARRAY(hfacc, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL PUSHREAL8ARRAY(hfacw, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL PUSHREAL8ARRAY(hfacs, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL PUSHREAL8ARRAY(recip_hfacc, (snx+2*olx)*(sny+2*oly)*nr*
     +                        nsx*nsy)
          CALL PUSHREAL8ARRAY(recip_hfacw, (snx+2*olx)*(sny+2*oly)*nr*
     +                        nsx*nsy)
          CALL PUSHREAL8ARRAY(recip_hfacs, (snx+2*olx)*(sny+2*oly)*nr*
     +                        nsx*nsy)
          CALL PUSHREAL8ARRAY(etan, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(uvel, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL PUSHREAL8ARRAY(vvel, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL PUSHREAL8ARRAY(wvel, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL PUSHREAL8ARRAY(theta, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL PUSHREAL8ARRAY(salt, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL PUSHREAL8ARRAY(gu, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL PUSHREAL8ARRAY(gv, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL PUSHREAL8ARRAY(gunm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL PUSHREAL8ARRAY(gvnm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL PUSHREAL8ARRAY(gtnm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL PUSHREAL8ARRAY(gsnm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL PUSHREAL8ARRAY(etah, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(rhoinsitu, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(totphihyd, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(phihydlow, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                       )
          CALL PUSHREAL8ARRAY(ivdconvcount, (snx+2*olx)*(sny+2*oly)*nr*
     +                        nsx*nsy)
          CALL PUSHREAL8ARRAY(ustress, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(vstress, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(ustress0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(ustress1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(vstress0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(vstress1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(wspeed, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(wspeed0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(wspeed1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(uwind, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(vwind, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(uwind0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(uwind1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(vwind0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(vwind1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(hflux, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(sflux, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(hflux0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(hflux1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(sflux0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(sflux1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(atemp, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(aqh, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(hs, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(hl, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(lwflux, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(evap, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(precip, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(snowprecip, (snx+2*olx)*(sny+2*oly)*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(atemp0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(atemp1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(aqh0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(aqh1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(lwflux0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(lwflux1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(precip0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(precip1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(snowprecip0, (snx+2*olx)*(sny+2*oly)*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(snowprecip1, (snx+2*olx)*(sny+2*oly)*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(wstress, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(cw, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(sw, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(sh, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(swflux, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(swflux0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(swflux1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(swdown, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(lwdown, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(swdown0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(swdown1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(lwdown0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(lwdown1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(apressure, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                       )
          CALL PUSHREAL8ARRAY(apressure0, (snx+2*olx)*(sny+2*oly)*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(apressure1, (snx+2*olx)*(sny+2*oly)*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(runoff, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(runoff0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(runoff1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(saltflx, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(saltflx0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(saltflx1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(climsst, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(climsst0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(climsst1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(climsss, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(climsss0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(climsss1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(area, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(heff, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(hsnow, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(uice, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(vice, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(dwatn, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(uicenm1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(vicenm1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(stressdivergencex, (snx+2*olx)*(sny+2*oly)
     +                        *nsx*nsy)
          CALL PUSHREAL8ARRAY(stressdivergencey, (snx+2*olx)*(sny+2*oly)
     +                        *nsx*nsy)
          CALL PUSHREAL8ARRAY(seaice_sigma1, (snx+2*olx)*(sny+2*oly)*nsx
     +                        *nsy)
          CALL PUSHREAL8ARRAY(seaice_sigma2, (snx+2*olx)*(sny+2*oly)*nsx
     +                        *nsy)
          CALL PUSHREAL8ARRAY(seaice_sigma12, (snx+2*olx)*(sny+2*oly)*
     +                        nsx*nsy)
          CALL PUSHREAL8ARRAY(eta, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(etaz, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(zeta, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(zetaz, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(press, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(e11, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(e22, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(e12, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(deltac, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(forcex, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(forcey, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(press0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(forcex0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(forcey0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(seaicemassc, (snx+2*olx)*(sny+2*oly)*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(seaicemassu, (snx+2*olx)*(sny+2*oly)*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(seaicemassv, (snx+2*olx)*(sny+2*oly)*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(d_heffbyneg, (snx+2*olx)*(sny+2*oly)*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(d_hsnwbyneg, (snx+2*olx)*(sny+2*oly)*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(tices, (snx+2*olx)*(sny+2*oly)*nitd*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(fu, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(fv, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(qnet, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(qsw, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(empmr, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(saltflux, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(sst, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(sss, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(pload, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(siceload, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(gcmsst, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHINTEGER4ARRAY(loadedrec, nsx*nsy)
          CALL PUSHREAL8ARRAY(taux0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(tauy0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(qnet0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(empmr0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(sst0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(sss0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(taux1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(tauy1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(qnet1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(empmr1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(sst1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(sss1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(saltflux0, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                       )
          CALL PUSHREAL8ARRAY(saltflux1, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                       )
          CALL PUSHREAL8ARRAY(qsw0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(qsw1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(pload0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(pload1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(surfaceforcingu, (snx+2*olx)*(sny+2*oly)*
     +                        nsx*nsy)
          CALL PUSHREAL8ARRAY(surfaceforcingv, (snx+2*olx)*(sny+2*oly)*
     +                        nsx*nsy)
          CALL PUSHREAL8ARRAY(surfaceforcingt, (snx+2*olx)*(sny+2*oly)*
     +                        nsx*nsy)
          CALL PUSHREAL8ARRAY(surfaceforcings, (snx+2*olx)*(sny+2*oly)*
     +                        nsx*nsy)
          CALL PUSHREAL8ARRAY(adjustcoldsst_diag, (snx+2*olx)*(sny+2*oly
     +                        )*nsx*nsy)
          CALL PUSHREAL8ARRAY(botdragu, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(botdragv, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(phi0surf, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(detahdt, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(pmepr, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL PUSHREAL8ARRAY(hfac_surfc, (snx+2*olx)*(sny+2*oly)*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(hfac_surfw, (snx+2*olx)*(sny+2*oly)*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(hfac_surfs, (snx+2*olx)*(sny+2*oly)*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(hfac_surfnm1c, (snx+2*olx)*(sny+2*oly)*nsx
     +                        *nsy)
          CALL PUSHREAL8ARRAY(hfac_surfnm1w, (snx+2*olx)*(sny+2*oly)*nsx
     +                        *nsy)
          CALL PUSHREAL8ARRAY(hfac_surfnm1s, (snx+2*olx)*(sny+2*oly)*nsx
     +                        *nsy)
          CALL PUSHREAL8ARRAY(rstarfacc, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                       )
          CALL PUSHREAL8ARRAY(rstarfacw, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                       )
          CALL PUSHREAL8ARRAY(rstarfacs, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                       )
          CALL PUSHREAL8ARRAY(pstarfack, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                       )
          CALL PUSHREAL8ARRAY(rstarfacnm1c, (snx+2*olx)*(sny+2*oly)*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(rstarfacnm1w, (snx+2*olx)*(sny+2*oly)*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(rstarfacnm1s, (snx+2*olx)*(sny+2*oly)*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(rstarexpc, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                       )
          CALL PUSHREAL8ARRAY(rstarexpw, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                       )
          CALL PUSHREAL8ARRAY(rstarexps, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                       )
          CALL PUSHREAL8ARRAY(rstardhcdt, (snx+2*olx)*(sny+2*oly)*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(rstardhwdt, (snx+2*olx)*(sny+2*oly)*nsx*
     +                        nsy)
          CALL PUSHREAL8ARRAY(rstardhsdt, (snx+2*olx)*(sny+2*oly)*nsx*
     +                        nsy)
          CALL PUSHINTEGER4(mythid)
          CALL PUSHINTEGER4(iloop)
          GOTO 100
        CASE (2) 
C    Look Snapshot:
          CALL ADSTACK_STARTREPEAT()
          CALL POPINTEGER4(iloop)
          CALL POPINTEGER4(mythid)
          CALL POPREAL8ARRAY(rstardhsdt, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                      )
          CALL POPREAL8ARRAY(rstardhwdt, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                      )
          CALL POPREAL8ARRAY(rstardhcdt, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                      )
          CALL POPREAL8ARRAY(rstarexps, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(rstarexpw, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(rstarexpc, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(rstarfacnm1s, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(rstarfacnm1w, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(rstarfacnm1c, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(pstarfack, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(rstarfacs, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(rstarfacw, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(rstarfacc, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(hfac_surfnm1s, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(hfac_surfnm1w, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(hfac_surfnm1c, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(hfac_surfs, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                      )
          CALL POPREAL8ARRAY(hfac_surfw, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                      )
          CALL POPREAL8ARRAY(hfac_surfc, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                      )
          CALL POPREAL8ARRAY(pmepr, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(detahdt, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(phi0surf, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(botdragv, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(botdragu, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(adjustcoldsst_diag, (snx+2*olx)*(sny+2*oly)
     +                       *nsx*nsy)
          CALL POPREAL8ARRAY(surfaceforcings, (snx+2*olx)*(sny+2*oly)*
     +                       nsx*nsy)
          CALL POPREAL8ARRAY(surfaceforcingt, (snx+2*olx)*(sny+2*oly)*
     +                       nsx*nsy)
          CALL POPREAL8ARRAY(surfaceforcingv, (snx+2*olx)*(sny+2*oly)*
     +                       nsx*nsy)
          CALL POPREAL8ARRAY(surfaceforcingu, (snx+2*olx)*(sny+2*oly)*
     +                       nsx*nsy)
          CALL POPREAL8ARRAY(pload1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(pload0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(qsw1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(qsw0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(saltflux1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(saltflux0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(sss1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(sst1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(empmr1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(qnet1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(tauy1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(taux1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(sss0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(sst0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(empmr0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(qnet0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(tauy0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(taux0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPINTEGER4ARRAY(loadedrec, nsx*nsy)
          CALL POPREAL8ARRAY(gcmsst, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(siceload, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(pload, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(sss, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(sst, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(saltflux, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(empmr, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(qsw, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(qnet, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(fv, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(fu, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(tices, (snx+2*olx)*(sny+2*oly)*nitd*nsx*nsy
     +                      )
          CALL POPREAL8ARRAY(d_hsnwbyneg, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(d_heffbyneg, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(seaicemassv, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(seaicemassu, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(seaicemassc, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(forcey0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(forcex0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(press0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(forcey, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(forcex, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(deltac, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(e12, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(e22, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(e11, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(press, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(zetaz, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(zeta, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(etaz, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(eta, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(seaice_sigma12, (snx+2*olx)*(sny+2*oly)*nsx
     +                       *nsy)
          CALL POPREAL8ARRAY(seaice_sigma2, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(seaice_sigma1, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(stressdivergencey, (snx+2*olx)*(sny+2*oly)*
     +                       nsx*nsy)
          CALL POPREAL8ARRAY(stressdivergencex, (snx+2*olx)*(sny+2*oly)*
     +                       nsx*nsy)
          CALL POPREAL8ARRAY(vicenm1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(uicenm1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(dwatn, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(vice, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(uice, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(hsnow, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(heff, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(area, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(climsss1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(climsss0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(climsss, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(climsst1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(climsst0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(climsst, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(saltflx1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(saltflx0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(saltflx, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(runoff1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(runoff0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(runoff, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(apressure1, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                      )
          CALL POPREAL8ARRAY(apressure0, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                      )
          CALL POPREAL8ARRAY(apressure, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(lwdown1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(lwdown0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(swdown1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(swdown0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(lwdown, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(swdown, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(swflux1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(swflux0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(swflux, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(sh, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(sw, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(cw, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(wstress, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(snowprecip1, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(snowprecip0, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(precip1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(precip0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(lwflux1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(lwflux0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(aqh1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(aqh0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(atemp1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(atemp0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(snowprecip, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                      )
          CALL POPREAL8ARRAY(precip, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(evap, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(lwflux, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(hl, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(hs, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(aqh, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(atemp, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(sflux1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(sflux0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(hflux1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(hflux0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(sflux, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(hflux, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(vwind1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(vwind0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(uwind1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(uwind0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(vwind, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(uwind, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(wspeed1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(wspeed0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(wspeed, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(vstress1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(vstress0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(ustress1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(ustress0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(vstress, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(ustress, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(ivdconvcount, (snx+2*olx)*(sny+2*oly)*nr*
     +                       nsx*nsy)
          CALL POPREAL8ARRAY(phihydlow, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(totphihyd, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(rhoinsitu, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(etah, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(gsnm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(gtnm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(gvnm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(gunm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(gv, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(gu, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
c ====== BEGIN manual I/O: forward fields (hFacC, theta, salt) ======
      open(unit=500, file='hFacC_v4_soma.data')
      open(unit=501, file='theta_v4_soma.data')
      open(unit=502, file='salt_v4_soma.data')
      DO ii1=1,nsy
        DO ii2=1,nsx
          DO ii3=1,nr
            DO ii4=1-oly,oly+sny
              DO ii5=1-olx,olx+snx
                write(500,*) hFacC(ii5,ii4,ii3,ii2,ii1)
                write(501,*) theta(ii5,ii4,ii3,ii2,ii1)
                write(502,*) salt (ii5,ii4,ii3,ii2,ii1)
              END DO
            END DO
          END DO
        END DO
      END DO
      close(500)
      close(501)
      close(502)
c ====== END manual I/O: forward fields ======
          CALL POPREAL8ARRAY(salt, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(theta, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(wvel, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(vvel, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(uvel, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(etan, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(recip_hfacs, (snx+2*olx)*(sny+2*oly)*nr*nsx
     +                       *nsy)
          CALL POPREAL8ARRAY(recip_hfacw, (snx+2*olx)*(sny+2*oly)*nr*nsx
     +                       *nsy)
          CALL POPREAL8ARRAY(recip_hfacc, (snx+2*olx)*(sny+2*oly)*nr*nsx
     +                       *nsy)
          CALL POPREAL8ARRAY(hfacs, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(hfacw, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(hfacc, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(vnm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(unm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(etanm1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(vveld, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(uveld, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(cmeanthetavvel, (snx+2*olx)*(sny+2*oly)*nr*
     +                       nsx*nsy)
          CALL POPREAL8ARRAY(cmeanthetauvel, (snx+2*olx)*(sny+2*oly)*nr*
     +                       nsx*nsy)
          CALL POPREAL8ARRAY(cmeanvvel, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(cmeanuvel, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(cmeantheta, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(surfaceforcingptr, (snx+2*olx)*(sny+2*oly)*
     +                       nsx*nsy*ptracers_num)
          CALL POPREAL8ARRAY(ptracer, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy
     +                       *ptracers_num)
          CALL POPREAL8ARRAY(xx_gentim2d, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy*maxctrltim2d)
          CALL POPREAL8ARRAY(xx_gentim2d1, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy*maxctrltim2d)
          CALL POPREAL8ARRAY(xx_gentim2d0, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy*maxctrltim2d)
          CALL POPREAL8ARRAY(gm_psiy, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy
     +                      )
          CALL POPREAL8ARRAY(gm_psix, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy
     +                      )
          CALL POPREAL8ARRAY(kvz, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(kuz, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(kvy, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(kux, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(kwz, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(kwy, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(kwx, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(kppfrac, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(kppplumefrac, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(kpphbl, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(kppghat, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy
     +                      )
          CALL POPREAL8ARRAY(kppdiffkzs, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(kppdiffkzt, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(kppviscaz, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(gm_psiytave, (snx+2*olx)*(sny+2*oly)*nr*nsx
     +                       *nsy)
          CALL POPREAL8ARRAY(gm_psixtave, (snx+2*olx)*(sny+2*oly)*nr*nsx
     +                       *nsy)
          CALL POPREAL8ARRAY(gm_kwz_t, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(gm_kwy_t, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(gm_kwx_t, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(gm_timeave, nsx*nsy)
          CALL POPREAL8ARRAY(saltplumeflux, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(saltplumedepth, (snx+2*olx)*(sny+2*oly)*nsx
     +                       *nsy)
          CALL POPREAL8ARRAY(dwtransv, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(dwtransu, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(dwtransc, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(convectcounttave, (snx+2*olx)*(sny+2*oly)*
     +                       nr*nsx*nsy)
          CALL POPREAL8ARRAY(vzetatave, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(uzetatave, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(tdiffrtave, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(sfluxtave, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(tfluxtave, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(vfluxtave, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(ufluxtave, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(ac2d, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(as2d, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(aw2d, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL ADSTACK_RESETREPEAT()
          CALL ADSTACK_ENDREPEAT()
          GOTO 100
        CASE (3) 
C    Pop Snapshot:
          CALL POPINTEGER4(iloop)
          CALL POPINTEGER4(mythid)
          CALL POPREAL8ARRAY(rstardhsdt, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                      )
          CALL POPREAL8ARRAY(rstardhwdt, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                      )
          CALL POPREAL8ARRAY(rstardhcdt, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                      )
          CALL POPREAL8ARRAY(rstarexps, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(rstarexpw, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(rstarexpc, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(rstarfacnm1s, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(rstarfacnm1w, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(rstarfacnm1c, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(pstarfack, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(rstarfacs, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(rstarfacw, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(rstarfacc, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(hfac_surfnm1s, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(hfac_surfnm1w, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(hfac_surfnm1c, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(hfac_surfs, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                      )
          CALL POPREAL8ARRAY(hfac_surfw, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                      )
          CALL POPREAL8ARRAY(hfac_surfc, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                      )
          CALL POPREAL8ARRAY(pmepr, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(detahdt, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(phi0surf, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(botdragv, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(botdragu, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(adjustcoldsst_diag, (snx+2*olx)*(sny+2*oly)
     +                       *nsx*nsy)
          CALL POPREAL8ARRAY(surfaceforcings, (snx+2*olx)*(sny+2*oly)*
     +                       nsx*nsy)
          CALL POPREAL8ARRAY(surfaceforcingt, (snx+2*olx)*(sny+2*oly)*
     +                       nsx*nsy)
          CALL POPREAL8ARRAY(surfaceforcingv, (snx+2*olx)*(sny+2*oly)*
     +                       nsx*nsy)
          CALL POPREAL8ARRAY(surfaceforcingu, (snx+2*olx)*(sny+2*oly)*
     +                       nsx*nsy)
          CALL POPREAL8ARRAY(pload1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(pload0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(qsw1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(qsw0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(saltflux1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(saltflux0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(sss1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(sst1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(empmr1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(qnet1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(tauy1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(taux1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(sss0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(sst0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(empmr0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(qnet0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(tauy0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(taux0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPINTEGER4ARRAY(loadedrec, nsx*nsy)
          CALL POPREAL8ARRAY(gcmsst, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(siceload, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(pload, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(sss, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(sst, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(saltflux, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(empmr, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(qsw, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(qnet, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(fv, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(fu, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(tices, (snx+2*olx)*(sny+2*oly)*nitd*nsx*nsy
     +                      )
          CALL POPREAL8ARRAY(d_hsnwbyneg, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(d_heffbyneg, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(seaicemassv, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(seaicemassu, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(seaicemassc, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(forcey0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(forcex0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(press0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(forcey, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(forcex, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(deltac, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(e12, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(e22, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(e11, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(press, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(zetaz, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(zeta, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(etaz, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(eta, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(seaice_sigma12, (snx+2*olx)*(sny+2*oly)*nsx
     +                       *nsy)
          CALL POPREAL8ARRAY(seaice_sigma2, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(seaice_sigma1, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(stressdivergencey, (snx+2*olx)*(sny+2*oly)*
     +                       nsx*nsy)
          CALL POPREAL8ARRAY(stressdivergencex, (snx+2*olx)*(sny+2*oly)*
     +                       nsx*nsy)
          CALL POPREAL8ARRAY(vicenm1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(uicenm1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(dwatn, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(vice, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(uice, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(hsnow, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(heff, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(area, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(climsss1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(climsss0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(climsss, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(climsst1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(climsst0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(climsst, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(saltflx1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(saltflx0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(saltflx, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(runoff1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(runoff0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(runoff, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(apressure1, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                      )
          CALL POPREAL8ARRAY(apressure0, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                      )
          CALL POPREAL8ARRAY(apressure, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(lwdown1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(lwdown0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(swdown1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(swdown0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(lwdown, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(swdown, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(swflux1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(swflux0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(swflux, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(sh, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(sw, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(cw, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(wstress, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(snowprecip1, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(snowprecip0, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(precip1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(precip0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(lwflux1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(lwflux0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(aqh1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(aqh0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(atemp1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(atemp0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(snowprecip, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                      )
          CALL POPREAL8ARRAY(precip, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(evap, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(lwflux, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(hl, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(hs, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(aqh, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(atemp, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(sflux1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(sflux0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(hflux1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(hflux0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(sflux, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(hflux, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(vwind1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(vwind0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(uwind1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(uwind0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(vwind, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(uwind, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(wspeed1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(wspeed0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(wspeed, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(vstress1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(vstress0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(ustress1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(ustress0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(vstress, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(ustress, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(ivdconvcount, (snx+2*olx)*(sny+2*oly)*nr*
     +                       nsx*nsy)
          CALL POPREAL8ARRAY(phihydlow, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(totphihyd, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(rhoinsitu, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(etah, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(gsnm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(gtnm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(gvnm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(gunm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(gv, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(gu, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(salt, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(theta, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(wvel, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(vvel, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(uvel, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(etan, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(recip_hfacs, (snx+2*olx)*(sny+2*oly)*nr*nsx
     +                       *nsy)
          CALL POPREAL8ARRAY(recip_hfacw, (snx+2*olx)*(sny+2*oly)*nr*nsx
     +                       *nsy)
          CALL POPREAL8ARRAY(recip_hfacc, (snx+2*olx)*(sny+2*oly)*nr*nsx
     +                       *nsy)
          CALL POPREAL8ARRAY(hfacs, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(hfacw, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(hfacc, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(vnm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(unm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(etanm1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(vveld, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(uveld, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(cmeanthetavvel, (snx+2*olx)*(sny+2*oly)*nr*
     +                       nsx*nsy)
          CALL POPREAL8ARRAY(cmeanthetauvel, (snx+2*olx)*(sny+2*oly)*nr*
     +                       nsx*nsy)
          CALL POPREAL8ARRAY(cmeanvvel, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(cmeanuvel, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(cmeantheta, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(surfaceforcingptr, (snx+2*olx)*(sny+2*oly)*
     +                       nsx*nsy*ptracers_num)
          CALL POPREAL8ARRAY(ptracer, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy
     +                       *ptracers_num)
          CALL POPREAL8ARRAY(xx_gentim2d, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy*maxctrltim2d)
          CALL POPREAL8ARRAY(xx_gentim2d1, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy*maxctrltim2d)
          CALL POPREAL8ARRAY(xx_gentim2d0, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy*maxctrltim2d)
          CALL POPREAL8ARRAY(gm_psiy, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy
     +                      )
          CALL POPREAL8ARRAY(gm_psix, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy
     +                      )
          CALL POPREAL8ARRAY(kvz, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(kuz, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(kvy, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(kux, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(kwz, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(kwy, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(kwx, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
          CALL POPREAL8ARRAY(kppfrac, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(kppplumefrac, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(kpphbl, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(kppghat, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy
     +                      )
          CALL POPREAL8ARRAY(kppdiffkzs, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(kppdiffkzt, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(kppviscaz, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(gm_psiytave, (snx+2*olx)*(sny+2*oly)*nr*nsx
     +                       *nsy)
          CALL POPREAL8ARRAY(gm_psixtave, (snx+2*olx)*(sny+2*oly)*nr*nsx
     +                       *nsy)
          CALL POPREAL8ARRAY(gm_kwz_t, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(gm_kwy_t, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(gm_kwx_t, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(gm_timeave, nsx*nsy)
          CALL POPREAL8ARRAY(saltplumeflux, (snx+2*olx)*(sny+2*oly)*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(saltplumedepth, (snx+2*olx)*(sny+2*oly)*nsx
     +                       *nsy)
          CALL POPREAL8ARRAY(dwtransv, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(dwtransu, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(dwtransc, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(convectcounttave, (snx+2*olx)*(sny+2*oly)*
     +                       nr*nsx*nsy)
          CALL POPREAL8ARRAY(vzetatave, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(uzetatave, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(tdiffrtave, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                       nsy)
          CALL POPREAL8ARRAY(sfluxtave, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(tfluxtave, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(vfluxtave, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(ufluxtave, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(ac2d, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(as2d, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          CALL POPREAL8ARRAY(aw2d, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
          GOTO 100
        CASE (4) 
C    Advance:
C
C     >>>>>>>>>>>>>>>>>>>>>>>>>>>   LOOP   <<<<<<<<<<<<<<<<<<<<<<<<<<<<
C     >>>>>>>>>>>>>>>>>>>>>>>>>>>  STARTS  <<<<<<<<<<<<<<<<<<<<<<<<<<<<
C
C
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C--
C**************************************
C
C
C TANVIR---The immediate next line isn't a comment, it is implementing
C binomial checkpointing for tapenade; fortran compilers will treat it
C as a comment and ignore (that's why putting "C" before is crucial) but
C tapenade won't ignore it|| why +1 in the 1st arg? =>
C ans is tapenade considers exiting the timeloop as another step || 2nd
C arg refers to the num of timesteps/snapshots we are storing in memory,
C the more the better until the code crashes; this limit will keep
C changing depending on the grid size of simulation, i.e., for finer
C grid you will be able to store small number of snapshots in memory.
C However, the ultimate limit is 98, this is the maximum we can go and
C it is hardcoded in tapenade|| 3rd arg is the starting number of
C iteration, should usually be 1.
C
          IF (iloop .LE. ntimesteps) THEN
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C
C--     >>> Loop body start <<<
C
            niter0 = NINT((starttime-basetime)/deltatclock)
C--   Reset the model iteration counter and the model time.
            myiter = niter0 + (iloop-1)
            mytime = starttime + deltatclock*(iloop-1)
C
C
C
            CALL TIMER_START('MAIN_DO_LOOP        [THE_MAIN_LOOP]', 
     +                       mythid)
            CALL MAIN_DO_LOOP(iloop, mytime, myiter, mythid)
            CALL TIMER_STOP('MAIN_DO_LOOP        [THE_MAIN_LOOP]', 
     +                      mythid)
C
C
C--     >>> Loop body end <<<
            iloop = iloop + 1
            GOTO 100
          ELSE
            CALL ADBINOMIAL_RESIZE()
          END IF
        CASE (5) 
C    First Turn:
          ad_count = 1
C
C     >>>>>>>>>>>>>>>>>>>>>>>>>>>   LOOP   <<<<<<<<<<<<<<<<<<<<<<<<<<<<
C     >>>>>>>>>>>>>>>>>>>>>>>>>>>  STARTS  <<<<<<<<<<<<<<<<<<<<<<<<<<<<
C
C
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C--
C**************************************
C
C
C TANVIR---The immediate next line isn't a comment, it is implementing
C binomial checkpointing for tapenade; fortran compilers will treat it
C as a comment and ignore (that's why putting "C" before is crucial) but
C tapenade won't ignore it|| why +1 in the 1st arg? =>
C ans is tapenade considers exiting the timeloop as another step || 2nd
C arg refers to the num of timesteps/snapshots we are storing in memory,
C the more the better until the code crashes; this limit will keep
C changing depending on the grid size of simulation, i.e., for finer
C grid you will be able to store small number of snapshots in memory.
C However, the ultimate limit is 98, this is the maximum we can go and
C it is hardcoded in tapenade|| 3rd arg is the starting number of
C iteration, should usually be 1.
C
          DO WHILE (iloop .LE. ntimesteps)
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C
C--     >>> Loop body start <<<
C
            CALL PUSHINTEGER4(niter0)
            niter0 = NINT((starttime-basetime)/deltatclock)
C--   Reset the model iteration counter and the model time.
C
C
C
            CALL PUSHREAL8ARRAY(rstardhsdt, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(rstardhwdt, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(rstardhcdt, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(rstarexps, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(rstarexpw, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(rstarexpc, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(rstarfacnm1s, (snx+2*olx)*(sny+2*oly)*
     +                          nsx*nsy)
            CALL PUSHREAL8ARRAY(rstarfacnm1w, (snx+2*olx)*(sny+2*oly)*
     +                          nsx*nsy)
            CALL PUSHREAL8ARRAY(rstarfacnm1c, (snx+2*olx)*(sny+2*oly)*
     +                          nsx*nsy)
            CALL PUSHREAL8ARRAY(pstarfack, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(rstarfacs, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(rstarfacw, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(rstarfacc, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(hfac_surfnm1s, (snx+2*olx)*(sny+2*oly)*
     +                          nsx*nsy)
            CALL PUSHREAL8ARRAY(hfac_surfnm1w, (snx+2*olx)*(sny+2*oly)*
     +                          nsx*nsy)
            CALL PUSHREAL8ARRAY(hfac_surfnm1c, (snx+2*olx)*(sny+2*oly)*
     +                          nsx*nsy)
            CALL PUSHREAL8ARRAY(hfac_surfs, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(hfac_surfw, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(hfac_surfc, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(pmepr, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(detahdt, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(phi0surf, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(botdragv, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(botdragu, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(adjustcoldsst_diag, (snx+2*olx)*(sny+2*
     +                          oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(surfaceforcings, (snx+2*olx)*(sny+2*oly)
     +                          *nsx*nsy)
            CALL PUSHREAL8ARRAY(surfaceforcingt, (snx+2*olx)*(sny+2*oly)
     +                          *nsx*nsy)
            CALL PUSHREAL8ARRAY(surfaceforcingv, (snx+2*olx)*(sny+2*oly)
     +                          *nsx*nsy)
            CALL PUSHREAL8ARRAY(surfaceforcingu, (snx+2*olx)*(sny+2*oly)
     +                          *nsx*nsy)
            CALL PUSHREAL8ARRAY(pload1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(pload0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(qsw1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(qsw0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(saltflux1, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(saltflux0, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(sss1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(sst1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(empmr1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(qnet1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(tauy1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(taux1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(sss0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(sst0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(empmr0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(qnet0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(tauy0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(taux0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHINTEGER4ARRAY(loadedrec, nsx*nsy)
            CALL PUSHREAL8ARRAY(gcmsst, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(siceload, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(pload, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(sss, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(sst, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(saltflux, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(empmr, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(qsw, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(qnet, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(fv, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(fu, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(tices, (snx+2*olx)*(sny+2*oly)*nitd*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(d_hsnwbyneg, (snx+2*olx)*(sny+2*oly)*nsx
     +                          *nsy)
            CALL PUSHREAL8ARRAY(d_heffbyneg, (snx+2*olx)*(sny+2*oly)*nsx
     +                          *nsy)
            CALL PUSHREAL8ARRAY(seaicemassv, (snx+2*olx)*(sny+2*oly)*nsx
     +                          *nsy)
            CALL PUSHREAL8ARRAY(seaicemassu, (snx+2*olx)*(sny+2*oly)*nsx
     +                          *nsy)
            CALL PUSHREAL8ARRAY(seaicemassc, (snx+2*olx)*(sny+2*oly)*nsx
     +                          *nsy)
            CALL PUSHREAL8ARRAY(forcey0, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(forcex0, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(press0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(forcey, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(forcex, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(deltac, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(e12, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(e22, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(e11, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(press, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(zetaz, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(zeta, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(etaz, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(eta, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(seaice_sigma12, (snx+2*olx)*(sny+2*oly)*
     +                          nsx*nsy)
            CALL PUSHREAL8ARRAY(seaice_sigma2, (snx+2*olx)*(sny+2*oly)*
     +                          nsx*nsy)
            CALL PUSHREAL8ARRAY(seaice_sigma1, (snx+2*olx)*(sny+2*oly)*
     +                          nsx*nsy)
            CALL PUSHREAL8ARRAY(stressdivergencey, (snx+2*olx)*(sny+2*
     +                          oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(stressdivergencex, (snx+2*olx)*(sny+2*
     +                          oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(vicenm1, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(uicenm1, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(dwatn, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(vice, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(uice, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(hsnow, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(heff, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(area, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(climsss1, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(climsss0, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(climsss, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(climsst1, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(climsst0, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(climsst, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(saltflx1, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(saltflx0, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(saltflx, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(runoff1, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(runoff0, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(runoff, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(apressure1, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(apressure0, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(apressure, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(lwdown1, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(lwdown0, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(swdown1, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(swdown0, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(lwdown, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(swdown, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(swflux1, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(swflux0, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(swflux, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(sh, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(sw, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(cw, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(wstress, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(snowprecip1, (snx+2*olx)*(sny+2*oly)*nsx
     +                          *nsy)
            CALL PUSHREAL8ARRAY(snowprecip0, (snx+2*olx)*(sny+2*oly)*nsx
     +                          *nsy)
            CALL PUSHREAL8ARRAY(precip1, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(precip0, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(lwflux1, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(lwflux0, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(aqh1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(aqh0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(atemp1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(atemp0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(snowprecip, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(precip, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(evap, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(lwflux, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(hl, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(hs, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(aqh, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(atemp, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(sflux1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(sflux0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(hflux1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(hflux0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(sflux, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(hflux, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(vwind1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(vwind0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(uwind1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(uwind0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(vwind, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(uwind, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(wspeed1, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(wspeed0, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(wspeed, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(vstress1, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(vstress0, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(ustress1, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(ustress0, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(vstress, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(ustress, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(ivdconvcount, (snx+2*olx)*(sny+2*oly)*nr
     +                          *nsx*nsy)
            CALL PUSHREAL8ARRAY(phihydlow, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(totphihyd, (snx+2*olx)*(sny+2*oly)*nr*
     +                          nsx*nsy)
            CALL PUSHREAL8ARRAY(rhoinsitu, (snx+2*olx)*(sny+2*oly)*nr*
     +                          nsx*nsy)
            CALL PUSHREAL8ARRAY(etah, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(gsnm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(gtnm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(gvnm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(gunm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(gv, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
            CALL PUSHREAL8ARRAY(gu, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
            CALL PUSHREAL8ARRAY(salt, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(theta, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(wvel, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(vvel, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(uvel, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(etan, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(recip_hfacs, (snx+2*olx)*(sny+2*oly)*nr*
     +                          nsx*nsy)
            CALL PUSHREAL8ARRAY(recip_hfacw, (snx+2*olx)*(sny+2*oly)*nr*
     +                          nsx*nsy)
            CALL PUSHREAL8ARRAY(recip_hfacc, (snx+2*olx)*(sny+2*oly)*nr*
     +                          nsx*nsy)
            CALL PUSHREAL8ARRAY(hfacs, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(hfacw, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(hfacc, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(vnm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(unm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(etanm1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(vveld, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(uveld, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(cmeanthetavvel, (snx+2*olx)*(sny+2*oly)*
     +                          nr*nsx*nsy)
            CALL PUSHREAL8ARRAY(cmeanthetauvel, (snx+2*olx)*(sny+2*oly)*
     +                          nr*nsx*nsy)
            CALL PUSHREAL8ARRAY(cmeanvvel, (snx+2*olx)*(sny+2*oly)*nr*
     +                          nsx*nsy)
            CALL PUSHREAL8ARRAY(cmeanuvel, (snx+2*olx)*(sny+2*oly)*nr*
     +                          nsx*nsy)
            CALL PUSHREAL8ARRAY(cmeantheta, (snx+2*olx)*(sny+2*oly)*nr*
     +                          nsx*nsy)
            CALL PUSHREAL8ARRAY(surfaceforcingptr, (snx+2*olx)*(sny+2*
     +                          oly)*nsx*nsy*ptracers_num)
            CALL PUSHREAL8ARRAY(ptracer, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                          nsy*ptracers_num)
            CALL PUSHREAL8ARRAY(xx_gentim2d, (snx+2*olx)*(sny+2*oly)*nsx
     +                          *nsy*maxctrltim2d)
            CALL PUSHREAL8ARRAY(xx_gentim2d1, (snx+2*olx)*(sny+2*oly)*
     +                          nsx*nsy*maxctrltim2d)
            CALL PUSHREAL8ARRAY(xx_gentim2d0, (snx+2*olx)*(sny+2*oly)*
     +                          nsx*nsy*maxctrltim2d)
            CALL PUSHREAL8ARRAY(gm_psiy, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(gm_psix, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(kvz, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
            CALL PUSHREAL8ARRAY(kuz, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
            CALL PUSHREAL8ARRAY(kvy, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
            CALL PUSHREAL8ARRAY(kux, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
            CALL PUSHREAL8ARRAY(kwz, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
            CALL PUSHREAL8ARRAY(kwy, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
            CALL PUSHREAL8ARRAY(kwx, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
            CALL PUSHREAL8ARRAY(kppfrac, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                         )
            CALL PUSHREAL8ARRAY(kppplumefrac, (snx+2*olx)*(sny+2*oly)*
     +                          nsx*nsy)
            CALL PUSHREAL8ARRAY(kpphbl, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(kppghat, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(kppdiffkzs, (snx+2*olx)*(sny+2*oly)*nr*
     +                          nsx*nsy)
            CALL PUSHREAL8ARRAY(kppdiffkzt, (snx+2*olx)*(sny+2*oly)*nr*
     +                          nsx*nsy)
            CALL PUSHREAL8ARRAY(kppviscaz, (snx+2*olx)*(sny+2*oly)*nr*
     +                          nsx*nsy)
            CALL PUSHREAL8ARRAY(gm_psiytave, (snx+2*olx)*(sny+2*oly)*nr*
     +                          nsx*nsy)
            CALL PUSHREAL8ARRAY(gm_psixtave, (snx+2*olx)*(sny+2*oly)*nr*
     +                          nsx*nsy)
            CALL PUSHREAL8ARRAY(gm_kwz_t, (snx+2*olx)*(sny+2*oly)*nr*nsx
     +                          *nsy)
            CALL PUSHREAL8ARRAY(gm_kwy_t, (snx+2*olx)*(sny+2*oly)*nr*nsx
     +                          *nsy)
            CALL PUSHREAL8ARRAY(gm_kwx_t, (snx+2*olx)*(sny+2*oly)*nr*nsx
     +                          *nsy)
            CALL PUSHREAL8ARRAY(gm_timeave, nsx*nsy)
            CALL PUSHREAL8ARRAY(saltplumeflux, (snx+2*olx)*(sny+2*oly)*
     +                          nsx*nsy)
            CALL PUSHREAL8ARRAY(saltplumedepth, (snx+2*olx)*(sny+2*oly)*
     +                          nsx*nsy)
            CALL PUSHREAL8ARRAY(dwtransv, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(dwtransu, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(dwtransc, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(convectcounttave, (snx+2*olx)*(sny+2*oly
     +                          )*nr*nsx*nsy)
            CALL PUSHREAL8ARRAY(vzetatave, (snx+2*olx)*(sny+2*oly)*nr*
     +                          nsx*nsy)
            CALL PUSHREAL8ARRAY(uzetatave, (snx+2*olx)*(sny+2*oly)*nr*
     +                          nsx*nsy)
            CALL PUSHREAL8ARRAY(tdiffrtave, (snx+2*olx)*(sny+2*oly)*nr*
     +                          nsx*nsy)
            CALL PUSHREAL8ARRAY(sfluxtave, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(tfluxtave, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(vfluxtave, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(ufluxtave, (snx+2*olx)*(sny+2*oly)*nsx*
     +                          nsy)
            CALL PUSHREAL8ARRAY(ac2d, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(as2d, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHREAL8ARRAY(aw2d, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
            CALL PUSHINTEGER4(mythid)
            CALL MAIN_DO_LOOP(iloop, mytime, myiter, mythid)
C
C
C--     >>> Loop body end <<<
            CALL PUSHINTEGER4(iloop)
            iloop = iloop + 1
            ad_count = ad_count + 1
          ENDDO
          CALL PUSHINTEGER4(ad_count)
        CASE (6) 
C    Turn:
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C
C--     >>> Loop body start <<<
C
          niter0 = NINT((starttime-basetime)/deltatclock)
C--   Reset the model iteration counter and the model time.
C
C
C
C
C
C--     >>> Loop body end <<<
          CALL MAIN_DO_LOOP_B(iloop, mytime, myiter, mythid)
          GOTO 100
        END SELECT
C
C     >>>>>>>>>>>>>>>>>>>>>>>>>>>   LOOP   <<<<<<<<<<<<<<<<<<<<<<<<<<<<
C     >>>>>>>>>>>>>>>>>>>>>>>>>>>  STOPS   <<<<<<<<<<<<<<<<<<<<<<<<<<<<
C
C
C
C
C--   Sum all cost function contributions.
        CALL PUSHREAL8ARRAY(objf_atl, nsx*nsy)
        CALL PUSHREAL8ARRAY(tile_fc, nsx*nsy)
        CALL COST_FINAL(mythid)
C
C
C
C
C
        CALL POPREAL8ARRAY(tile_fc, nsx*nsy)
        CALL POPREAL8ARRAY(objf_atl, nsx*nsy)
        CALL COST_FINAL_B(mythid)
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                dwtranscb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                dwtransub(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                dwtransvb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                saltplumedepthb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                saltplumefluxb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  kppviscazb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  kppdiffkztb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  kppdiffkzsb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  kppghatb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                kpphblb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                kppplumefracb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                kppfracb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  kwxb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  kwyb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  kwzb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  kuxb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  kvyb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  kuzb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  kvzb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  gm_psixb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  gm_psiyb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,maxctrltim2d
          xx_gentim2d_dummyb(ii1) = 0.D0
        ENDDO
        DO ii1=1,maxctrltim2d
          DO ii2=1,nsy
            DO ii3=1,nsx
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  xx_gentim2d0b(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,maxctrltim2d
          DO ii2=1,nsy
            DO ii3=1,nsx
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  xx_gentim2d1b(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,maxctrltim2d
          DO ii2=1,nsy
            DO ii3=1,nsx
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  xx_gentim2db(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,ptracers_num
          DO ii2=1,nsy
            DO ii3=1,nsx
              DO ii4=1,nr
                DO ii5=1-oly,oly+sny
                  DO ii6=1-olx,olx+snx
                    ptracerb(ii6, ii5, ii4, ii3, ii2, ii1) = 0.D0
                  ENDDO
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,ptracers_num
          DO ii2=1,nsy
            DO ii3=1,nsx
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  surfaceforcingptrb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  uveldb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  vveldb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                etanm1b(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  unm1b(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  vnm1b(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  hfaccb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  hfacwb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  hfacsb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  recip_hfaccb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  recip_hfacwb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  recip_hfacsb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                etanb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  uvelb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  vvelb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  wvelb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  thetab(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  saltb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  gub(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  gvb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  gunm1b(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  gvnm1b(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  gtnm1b(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  gsnm1b(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                etahb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  rhoinsitub(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nr
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  totphihydb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                ustressb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                vstressb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                wspeedb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                uwindb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                vwindb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                hfluxb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                sfluxb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                atempb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                aqhb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                hsb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                hlb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                lwfluxb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                evapb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                precipb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                snowprecipb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                wstressb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                cwb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                swb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                shb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                swfluxb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                swdownb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                lwdownb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                apressureb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                runoffb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                areab(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                heffb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                hsnowb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                d_heffbynegb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                d_hsnwbynegb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1,nitd
              DO ii4=1-oly,oly+sny
                DO ii5=1-olx,olx+snx
                  ticesb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                fub(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                fvb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                qnetb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                qswb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                empmrb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                saltfluxb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                sstb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                sssb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                ploadb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                siceloadb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                gcmsstb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                surfaceforcingub(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                surfaceforcingvb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                surfaceforcingtb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                surfaceforcingsb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                adjustcoldsst_diagb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                phi0surfb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                detahdtb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                pmeprb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                hfac_surfcb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                hfac_surfwb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                hfac_surfsb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                hfac_surfnm1cb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                hfac_surfnm1wb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                hfac_surfnm1sb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                rstarfaccb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                rstarfacwb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                rstarfacsb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                pstarfackb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                rstarfacnm1cb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                rstarfacnm1wb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                rstarfacnm1sb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                rstarexpcb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                rstarexpwb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                rstarexpsb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                rstardhcdtb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                rstardhwdtb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,nsy
          DO ii2=1,nsx
            DO ii3=1-oly,oly+sny
              DO ii4=1-olx,olx+snx
                rstardhsdtb(ii4, ii3, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        IF (action .NE. 4) THEN
          CALL POPINTEGER4(ad_count)
          DO i=1,ad_count
            IF (i .EQ. 1) THEN
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      dwtranscb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      dwtransub(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      dwtransvb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      saltplumedepthb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      saltplumefluxb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        kppviscazb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        kppdiffkztb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        kppdiffkzsb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        kppghatb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      kpphblb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      kppplumefracb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      kppfracb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        kwxb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        kwyb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        kwzb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        kuxb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        kvyb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        kuzb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        kvzb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        gm_psixb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        gm_psiyb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,maxctrltim2d
                xx_gentim2d_dummyb(ii1) = 0.D0
              ENDDO
              DO ii1=1,maxctrltim2d
                DO ii2=1,nsy
                  DO ii3=1,nsx
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        xx_gentim2d0b(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,maxctrltim2d
                DO ii2=1,nsy
                  DO ii3=1,nsx
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        xx_gentim2d1b(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,maxctrltim2d
                DO ii2=1,nsy
                  DO ii3=1,nsx
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        xx_gentim2db(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,ptracers_num
                DO ii2=1,nsy
                  DO ii3=1,nsx
                    DO ii4=1,nr
                      DO ii5=1-oly,oly+sny
                        DO ii6=1-olx,olx+snx
                          ptracerb(ii6, ii5, ii4, ii3, ii2, ii1) = 0.D0
                        ENDDO
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,ptracers_num
                DO ii2=1,nsy
                  DO ii3=1,nsx
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        surfaceforcingptrb(ii5, ii4, ii3, ii2, ii1) = 
     +                    0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        uveldb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        vveldb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      etanm1b(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        unm1b(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        vnm1b(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        hfaccb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        hfacwb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        hfacsb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        recip_hfaccb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        recip_hfacwb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        recip_hfacsb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      etanb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        uvelb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        vvelb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        wvelb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        thetab(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        saltb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        gub(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        gvb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        gunm1b(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        gvnm1b(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        gtnm1b(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        gsnm1b(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      etahb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        rhoinsitub(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nr
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        totphihydb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      ustressb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      vstressb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      wspeedb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      uwindb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      vwindb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      hfluxb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      sfluxb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      atempb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      aqhb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      hsb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      hlb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      lwfluxb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      evapb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      precipb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      snowprecipb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      wstressb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      cwb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      swb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      shb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      swfluxb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      swdownb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      lwdownb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      apressureb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      runoffb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      areab(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      heffb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      hsnowb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      d_heffbynegb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      d_hsnwbynegb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1,nitd
                    DO ii4=1-oly,oly+sny
                      DO ii5=1-olx,olx+snx
                        ticesb(ii5, ii4, ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      fub(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      fvb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      qnetb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      qswb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      empmrb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      saltfluxb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      sstb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      sssb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      ploadb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      siceloadb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      gcmsstb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      surfaceforcingub(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      surfaceforcingvb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      surfaceforcingtb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      surfaceforcingsb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      adjustcoldsst_diagb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      phi0surfb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      detahdtb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      pmeprb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      hfac_surfcb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      hfac_surfwb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      hfac_surfsb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      hfac_surfnm1cb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      hfac_surfnm1wb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      hfac_surfnm1sb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      rstarfaccb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      rstarfacwb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      rstarfacsb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      pstarfackb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      rstarfacnm1cb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      rstarfacnm1wb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      rstarfacnm1sb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      rstarexpcb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      rstarexpwb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      rstarexpsb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      rstardhcdtb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      rstardhwdtb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
              DO ii1=1,nsy
                DO ii2=1,nsx
                  DO ii3=1-oly,oly+sny
                    DO ii4=1-olx,olx+snx
                      rstardhsdtb(ii4, ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
            ELSE
              CALL POPINTEGER4(iloop)
              CALL POPINTEGER4(mythid)
              CALL POPREAL8ARRAY(aw2d, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(as2d, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(ac2d, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(ufluxtave, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(vfluxtave, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(tfluxtave, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(sfluxtave, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(tdiffrtave, (snx+2*olx)*(sny+2*oly)*nr*
     +                           nsx*nsy)
              CALL POPREAL8ARRAY(uzetatave, (snx+2*olx)*(sny+2*oly)*nr*
     +                           nsx*nsy)
              CALL POPREAL8ARRAY(vzetatave, (snx+2*olx)*(sny+2*oly)*nr*
     +                           nsx*nsy)
              CALL POPREAL8ARRAY(convectcounttave, (snx+2*olx)*(sny+2*
     +                           oly)*nr*nsx*nsy)
              CALL POPREAL8ARRAY(dwtransc, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(dwtransu, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(dwtransv, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(saltplumedepth, (snx+2*olx)*(sny+2*oly)
     +                           *nsx*nsy)
              CALL POPREAL8ARRAY(saltplumeflux, (snx+2*olx)*(sny+2*oly)*
     +                           nsx*nsy)
              CALL POPREAL8ARRAY(gm_timeave, nsx*nsy)
              CALL POPREAL8ARRAY(gm_kwx_t, (snx+2*olx)*(sny+2*oly)*nr*
     +                           nsx*nsy)
              CALL POPREAL8ARRAY(gm_kwy_t, (snx+2*olx)*(sny+2*oly)*nr*
     +                           nsx*nsy)
              CALL POPREAL8ARRAY(gm_kwz_t, (snx+2*olx)*(sny+2*oly)*nr*
     +                           nsx*nsy)
              CALL POPREAL8ARRAY(gm_psixtave, (snx+2*olx)*(sny+2*oly)*nr
     +                           *nsx*nsy)
              CALL POPREAL8ARRAY(gm_psiytave, (snx+2*olx)*(sny+2*oly)*nr
     +                           *nsx*nsy)
              CALL POPREAL8ARRAY(kppviscaz, (snx+2*olx)*(sny+2*oly)*nr*
     +                           nsx*nsy)
              CALL POPREAL8ARRAY(kppdiffkzt, (snx+2*olx)*(sny+2*oly)*nr*
     +                           nsx*nsy)
              CALL POPREAL8ARRAY(kppdiffkzs, (snx+2*olx)*(sny+2*oly)*nr*
     +                           nsx*nsy)
              CALL POPREAL8ARRAY(kppghat, (snx+2*olx)*(sny+2*oly)*nr*nsx
     +                           *nsy)
              CALL POPREAL8ARRAY(kpphbl, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(kppplumefrac, (snx+2*olx)*(sny+2*oly)*
     +                           nsx*nsy)
              CALL POPREAL8ARRAY(kppfrac, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(kwx, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(kwy, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(kwz, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(kux, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(kvy, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(kuz, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(kvz, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(gm_psix, (snx+2*olx)*(sny+2*oly)*nr*nsx
     +                           *nsy)
              CALL POPREAL8ARRAY(gm_psiy, (snx+2*olx)*(sny+2*oly)*nr*nsx
     +                           *nsy)
              CALL POPREAL8ARRAY(xx_gentim2d0, (snx+2*olx)*(sny+2*oly)*
     +                           nsx*nsy*maxctrltim2d)
              CALL POPREAL8ARRAY(xx_gentim2d1, (snx+2*olx)*(sny+2*oly)*
     +                           nsx*nsy*maxctrltim2d)
              CALL POPREAL8ARRAY(xx_gentim2d, (snx+2*olx)*(sny+2*oly)*
     +                           nsx*nsy*maxctrltim2d)
              CALL POPREAL8ARRAY(ptracer, (snx+2*olx)*(sny+2*oly)*nr*nsx
     +                           *nsy*ptracers_num)
              CALL POPREAL8ARRAY(surfaceforcingptr, (snx+2*olx)*(sny+2*
     +                           oly)*nsx*nsy*ptracers_num)
              CALL POPREAL8ARRAY(cmeantheta, (snx+2*olx)*(sny+2*oly)*nr*
     +                           nsx*nsy)
              CALL POPREAL8ARRAY(cmeanuvel, (snx+2*olx)*(sny+2*oly)*nr*
     +                           nsx*nsy)
              CALL POPREAL8ARRAY(cmeanvvel, (snx+2*olx)*(sny+2*oly)*nr*
     +                           nsx*nsy)
              CALL POPREAL8ARRAY(cmeanthetauvel, (snx+2*olx)*(sny+2*oly)
     +                           *nr*nsx*nsy)
              CALL POPREAL8ARRAY(cmeanthetavvel, (snx+2*olx)*(sny+2*oly)
     +                           *nr*nsx*nsy)
              CALL POPREAL8ARRAY(uveld, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(vveld, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(etanm1, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(unm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(vnm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(hfacc, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(hfacw, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(hfacs, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(recip_hfacc, (snx+2*olx)*(sny+2*oly)*nr
     +                           *nsx*nsy)
              CALL POPREAL8ARRAY(recip_hfacw, (snx+2*olx)*(sny+2*oly)*nr
     +                           *nsx*nsy)
              CALL POPREAL8ARRAY(recip_hfacs, (snx+2*olx)*(sny+2*oly)*nr
     +                           *nsx*nsy)
              CALL POPREAL8ARRAY(etan, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(uvel, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(vvel, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(wvel, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(theta, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(salt, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(gu, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
              CALL POPREAL8ARRAY(gv, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
              CALL POPREAL8ARRAY(gunm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(gvnm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(gtnm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(gsnm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(etah, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(rhoinsitu, (snx+2*olx)*(sny+2*oly)*nr*
     +                           nsx*nsy)
              CALL POPREAL8ARRAY(totphihyd, (snx+2*olx)*(sny+2*oly)*nr*
     +                           nsx*nsy)
              CALL POPREAL8ARRAY(phihydlow, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(ivdconvcount, (snx+2*olx)*(sny+2*oly)*
     +                           nr*nsx*nsy)
              CALL POPREAL8ARRAY(ustress, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(vstress, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(ustress0, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(ustress1, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(vstress0, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(vstress1, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(wspeed, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(wspeed0, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(wspeed1, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(uwind, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(vwind, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(uwind0, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(uwind1, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(vwind0, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(vwind1, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(hflux, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(sflux, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(hflux0, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(hflux1, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(sflux0, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(sflux1, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(atemp, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(aqh, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(hs, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(hl, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(lwflux, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(evap, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(precip, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(snowprecip, (snx+2*olx)*(sny+2*oly)*nsx
     +                           *nsy)
              CALL POPREAL8ARRAY(atemp0, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(atemp1, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(aqh0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(aqh1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(lwflux0, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(lwflux1, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(precip0, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(precip1, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(snowprecip0, (snx+2*olx)*(sny+2*oly)*
     +                           nsx*nsy)
              CALL POPREAL8ARRAY(snowprecip1, (snx+2*olx)*(sny+2*oly)*
     +                           nsx*nsy)
              CALL POPREAL8ARRAY(wstress, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(cw, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(sw, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(sh, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(swflux, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(swflux0, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(swflux1, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(swdown, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(lwdown, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(swdown0, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(swdown1, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(lwdown0, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(lwdown1, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(apressure, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(apressure0, (snx+2*olx)*(sny+2*oly)*nsx
     +                           *nsy)
              CALL POPREAL8ARRAY(apressure1, (snx+2*olx)*(sny+2*oly)*nsx
     +                           *nsy)
              CALL POPREAL8ARRAY(runoff, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(runoff0, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(runoff1, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(saltflx, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(saltflx0, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(saltflx1, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(climsst, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(climsst0, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(climsst1, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(climsss, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(climsss0, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(climsss1, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(area, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(heff, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(hsnow, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(uice, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(vice, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(dwatn, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(uicenm1, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(vicenm1, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(stressdivergencex, (snx+2*olx)*(sny+2*
     +                           oly)*nsx*nsy)
              CALL POPREAL8ARRAY(stressdivergencey, (snx+2*olx)*(sny+2*
     +                           oly)*nsx*nsy)
              CALL POPREAL8ARRAY(seaice_sigma1, (snx+2*olx)*(sny+2*oly)*
     +                           nsx*nsy)
              CALL POPREAL8ARRAY(seaice_sigma2, (snx+2*olx)*(sny+2*oly)*
     +                           nsx*nsy)
              CALL POPREAL8ARRAY(seaice_sigma12, (snx+2*olx)*(sny+2*oly)
     +                           *nsx*nsy)
              CALL POPREAL8ARRAY(eta, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(etaz, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(zeta, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(zetaz, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(press, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(e11, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(e22, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(e12, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(deltac, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(forcex, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(forcey, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(press0, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(forcex0, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(forcey0, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(seaicemassc, (snx+2*olx)*(sny+2*oly)*
     +                           nsx*nsy)
              CALL POPREAL8ARRAY(seaicemassu, (snx+2*olx)*(sny+2*oly)*
     +                           nsx*nsy)
              CALL POPREAL8ARRAY(seaicemassv, (snx+2*olx)*(sny+2*oly)*
     +                           nsx*nsy)
              CALL POPREAL8ARRAY(d_heffbyneg, (snx+2*olx)*(sny+2*oly)*
     +                           nsx*nsy)
              CALL POPREAL8ARRAY(d_hsnwbyneg, (snx+2*olx)*(sny+2*oly)*
     +                           nsx*nsy)
              CALL POPREAL8ARRAY(tices, (snx+2*olx)*(sny+2*oly)*nitd*nsx
     +                           *nsy)
              CALL POPREAL8ARRAY(fu, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(fv, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(qnet, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(qsw, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(empmr, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(saltflux, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(sst, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(sss, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(pload, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(siceload, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(gcmsst, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                          )
              CALL POPINTEGER4ARRAY(loadedrec, nsx*nsy)
              CALL POPREAL8ARRAY(taux0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(tauy0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(qnet0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(empmr0, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(sst0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(sss0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(taux1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(tauy1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(qnet1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(empmr1, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(sst1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(sss1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(saltflux0, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(saltflux1, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(qsw0, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(qsw1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(pload0, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(pload1, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                          )
              CALL POPREAL8ARRAY(surfaceforcingu, (snx+2*olx)*(sny+2*oly
     +                           )*nsx*nsy)
              CALL POPREAL8ARRAY(surfaceforcingv, (snx+2*olx)*(sny+2*oly
     +                           )*nsx*nsy)
              CALL POPREAL8ARRAY(surfaceforcingt, (snx+2*olx)*(sny+2*oly
     +                           )*nsx*nsy)
              CALL POPREAL8ARRAY(surfaceforcings, (snx+2*olx)*(sny+2*oly
     +                           )*nsx*nsy)
              CALL POPREAL8ARRAY(adjustcoldsst_diag, (snx+2*olx)*(sny+2*
     +                           oly)*nsx*nsy)
              CALL POPREAL8ARRAY(botdragu, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(botdragv, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(phi0surf, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(detahdt, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(pmepr, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
              CALL POPREAL8ARRAY(hfac_surfc, (snx+2*olx)*(sny+2*oly)*nsx
     +                           *nsy)
              CALL POPREAL8ARRAY(hfac_surfw, (snx+2*olx)*(sny+2*oly)*nsx
     +                           *nsy)
              CALL POPREAL8ARRAY(hfac_surfs, (snx+2*olx)*(sny+2*oly)*nsx
     +                           *nsy)
              CALL POPREAL8ARRAY(hfac_surfnm1c, (snx+2*olx)*(sny+2*oly)*
     +                           nsx*nsy)
              CALL POPREAL8ARRAY(hfac_surfnm1w, (snx+2*olx)*(sny+2*oly)*
     +                           nsx*nsy)
              CALL POPREAL8ARRAY(hfac_surfnm1s, (snx+2*olx)*(sny+2*oly)*
     +                           nsx*nsy)
              CALL POPREAL8ARRAY(rstarfacc, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(rstarfacw, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(rstarfacs, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(pstarfack, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(rstarfacnm1c, (snx+2*olx)*(sny+2*oly)*
     +                           nsx*nsy)
              CALL POPREAL8ARRAY(rstarfacnm1w, (snx+2*olx)*(sny+2*oly)*
     +                           nsx*nsy)
              CALL POPREAL8ARRAY(rstarfacnm1s, (snx+2*olx)*(sny+2*oly)*
     +                           nsx*nsy)
              CALL POPREAL8ARRAY(rstarexpc, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(rstarexpw, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(rstarexps, (snx+2*olx)*(sny+2*oly)*nsx*
     +                           nsy)
              CALL POPREAL8ARRAY(rstardhcdt, (snx+2*olx)*(sny+2*oly)*nsx
     +                           *nsy)
              CALL POPREAL8ARRAY(rstardhwdt, (snx+2*olx)*(sny+2*oly)*nsx
     +                           *nsy)
              CALL POPREAL8ARRAY(rstardhsdt, (snx+2*olx)*(sny+2*oly)*nsx
     +                           *nsy)
              CALL MAIN_DO_LOOP_B(iloop, mytime, myiter, mythid)
              CALL POPINTEGER4(niter0)
            END IF
          ENDDO
        END IF
 100  CONTINUE
      CALL POPINTEGER4(mythid)
      CALL POPREAL8ARRAY(xx_gentim2d_dummy, maxctrltim2d)
      CALL POPREAL8ARRAY(wgenarr2d, (snx+2*olx)*(sny+2*oly)*nsx*nsy*
     +                   maxctrlarr2d)
      CALL POPREAL8ARRAY(wgenarr3d, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy*
     +                   maxctrlarr3d)
      CALL POPREAL8ARRAY(wgentim2d, (snx+2*olx)*(sny+2*oly)*nsx*nsy*
     +                   maxctrltim2d)
      CALL POPREAL8ARRAY(ptracer, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy*
     +                   ptracers_num)
      CALL POPREAL8ARRAY(gptrnm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy*
     +                   ptracers_num)
      CALL POPREAL8ARRAY(uveld, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL POPREAL8ARRAY(vveld, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL POPREAL8ARRAY(etanm1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(unm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL POPREAL8ARRAY(vnm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL POPREAL8ARRAY(raw, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(ras, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(hfacc, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL POPREAL8ARRAY(hfacw, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL POPREAL8ARRAY(hfacs, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL POPREAL8ARRAY(etan, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(uvel, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL POPREAL8ARRAY(vvel, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL POPREAL8ARRAY(wvel, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL POPREAL8ARRAY(theta, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL POPREAL8ARRAY(salt, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL POPREAL8ARRAY(gunm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL POPREAL8ARRAY(gvnm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL POPREAL8ARRAY(gtnm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL POPREAL8ARRAY(gsnm1, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL POPREAL8ARRAY(etah, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(totphihyd, (snx+2*olx)*(sny+2*oly)*nr*nsx*nsy)
      CALL POPREAL8ARRAY(phihydlow, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(heffm, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(seaicemasku, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(seaicemaskv, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(area, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(heff, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(hsnow, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(uice, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(vice, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(seaice_sigma1, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(seaice_sigma2, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(seaice_sigma12, (snx+2*olx)*(sny+2*oly)*nsx*nsy
     +                  )
      CALL POPREAL8ARRAY(scalarproductmetric, nvec*nsx*nsy)
      CALL POPREAL8ARRAY(tices, (snx+2*olx)*(sny+2*oly)*nitd*nsx*nsy)
      CALL POPREAL8ARRAY(fu, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(fv, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(qnet, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(qsw, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(empmr, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(saltflux, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(sst, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(sss, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(lambdathetaclimrelax, (snx+2*olx)*(sny+2*oly)*
     +                   nsx*nsy)
      CALL POPREAL8ARRAY(lambdasaltclimrelax, (snx+2*olx)*(sny+2*oly)*
     +                   nsx*nsy)
      CALL POPREAL8ARRAY(pload, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(detahdt, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(pmepr, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(hfac_surfc, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(hfac_surfw, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(hfac_surfs, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(hfac_surfnm1c, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(hfac_surfnm1w, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(hfac_surfnm1s, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(rmin_surf, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(rstarfacc, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(rstarfacw, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(rstarfacs, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(rstarfacnm1c, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(rstarfacnm1w, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(rstarfacnm1s, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(rstarexpc, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(rstarexpw, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
      CALL POPREAL8ARRAY(rstarexps, (snx+2*olx)*(sny+2*oly)*nsx*nsy)
c ====== BEGIN manual I/O: adjoint fields (thetab, saltb) ======
      open(unit=503, file='thetab_v4_soma.data')
      open(unit=504, file='saltb_v4_soma.data')
      DO ii1=1,nsy
        DO ii2=1,nsx
          DO ii3=1,nr
            DO ii4=1-oly,oly+sny
              DO ii5=1-olx,olx+snx
                write(503,*) thetab(ii5,ii4,ii3,ii2,ii1)
                write(504,*) saltb (ii5,ii4,ii3,ii2,ii1)
              END DO
            END DO
          END DO
        END DO
      END DO
      close(503)
      close(504)
c ====== END manual I/O: adjoint fields ======
      CALL INITIALISE_VARIA_B(mythid)
      END
